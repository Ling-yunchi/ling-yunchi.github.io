<!-- build time:Thu Mar 31 2022 09:09:26 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="QWQ" href="https://ling-yunchi.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="QWQ" href="https://ling-yunchi.github.io/atom.xml"><link rel="alternate" type="application/json" title="QWQ" href="https://ling-yunchi.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://ling-yunchi.github.io/2021/07/30/Docker/"><title>Docker | Ling Yunchi = QWQ</title><meta name="generator" content="Hexo 5.4.1"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Docker</h1><div class="meta"><span class="item" title="创建时间：2021-07-30 15:01:53"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-07-30T15:01:53+08:00">2021-07-30</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Ling Yunchi</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclh5u05ej20zk0m87df.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giciuja1j1j20zk0m8kjl.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicljitigmj20zk0m87fp.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclwrdwyaj20zk0m8are.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicitspjpbj20zk0m81ky.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclflwv2aj20zk0m84qp.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://ling-yunchi.github.io/2021/07/30/Docker/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Ling yunchi"><meta itemprop="description" content=", qwqqqq"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="QWQ"></span><div class="body md" itemprop="articleBody"><h1 id="docker"><a class="anchor" href="#docker">#</a> Docker</h1><h2 id="docker常用命令"><a class="anchor" href="#docker常用命令">#</a> Docker 常用命令</h2><p>帮助命令:</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>docker version			<span class="token comment">#显示版本信息</span></pre></td></tr><tr><td data-num="2"></td><td><pre>docker info				<span class="token comment">#显示 Docker 的系统信息，包括镜像和容器的数量</span></pre></td></tr><tr><td data-num="3"></td><td><pre>docker <span class="token punctuation">[</span>commend<span class="token punctuation">]</span> --help	<span class="token comment">#查询 commend 的帮助</span></pre></td></tr></table></figure><h3 id="镜像的基本命令"><a class="anchor" href="#镜像的基本命令">#</a> 镜像的基本命令</h3><ul><li><p><strong>docker images</strong>: 查看所有本地的主机上的镜像</p><ul><li>-a 列出所有镜像</li><li>-q 只显示镜像的 id</li></ul></li><li><p><strong>docker search [image name]</strong>: 搜索镜像</p></li><li><p><strong>docekr pull</strong>: 下载镜像</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">#下载镜像 docker pull [image name][:tag]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token operator">></span> $ docker pull mysql</pre></td></tr><tr><td data-num="3"></td><td><pre>Using default tag: latest	<span class="token comment">#不指定 tag 时，下载的为最新版本</span></pre></td></tr><tr><td data-num="4"></td><td><pre>latest: Pulling from library/mysql</pre></td></tr><tr><td data-num="5"></td><td><pre>33847f680f63: Pull complete	<span class="token comment">#分层下载，docker image 的核心 联合文件系统</span></pre></td></tr><tr><td data-num="6"></td><td><pre>5cb67864e624: Pull complete</pre></td></tr><tr><td data-num="7"></td><td><pre>1a2b594783f5: Pull complete</pre></td></tr><tr><td data-num="8"></td><td><pre>b30e406dd925: Pull complete</pre></td></tr><tr><td data-num="9"></td><td><pre>48901e306e4c: Pull complete</pre></td></tr><tr><td data-num="10"></td><td><pre>603d2b7147fd: Pull complete</pre></td></tr><tr><td data-num="11"></td><td><pre>802aa684c1c4: Pull complete</pre></td></tr><tr><td data-num="12"></td><td><pre>715d3c143a06: Pull complete</pre></td></tr><tr><td data-num="13"></td><td><pre>6978e1b7a511: Pull complete</pre></td></tr><tr><td data-num="14"></td><td><pre>f0d78b0ac1be: Pull complete</pre></td></tr><tr><td data-num="15"></td><td><pre>35a94d251ed1: Pull complete</pre></td></tr><tr><td data-num="16"></td><td><pre>36f75719b1a9: Pull complete</pre></td></tr><tr><td data-num="17"></td><td><pre>Digest: sha256:8b928a5117cf5c2238c7a09cd28c2e801ac98f91c3f8203a8938ae51f14700fd	<span class="token comment">#签名</span></pre></td></tr><tr><td data-num="18"></td><td><pre>Status: Downloaded newer image <span class="token keyword">for</span> mysql:latest</pre></td></tr><tr><td data-num="19"></td><td><pre>docker.io/library/mysql:latest	<span class="token comment">#真实地址</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment"># docker pull mysql 等价于 docker pull docker.io/library/mysql:latest</span></pre></td></tr></table></figure></li><li><p><strong>docker image rm</strong>: 删除镜像</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>docker image <span class="token function">rm</span> -f <span class="token punctuation">[</span>image id<span class="token punctuation">]</span>	<span class="token comment">#删除指定镜像</span></pre></td></tr><tr><td data-num="2"></td><td><pre>docker rmi -f <span class="token punctuation">[</span>image id<span class="token punctuation">]</span>	<span class="token comment">#可简写为 rmi</span></pre></td></tr></table></figure></li></ul><h3 id="容器的基本命令"><a class="anchor" href="#容器的基本命令">#</a> 容器的基本命令</h3><ul><li><p><strong>docker run</strong>: 新建容器并启动</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>docker run <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> image <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>--name<span class="token operator">=</span><span class="token string">"name"</span>	<span class="token comment">#指定容器的名字，用于区分容器</span></pre></td></tr><tr><td data-num="4"></td><td><pre>-d				<span class="token comment">#后台方式运行</span></pre></td></tr><tr><td data-num="5"></td><td><pre>-it				<span class="token comment">#使用交互方式运行，进入容器查看内容</span></pre></td></tr><tr><td data-num="6"></td><td><pre>-p				<span class="token comment">#指定容器的端口</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	-p <span class="token punctuation">[</span>主机端口<span class="token punctuation">]</span>:<span class="token punctuation">[</span>容器端口<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	-p <span class="token punctuation">[</span>容器端口<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	-p <span class="token comment">#随机指定端口</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">#启动并进入容器</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token operator">></span> $ docker run -it --name<span class="token operator">=</span><span class="token string">"php"</span> -p <span class="token number">8080</span>:8080 php:7.4-apache /bin/bash</pre></td></tr><tr><td data-num="13"></td><td><pre>root@7f86025a83aa:/var/www/html<span class="token comment">#</span></pre></td></tr></table></figure></li><li><p><strong>docker ps</strong>: 查询容器</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>docker <span class="token function">ps</span>	<span class="token comment">#列出当前正在运行的容器</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	-a		<span class="token comment">#列出当前正在运行的容器及历史运行过的容器</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	-n<span class="token operator">=</span>?	<span class="token comment">#显示最近创建容器</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	-q 		<span class="token comment">#只显示容器 id</span></pre></td></tr></table></figure></li><li><p>退出容器</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token builtin class-name">exit</span>		<span class="token comment">#直接停止容器并退出</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  ctrl+p+q	<span class="token comment">#容器不停止退出</span></pre></td></tr></table></figure></li><li><p><strong>docker rm</strong>: 删除容器</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>docker <span class="token function">rm</span> <span class="token punctuation">[</span>container id<span class="token punctuation">]</span>	<span class="token comment">#删除指定容器，不能删除正在运行的容器，若要强制删除加上参数 -f</span></pre></td></tr></table></figure></li><li><p>启动和停止容器</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>docker start <span class="token punctuation">[</span>container id<span class="token punctuation">]</span>		<span class="token comment">#启动容器</span></pre></td></tr><tr><td data-num="2"></td><td><pre>docker restart <span class="token punctuation">[</span>container id<span class="token punctuation">]</span>	<span class="token comment">#重启容器</span></pre></td></tr><tr><td data-num="3"></td><td><pre>docker stop <span class="token punctuation">[</span>container id<span class="token punctuation">]</span>		<span class="token comment">#停止一个正在运行的容器</span></pre></td></tr><tr><td data-num="4"></td><td><pre>docker <span class="token function">kill</span> <span class="token punctuation">[</span>container id<span class="token punctuation">]</span>		<span class="token comment">#强制停止该容器</span></pre></td></tr></table></figure></li></ul><h3 id="其他常用命令"><a class="anchor" href="#其他常用命令">#</a> 其他常用命令</h3><ul><li><p>后台启动容器</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># docker run -d [镜像名]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>docker dun -d centos</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 问题 docker ps，发现 centos 停止了</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment"># 常见的坑，docker 容器使用后台运行，就必须要有一个后台进程，docker 发现没有应用就会自动停止</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment"># ngnix，容器启动后，发现自己没有提供服务，就会立即停止，就是没有程序了</span></pre></td></tr></table></figure></li><li><p>查看日志</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>docker logs -f -t --tail <span class="token punctuation">[</span>条数<span class="token punctuation">]</span> 容器</pre></td></tr><tr><td data-num="2"></td><td><pre>-t 带时间戳</pre></td></tr><tr><td data-num="3"></td><td><pre>-f follow，跟随最新日志打印</pre></td></tr></table></figure></li><li><p>查看容器中进程信息</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>docker <span class="token function">top</span> <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span></pre></td></tr></table></figure></li><li><p>查看镜像元数据</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>docker inspect 容器id</pre></td></tr></table></figure></li><li><p>进入正在运行的容器</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 命令</span></pre></td></tr><tr><td data-num="4"></td><td><pre>docker <span class="token builtin class-name">exec</span> -it 容器id shell路径</pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">#方式二</span></pre></td></tr><tr><td data-num="7"></td><td><pre>docker attach 容器id</pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">#docker exec    #进入容器后开启一个新的终端，可以在里面操作（常用)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment"># docker attach #进入容器正在执行的终端，不会启动新的进程！</span></pre></td></tr></table></figure></li><li><p>拷贝文件</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 从容器内部拷贝到主机</span></pre></td></tr><tr><td data-num="2"></td><td><pre>docker <span class="token function">cp</span> 容器id:容器内路径 目的的主机路径</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 从主机拷贝到容器内部</span></pre></td></tr><tr><td data-num="5"></td><td><pre>docker <span class="token function">cp</span> 主机路径 容器id:容器内目的路径 </pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment"># 拷贝是一个手动过程，未来使用 -v 卷的技术，可以实现自动同步</span></pre></td></tr></table></figure></li></ul><p><img data-src="C:%5CUsers%5C10051%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220223184246281.png" alt="image-20220223184246281"></p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>attach     Attach to a running container <span class="token comment"># 当前 shell 下 attach 连接指定运行镜像</span></pre></td></tr><tr><td data-num="2"></td><td><pre>build      Build an image from a Dockerfile <span class="token comment"># 通过 Dockerfile 定制镜像</span></pre></td></tr><tr><td data-num="3"></td><td><pre>commit     Create a new image from a container changes <span class="token comment"># 提交当前容器为新的镜像</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">cp</span>         Copy files/folders from the containers filesystem to the <span class="token function">host</span> path <span class="token comment">#从容器中拷贝指定文件或者目录到宿主机中</span></pre></td></tr><tr><td data-num="5"></td><td><pre>create     Create a new container <span class="token comment"># 创建一个新的容器，同 run，但不启动容器</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">diff</span>       Inspect changes on a container's filesystem <span class="token comment"># 查看 docker 容器变化</span></pre></td></tr><tr><td data-num="7"></td><td><pre>events     Get real <span class="token function">time</span> events from the server <span class="token comment"># 从 docker 服务获取容器实时事件</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token builtin class-name">exec</span>       Run a <span class="token builtin class-name">command</span> <span class="token keyword">in</span> an existing container <span class="token comment"># 在已存在的容器上运行命令</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token builtin class-name">export</span>     Stream the contents of a container as a <span class="token function">tar</span> archive <span class="token comment"># 导出容器的内容流作为一个 tar 归档文件 [对应 import]</span></pre></td></tr><tr><td data-num="10"></td><td><pre>histor     show the <span class="token function">history</span> of an image <span class="token comment"># 展示一个镜像形成历史</span></pre></td></tr><tr><td data-num="11"></td><td><pre>images     List images <span class="token comment"># 列出系统当前镜像</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token function">import</span>     Create a new filesystem image from the contents of a tarbal1 <span class="token comment"># 从 tar 包中的内容创建一个新的文件系统映像 [对应 export]</span></pre></td></tr><tr><td data-num="13"></td><td><pre>info       Display system-wide information <span class="token comment"># 显示系统相关信息</span></pre></td></tr><tr><td data-num="14"></td><td><pre>inspec     Return low-level information on a container <span class="token comment"># 查看容器详细信息</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token function">kill</span>       Kill a running container <span class="token comment"># kill 指定 docker 容器</span></pre></td></tr><tr><td data-num="16"></td><td><pre>load       Load an image from a <span class="token function">tar</span> archive <span class="token comment"># 从一个 tar 包中加载一个镜像 [对应 save]</span></pre></td></tr><tr><td data-num="17"></td><td><pre>login      Register or Login to the docker registry server <span class="token comment"># 注册或者登陆一个 docker 源服务器</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token builtin class-name">logout</span>     Log out from a Docker registry server <span class="token comment"># 从当前 Docker registry 退出</span></pre></td></tr><tr><td data-num="19"></td><td><pre>logs       Fetch the logs of a container <span class="token comment"># 输出当前容器日志信息</span></pre></td></tr><tr><td data-num="20"></td><td><pre>port       Lookup the public-facing port <span class="token function">which</span> is NAT-ed to PRIVATE_PORT <span class="token comment"># 查看映射端口对应的容器内部源端口</span></pre></td></tr><tr><td data-num="21"></td><td><pre>pause      Pause all processes within a container <span class="token comment"># 暂停容器</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token function">ps</span>         List containers <span class="token comment"># 列出容器列表</span></pre></td></tr><tr><td data-num="23"></td><td><pre>pull       Pull an image or a repository from the docker registry server <span class="token comment"># 从 docker 镜像源服务器拉取指定镜像或者库镜像</span></pre></td></tr><tr><td data-num="24"></td><td><pre>push       Push an image or a repository to the docker registry server <span class="token comment"># 推送指定镜像或者库镜像至 docker 源服务器</span></pre></td></tr><tr><td data-num="25"></td><td><pre>restart    Restart a running container <span class="token comment"># 重启运行的容器</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token function">rm</span>         Remove one or <span class="token function">more</span> containers <span class="token comment"># 移除一个或者多个容器</span></pre></td></tr><tr><td data-num="27"></td><td><pre>rmi        Remove one or <span class="token function">more</span> images <span class="token comment"># 移除一个或多个镜像 [无容器使用该镜像才可删除，否则需删除相关容器才可继续或 - f 强制册除]</span></pre></td></tr><tr><td data-num="28"></td><td><pre>run        Run a <span class="token builtin class-name">command</span> <span class="token keyword">in</span> a new container <span class="token comment"># 创建一个新的容器并运行一个命令</span></pre></td></tr><tr><td data-num="29"></td><td><pre>save       save an image to a <span class="token function">tar</span> archive <span class="token comment"># 保存一个镜像为一个 tar 包 [对应 load]</span></pre></td></tr><tr><td data-num="30"></td><td><pre>search     search <span class="token keyword">for</span> an image on the Docker Hub <span class="token comment"># 在 docker hub 中搜索镜像</span></pre></td></tr><tr><td data-num="31"></td><td><pre>start      start a stopped containers <span class="token comment"># 启动容器</span></pre></td></tr><tr><td data-num="32"></td><td><pre>stop       Stop a running containers <span class="token comment"># 停止容器</span></pre></td></tr><tr><td data-num="33"></td><td><pre>tag        Tag an image into a repository <span class="token comment"># 给源中镜像打标签</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token function">top</span>        Lookup the running processes of a container <span class="token comment"># 查看容器中运行的进程信息</span></pre></td></tr><tr><td data-num="35"></td><td><pre>unpause    Unpause a paused container <span class="token comment"># 取消暂停容器</span></pre></td></tr><tr><td data-num="36"></td><td><pre>version    show the docker version information <span class="token comment"># 查看 docker 版本号</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token function">wait</span>       Block <span class="token keyword">until</span> a container stops，then print its <span class="token builtin class-name">exit</span> code <span class="token comment"># 截取容器停止时的退出状态值</span></pre></td></tr></table></figure><h2 id="docker镜像原理"><a class="anchor" href="#docker镜像原理">#</a> Docker 镜像原理</h2><h3 id="什么是镜像"><a class="anchor" href="#什么是镜像">#</a> 什么是镜像</h3><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p><p>所有的应用，直接打包 docker 镜像，就能直接运行！</p><p>如何获得镜像：</p><ul><li>从远程仓库下载</li><li>拷贝</li><li>自己制作一个 DockerFile</li></ul><h3 id="docker镜像加载原理"><a class="anchor" href="#docker镜像加载原理">#</a> Docker 镜像加载原理</h3><blockquote><p>UnionFS (联合文件系统)</p></blockquote><p>UnionFS (联合文件系统) : Union 文件系统 ( UnionFS) 是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下 (unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像 (没有父镜像) ， 可以制作各种具体的应用镜像。</p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><blockquote><p>Docker 镜像加载原理</p></blockquote><p>docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统 UnionFS。</p><p>bootfs (boot file system) 主要包含 bootloader 和 kernel， bootloader 主要是引导加载 kernel， Linux 刚启动时会加载 bootfs 文件系统，在 Docker 镜像的最底层是 bootfs。这一层与我们典型的 Linux/Unix 系统是一样的 ，包含 boot 加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs。</p><p>rootfs (root file system) , 在 bootfs 之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs 就是各种不同的操作系统发行版，比如 Ubuntu , Centos 等等。</p><p><img data-src="C:%5CUsers%5C10051%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220223192345966.png" alt="image-20220223192345966"></p><p><strong>平时我们安装进虚拟机的 CentOS 都是好几个 G , 为什么 Docker 这里才 200M ?</strong></p><p>对于一个精简的 OS，rootfs 可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用 Host 的 kernel，自己只需要提供 rootfs 就可以了。由此可见对于不同的 linux 发行版，bootfs 基本是一致的， rootfs 会有差别，因此不同的发行版可以公用 bootfs。</p><h3 id="分层理解"><a class="anchor" href="#分层理解">#</a> 分层理解</h3><blockquote><p>分层镜像</p></blockquote><p>去下载一个镜像，注意观察下载的日志输出，可以看到是一层一层的在下载！</p><p>思考：为什么 Docker 镜像要采用这种分层的结构呢？</p><p>最大的好处，我觉得莫过于是资源共享了！比如有多个镜像都从相同的 Base 镜像构建而来，那么宿主机只需在磁盘上保留一份 base 镜像，同时内存中也只需要加载一份 base 镜像 ，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。</p><p>查看镜像分层的方式可以通过 docker image inspect 命令！</p><p><strong>理解:</strong></p><p>所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p><p>举一个简单的例子，假如基于 Ubuntu Linux 16.04 创建一个 新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python 包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁， 就会创建第三个镜像层。</p><p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。</p><p>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有 6 个文件，这是因为最上层中的文件 7 是文件 5 的一个更新版本。</p><p><img data-src="C:%5CUsers%5C10051%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220223193255142.png" alt="image-20220223193255142"></p><p>这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。</p><p>Docker 通过存储引擎 (新版本采用快照机制) 的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。</p><p>Linux 上可用的存储弓 | 擎有 AUFS、Overlay2、 Device Mapper、Btrfs 以及 ZFS。顾名思义，每种存储引擎都基于 Linux 中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。<br>Docker 在 Windows 上仅支持 windowsfilter 一种存储引擎，该引擎基于 NTFS 文件系统之上实现了分层和 CoW [1]。</p><p>下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。</p><p><img data-src="C:%5CUsers%5C10051%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220223193437110.png" alt="image-20220223193437110"></p><blockquote><p>特点</p></blockquote><p>Docker 镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！</p><p>这一层就是我们常说的容器层，容器之下的都是镜像层！</p><h3 id="commit镜像"><a class="anchor" href="#commit镜像">#</a> commit 镜像</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>docker commit 提交容器成为一个新的副本</pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 命令原理与 git 类似</span></pre></td></tr><tr><td data-num="4"></td><td><pre>docker commit -m<span class="token operator">=</span><span class="token string">"提交的描述信息"</span> -a<span class="token operator">=</span><span class="token string">"作者"</span> 容器id 目标镜像名:<span class="token punctuation">[</span>TAG<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment"># 提交当前容器的一个快照，获得一个新的镜像</span></pre></td></tr></table></figure><h2 id="容器数据卷"><a class="anchor" href="#容器数据卷">#</a> 容器数据卷</h2><h3 id="什么是容器数据卷"><a class="anchor" href="#什么是容器数据卷">#</a> 什么是容器数据卷</h3><p>docker 的理念是将应用和环境打包成一个镜像！</p><p>如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化</p><p>容器之间可以有一个数据共享的技术！Docker 容器中产生的数据，同步到本地！</p><p>这就是卷技术！目录的挂载，将我们容器内的目录，挂载到 Linux 上面！</p><p><strong>容器的持久化与同步操作！容器间也是可以数据共享的！</strong></p><h3 id="使用数据卷"><a class="anchor" href="#使用数据卷">#</a> 使用数据卷</h3><blockquote><p>方式一：直接使用命令挂载 -v</p></blockquote><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>docker run -it -v 主机目录:容器内目录 -p 主机端口:容器内端口</pre></td></tr></table></figure><h3 id="具名挂载与匿名挂载"><a class="anchor" href="#具名挂载与匿名挂载">#</a> 具名挂载与匿名挂载</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 匿名挂载</span></pre></td></tr><tr><td data-num="2"></td><td><pre>-v 容器内路径</pre></td></tr><tr><td data-num="3"></td><td><pre>docker run -d -P --name<span class="token operator">=</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span> -v <span class="token punctuation">[</span>容器内路径<span class="token punctuation">]</span> <span class="token punctuation">[</span>镜像名<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment"># 具名挂载</span></pre></td></tr><tr><td data-num="6"></td><td><pre>-v 卷名:容器内路径</pre></td></tr><tr><td data-num="7"></td><td><pre>docker run -d -P --name<span class="token operator">=</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span> -v <span class="token punctuation">[</span>卷名<span class="token punctuation">]</span>:<span class="token punctuation">[</span>容器内路径<span class="token punctuation">]</span> <span class="token punctuation">[</span>镜像名<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment"># 指定路径挂载</span></pre></td></tr><tr><td data-num="10"></td><td><pre>docker run -it -v 主机目录:容器内目录 -p 主机端口:容器内端口</pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment"># 查看所有 volume （卷）的情况</span></pre></td></tr><tr><td data-num="13"></td><td><pre>docker volume <span class="token function">ls</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment"># 匿名挂载的卷的名称为一长串字符</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token comment"># 具名挂载的卷的名称为自己指定的名称</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment"># 指定路径挂载的卷不会出现在列表中</span></pre></td></tr></table></figure><p>所有 docker 容器内的卷，<strong>没有指定目录</strong>的情况下都是在 <code>/var/lib/docker/volumes/xxx</code> 中</p><p>通过具名挂载可以方便的找到我们使用的卷。</p><p><strong>拓展：</strong></p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 通过 -v 容器内路径:[ro/rw] 改变读写权限</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># ro 	readonly</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># rw 	readwrite</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment"># 一旦设置了容器读写权限，容器对我们挂载出来的内容就有限制了</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment"># 默认使用 rw 权限</span></pre></td></tr><tr><td data-num="7"></td><td><pre>docker run -d -P --name<span class="token operator">=</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span> -v <span class="token punctuation">[</span>卷名<span class="token punctuation">]</span>:<span class="token punctuation">[</span>容器内路径<span class="token punctuation">]</span>:<span class="token punctuation">[</span>ro/rw<span class="token punctuation">]</span> <span class="token punctuation">[</span>镜像名<span class="token punctuation">]</span></pre></td></tr></table></figure><blockquote><p>方式二：使用 DockerFile 来挂载 volume</p></blockquote><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">#创建一个 DockerFile，名字可以随意，建议使用 Dockerfile</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">#------Dockerfile------</span></pre></td></tr><tr><td data-num="3"></td><td><pre>FROM centos</pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment"># 使用 VOLUME 来挂载卷</span></pre></td></tr><tr><td data-num="6"></td><td><pre>VOLUME <span class="token punctuation">[</span><span class="token string">"volume1"</span>,<span class="token string">"volume2"</span><span class="token punctuation">]</span> <span class="token comment"># 匿名挂载</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>CMD <span class="token builtin class-name">echo</span> <span class="token string">"---end---"</span></pre></td></tr><tr><td data-num="9"></td><td><pre>CMD /bin/bash</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">#---------------------</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">#这里的每个命令，都是镜像的一层</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>docker build -f <span class="token punctuation">[</span>DockerFilePath<span class="token punctuation">]</span> -t <span class="token punctuation">[</span>imageName<span class="token punctuation">]</span> <span class="token punctuation">[</span>savePath<span class="token punctuation">]</span></pre></td></tr></table></figure><h3 id="数据卷容器"><a class="anchor" href="#数据卷容器">#</a> 数据卷容器</h3><p>启动一个容器作为数据卷容器，可以使用 <code>--volumes-from</code> 将其他容器挂载到与这个容器相同的数据卷上，这样这两个容器的数据就会同步。</p><h2 id="dockerfile"><a class="anchor" href="#dockerfile">#</a> DockerFile</h2><h3 id="dockerfile介绍"><a class="anchor" href="#dockerfile介绍">#</a> DockerFile 介绍</h3><p>dockerfile 是用来构建 dokcer 镜像的文件！令参数脚本！</p><p>构建步骤:</p><ol><li>编写一个 dockerfile 文件</li><li>docker build 构建成为一个镜像</li><li>docker run 运行镜像</li><li>docker push 发布镜像 (DockerHub、阿里云镜像仓库！)</li></ol><h3 id="dockerfile构建过程"><a class="anchor" href="#dockerfile构建过程">#</a> DockerFile 构建过程</h3><p><strong>基础知识:</strong></p><ol><li>每个保留关键字 (指令) 都是必须是大写字母</li><li>执行从上到下顺序执行</li><li>#表示注释</li><li>每一个指令都会创建提交一个新的镜像层， 并提交！</li></ol><p>dockerfile 是面向开发的，我们以后要发布项目， 做镜像，就需要编写 dockerfile 文件。</p><p>Dockerfile：构建文件，定义了一切的步骤，源代码</p><p>DockerImages：通过 Dockerfile 构建生成的镜像，最终发布和运行的产品！</p><p>Docker 容器：容器就是镜像运行起来提供的服务。</p><h3 id="dockerfile指令"><a class="anchor" href="#dockerfile指令">#</a> DockerFile 指令</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>FROM       <span class="token comment"># 指定基础镜像，一切从这里开始构建</span></pre></td></tr><tr><td data-num="2"></td><td><pre>MAINTAINER <span class="token comment"># 指定维护者信息</span></pre></td></tr><tr><td data-num="3"></td><td><pre>RUN        <span class="token comment"># 镜像构建时执行的命令</span></pre></td></tr><tr><td data-num="4"></td><td><pre>ADD        <span class="token comment"># 添加内容</span></pre></td></tr><tr><td data-num="5"></td><td><pre>WORKDIR    <span class="token comment"># 镜像的工作目录</span></pre></td></tr><tr><td data-num="6"></td><td><pre>VOLUME     <span class="token comment"># 挂载的目录</span></pre></td></tr><tr><td data-num="7"></td><td><pre>EXPOST     <span class="token comment"># 保留端口配置</span></pre></td></tr><tr><td data-num="8"></td><td><pre>CMD        <span class="token comment"># 指定容器启动时要运行的命令，一个 CMD 后跟多个命令只有最后一个会生效，可被替代</span></pre></td></tr><tr><td data-num="9"></td><td><pre>ENTRYPOINT <span class="token comment"># 指定容器启动时要运行的命令，可以追加命令</span></pre></td></tr><tr><td data-num="10"></td><td><pre>ONBUILD    <span class="token comment"># 当构建一个被继承的 DockerFile 时，这时就会执行 ONBUILD 的指令。</span></pre></td></tr><tr><td data-num="11"></td><td><pre>COPY       <span class="token comment"># 类似 ADD ，将我们的文件拷贝到镜像中</span></pre></td></tr><tr><td data-num="12"></td><td><pre>ENV        <span class="token comment"># 构建的时候设置的环境变量</span></pre></td></tr></table></figure><blockquote><p>创建一个自己的 ubuntu</p></blockquote><h2 id="小总结"><a class="anchor" href="#小总结">#</a> 小总结</h2><p><img data-src="C:%5CUsers%5C10051%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220312091040680.png" alt="image-20220312091040680"></p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>docker save <span class="token punctuation">[</span>-o outputPath<span class="token punctuation">]</span> image <span class="token punctuation">[</span>image<span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token comment"># 将镜像打包成 tar 包</span></pre></td></tr><tr><td data-num="2"></td><td><pre>docker load <span class="token punctuation">[</span>-i imputPath<span class="token punctuation">]</span> <span class="token punctuation">[</span>-q<span class="token punctuation">(</span>quilt 阻止命令输出<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment"># 加载 tar 包中的镜像</span></pre></td></tr></table></figure><h2 id="docker-网络"><a class="anchor" href="#docker-网络">#</a> Docker 网络</h2><h3 id="理解docker0"><a class="anchor" href="#理解docker0">#</a> 理解 docker0</h3></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-03-16 20:22:19" itemprop="dateModified" datetime="2022-03-16T20:22:19+08:00">2022-03-16</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Ling yunchi 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Ling yunchi 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Ling yunchi 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Ling yunchi <i class="ic i-at"><em>@</em></i>QWQ</li><li class="link"><strong>本文链接：</strong> <a href="https://ling-yunchi.github.io/2021/07/30/Docker/" title="Docker">https://ling-yunchi.github.io/2021/07/30/Docker/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/07/29/Java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giciundwu5j20zk0m8n9e.jpg" title="Java注解和反射"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>Java注解和反射</h3></a></div><div class="item right"><a href="/2021/08/02/javaWeb/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicli9lfebj20zk0m84qp.jpg" title="javaWeb"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>javaWeb</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#docker"><span class="toc-number">1.</span> <span class="toc-text">Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.</span> <span class="toc-text">Docker 常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.1.</span> <span class="toc-text">镜像的基本命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.2.</span> <span class="toc-text">容器的基本命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.3.</span> <span class="toc-text">其他常用命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker%E9%95%9C%E5%83%8F%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">Docker 镜像原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%95%9C%E5%83%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">什么是镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.2.</span> <span class="toc-text">Docker 镜像加载原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%90%86%E8%A7%A3"><span class="toc-number">1.2.3.</span> <span class="toc-text">分层理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#commit%E9%95%9C%E5%83%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">commit 镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">1.3.</span> <span class="toc-text">容器数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">1.3.1.</span> <span class="toc-text">什么是容器数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">1.3.2.</span> <span class="toc-text">使用数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E6%8C%82%E8%BD%BD%E4%B8%8E%E5%8C%BF%E5%90%8D%E6%8C%82%E8%BD%BD"><span class="toc-number">1.3.3.</span> <span class="toc-text">具名挂载与匿名挂载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">数据卷容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dockerfile"><span class="toc-number">1.4.</span> <span class="toc-text">DockerFile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dockerfile%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.4.1.</span> <span class="toc-text">DockerFile 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dockerfile%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">DockerFile 构建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dockerfile%E6%8C%87%E4%BB%A4"><span class="toc-number">1.4.3.</span> <span class="toc-text">DockerFile 指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">小总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E7%BD%91%E7%BB%9C"><span class="toc-number">1.6.</span> <span class="toc-text">Docker 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3docker0"><span class="toc-number">1.6.1.</span> <span class="toc-text">理解 docker0</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Ling yunchi" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Ling yunchi</p><div class="description" itemprop="description">qwqqqq</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">45</span> <span class="name">文章</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpbmcteXVuY2hp" title="https:&#x2F;&#x2F;github.com&#x2F;Ling-yunchi"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/07/29/Java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/08/02/javaWeb/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Ling yunchi @ Ling Yunchi</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/07/30/Docker/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->