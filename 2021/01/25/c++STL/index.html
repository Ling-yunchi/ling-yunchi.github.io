<!-- build time:Mon Aug 09 2021 11:22:12 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="QWQ" href="https://ling-yunchi.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="QWQ" href="https://ling-yunchi.github.io/atom.xml"><link rel="alternate" type="application/json" title="QWQ" href="https://ling-yunchi.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://ling-yunchi.github.io/2021/01/25/c++STL/"><title>c++STL | Ling Yunchi = QWQ</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">c++STL</h1><div class="meta"><span class="item" title="创建时间：2021-01-25 16:06:55"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-01-25T16:06:55+08:00">2021-01-25</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Ling Yunchi</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipesng5oej20zk0m87d4.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipet8c1a2j20zk0m8kct.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipexe4oykj20zk0m87ji.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclxp31goj20zk0m8qv5.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciub8ja1j20zk0m81ky.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclil3m4ej20zk0m8tn8.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://ling-yunchi.github.io/2021/01/25/c++STL/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Ling yunchi"><meta itemprop="description" content=", qwqqqq"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="QWQ"></span><div class="body md" itemprop="articleBody"><h1 id="stl初识"><a class="anchor" href="#stl初识">#</a> STL 初识</h1><h2 id="stl的诞生"><a class="anchor" href="#stl的诞生">#</a> STL 的诞生</h2><ul><li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p></li><li><p>C++ 的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p></li><li><p>大多情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作</p></li><li><p>为了建立数据结构和算法的一套标准，诞生了<strong> STL</strong></p></li></ul><h2 id="stl基本概念"><a class="anchor" href="#stl基本概念">#</a> STL 基本概念</h2><ul><li>STL(Standard Template Library,<strong> 标准模板库</strong>)</li><li>STL 从广义上分为: <strong>容器 (container) 算法 (algorithm) 迭代器 (iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h2 id="stl六大组件"><a class="anchor" href="#stl六大组件">#</a> STL 六大组件</h2><p>STL 大体分为六大组件，分别是:<strong> 容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p><ol><li>容器：各种数据结构，如 vector、list、deque、set、map 等，用来存放数据。</li><li>算法：各种常用的算法，如 sort、find、copy、for_each 等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><h2 id="stl中容器-算法-迭代器"><a class="anchor" href="#stl中容器-算法-迭代器">#</a> STL 中容器、算法、迭代器</h2><p>** 容器：** 置物之所也</p><p>STL<strong> 容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构：数组，链表，树，栈，队列，集合，映射表 等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p><p>​	<strong>序列式容器</strong>：强调值的排序，序列式容器中的每个元素均有固定的位置。<br>​	<strong>关联式容器</strong>：二叉树结构，各元素之间没有严格的物理上的顺序关系</p><p>** 算法：** 问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法 (Algorithms)</p><p>算法分为:<strong> 质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><p>** 迭代器：** 容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持 ++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持 ++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持 ++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持 ++、--，</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持 ++、--、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><h2 id="stl-常用容器"><a class="anchor" href="#stl-常用容器">#</a> STL- 常用容器</h2><h2 id="string容器"><a class="anchor" href="#string容器">#</a> string 容器</h2><h3 id="string基本概念"><a class="anchor" href="#string基本概念">#</a> string 基本概念</h3><p><strong>本质：</strong></p><ul><li>string 是 C++ 风格的字符串，而 string 本质上是一个<strong>类</strong></li></ul><p><strong>string 和 char * 区别：</strong></p><ul><li>char * 是一个指针</li><li>string 是一个类，类内部封装了 char*，管理这个字符串，是一个 char * 型的容器。</li></ul><p><strong>特点：</strong></p><p>string 类内部封装了很多成员方法</p><p>例如：查找 find，拷贝 copy，删除 delete 替换 replace，插入 insert</p><p>string 管理 char * 所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p><h3 id="string构造函数"><a class="anchor" href="#string构造函数">#</a> string 构造函数</h3><p>构造函数原型：</p><ul><li><code>string();</code> // 创建一个空的字符串 例如: string str;<br><code>string(const char* s);</code> // 使用字符串 s 初始化</li><li><code>string(const string&amp; str);</code> // 使用一个 string 对象初始化另一个 string 对象</li><li><code>string(int n, char c);</code> // 使用 n 个字符 c 初始化</li></ul><h3 id="string赋值操作"><a class="anchor" href="#string赋值操作">#</a> string 赋值操作</h3><p>功能描述：</p><ul><li>给 string 字符串进行赋值</li></ul><p>赋值的函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code> //char * 类型字符串 赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code> // 把字符串 s 赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code> // 字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code> // 把字符串 s 赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code> // 把字符串 s 的前 n 个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code> // 把字符串 s 赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code> // 用 n 个字符 c 赋给当前字符串</li></ul><h3 id="string字符串拼接"><a class="anchor" href="#string字符串拼接">#</a> string 字符串拼接</h3><p><strong>功能描述：</strong></p><ul><li>实现在字符串末尾拼接字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; operator+=(const char* str);</code> // 重载 += 操作符</li><li><code>string&amp; operator+=(const char c);</code> // 重载 += 操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code> // 重载 += 操作符</li><li><code>string&amp; append(const char *s);</code> // 把字符串 s 连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code> // 把字符串 s 的前 n 个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code> // 同 operator+=(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n);</code> // 字符串 s 中从 pos 开始的 n 个字符连接到字符串结尾</li></ul><h3 id="string查找和替换"><a class="anchor" href="#string查找和替换">#</a> string 查找和替换</h3><p><strong>功能描述：</strong></p><ul><li>查找：查找指定字符串是否存在</li><li>替换：在指定的位置替换字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code> // 查找 str 第一次出现位置，从 pos 开始查找</li><li><code>int find(const char* s, int pos = 0) const;</code> // 查找 s 第一次出现位置，从 pos 开始查找</li><li><code>int find(const char* s, int pos, int n) const;</code> // 从 pos 位置查找 s 的前 n 个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const;</code> // 查找字符 c 第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code> // 查找 str 最后一次位置，从 pos 开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code> // 查找 s 最后一次出现位置，从 pos 开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code> // 从 pos 查找 s 的前 n 个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const;</code> // 查找字符 c 最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str);</code> // 替换从 pos 开始 n 个字符为字符串 str</li><li><code>string&amp; replace(int pos, int n,const char* s);</code> // 替换从 pos 开始的 n 个字符为字符串 s</li></ul><p>总结：</p><ul><li>find 查找是从左往后，rfind 从右往左</li><li>find 找到字符串后<strong>返回查找的第一个字符位置</strong>，找不到<strong>返回 - 1</strong></li><li>replace 在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h3 id="string字符串比较"><a class="anchor" href="#string字符串比较">#</a> string 字符串比较</h3><p><strong>功能描述：</strong></p><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的<strong> ASCII 码</strong>进行对比</li></ul><p>= 返回 0</p><p>&gt; 返回 1</p><p>&lt; 返回 -1</p><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const;</code> // 与字符串 s 比较</li><li><code>int compare(const char *s) const;</code> // 与字符串 s 比较</li></ul><p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p><h3 id="string字符存取"><a class="anchor" href="#string字符存取">#</a> string 字符存取</h3><p>string 中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n);</code> // 通过 [] 方式取字符</li><li><code>char&amp; at(int n);</code> // 通过 at 方法获取字符</li></ul><h3 id="string插入和删除"><a class="anchor" href="#string插入和删除">#</a> string 插入和删除</h3><p><strong>功能描述：</strong></p><ul><li>对 string 字符串进行插入和删除字符操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; insert(int pos, const char* s);</code> // 插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str);</code> // 插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code> // 在指定位置插入 n 个字符 c</li><li><code>string&amp; erase(int pos, int n = npos);</code> // 删除从 Pos 开始的 n 个字符</li></ul><h3 id="string子串"><a class="anchor" href="#string子串">#</a> string 子串</h3><p><strong>功能描述：</strong></p><ul><li>从字符串中获取想要的子串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string substr(int pos = 0, int n = npos) const;</code> // 返回由 pos 开始的 n 个字符组成的字符串</li></ul><p>** 总结：** 灵活的运用求子串功能，可以在实际开发中获取有效的信息</p><h2 id="vector容器"><a class="anchor" href="#vector容器">#</a> vector 容器</h2><h3 id="vector基本概念"><a class="anchor" href="#vector基本概念">#</a> vector 基本概念</h3><p><strong>功能：</strong></p><ul><li>vector 数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li></ul><p><strong>vector 与普通数组区别：</strong></p><ul><li>不同之处在于数组是静态空间，而 vector 可以<strong>动态扩展</strong></li></ul><p><strong>动态扩展：</strong></p><ul><li>并不是在原空间之后续接新空间，而是<strong>找更大的内存空间</strong>，然后将原数据拷贝新空间，释放原空间</li></ul><p><img data-src="./c++STL/clip_image002.jpg" alt="002"></p><p><img data-src="clip_image002.jpg" alt="002"></p><ul><li>vector 容器的迭代器是支持随机访问的迭代器</li></ul><h3 id="vector构造函数"><a class="anchor" href="#vector构造函数">#</a> vector 构造函数</h3><p><strong>功能描述：</strong></p><ul><li>创建 vector 容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&lt;T&gt; v;</code> // 采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());</code> // 将 v [begin (), end ()) 区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code> // 构造函数将 n 个 elem 拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code> // 拷贝构造函数。</li></ul><h3 id="vector赋值操作"><a class="anchor" href="#vector赋值操作">#</a> vector 赋值操作</h3><p><strong>功能描述：</strong></p><ul><li>给 vector 容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>vector&amp; operator=(const vector &amp;vec);</code> // 重载等号操作符</p></li><li><p><code>assign(beg, end);</code> // 将 [beg, end) 区间中的数据拷贝赋值给本身。</p></li><li><p><code>assign(n, elem);</code> // 将 n 个 elem 拷贝赋值给本身。</p></li></ul><h3 id="vector容量和大小"><a class="anchor" href="#vector容量和大小">#</a> vector 容量和大小</h3><p><strong>功能描述：</strong></p><ul><li>对 vector 容器的容量和大小操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>empty();</code> // 判断容器是否为空</p></li><li><p><code>capacity();</code> // 容器的容量</p></li><li><p><code>size();</code> // 返回容器中元素的个数</p></li><li><p><code>resize(int num);</code> // 重新指定容器的长度为 num，若容器变长，则以默认值填充新位置。</p><p>​ // 如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(int num, elem);</code> // 重新指定容器的长度为 num，若容器变长，则以 elem 值填充新位置。</p><p>​ // 如果容器变短，则末尾超出容器长度的元素被删除</p></li></ul><p>总结：</p><ul><li>判断是否为空 --- empty</li><li>返回元素个数 --- size</li><li>返回容器容量 --- capacity</li><li>重新指定大小 --- resize</li></ul><h3 id="vector插入和删除"><a class="anchor" href="#vector插入和删除">#</a> vector 插入和删除</h3><p><strong>功能描述：</strong></p><ul><li>对 vector 容器进行插入、删除操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>push_back(ele);</code> // 尾部插入元素 ele</li><li><code>pop_back();</code> // 删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code> // 迭代器指向位置 pos 插入元素 ele</li><li><code>insert(const_iterator pos, int count,ele);</code> // 迭代器指向位置 pos 插入 count 个元素 ele</li><li><code>erase(const_iterator pos);</code> // 删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code> // 删除迭代器从 start 到 end 之间的元素</li><li><code>clear();</code> // 删除容器中所有元素</li></ul><p>总结：</p><ul><li>尾插 --- push_back</li><li>尾删 --- pop_back</li><li>插入 --- insert (位置迭代器)</li><li>删除 --- erase （位置迭代器）</li><li>清空 --- clear</li></ul><h3 id="vector数据存取"><a class="anchor" href="#vector数据存取">#</a> vector 数据存取</h3><p><strong>功能描述：</strong></p><ul><li>对 vector 中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx);</code> // 返回索引 idx 所指的数据</li><li><code>operator[];</code> // 返回索引 idx 所指的数据</li><li><code>front();</code> // 返回容器中第一个数据元素</li><li><code>back();</code> // 返回容器中最后一个数据元素</li></ul><p>总结：</p><ul><li>除了用迭代器获取 vector 容器中元素，[ ] 和 at 也可以</li><li>front 返回容器第一个元素</li><li>back 返回容器最后一个元素</li></ul><h3 id="vector互换容器"><a class="anchor" href="#vector互换容器">#</a> vector 互换容器</h3><p><strong>功能描述：</strong></p><ul><li>实现两个容器内元素进行互换</li></ul><p><strong>函数原型：</strong></p><ul><li><code>swap(vec);</code> // 将 vec 与本身的元素互换，交换两个 vector 的元素</li></ul><p>总结：swap 可以使两个容器互换，可以达到实用的收缩内存效果</p><pre><code class="language-c++">int main()
&#123;
	vector&lt;int&gt; arr;
	for (int i = 0; i &lt; 100; i++)
		arr.push_back(i);
	cout &lt;&lt; &quot;arr的容量:&quot; &lt;&lt; arr.capacity() &lt;&lt; endl;
	cout &lt;&lt; &quot;arr的大小:&quot; &lt;&lt; arr.size() &lt;&lt; endl;
	vector&lt;int&gt;(arr).swap(arr);
	cout &lt;&lt; &quot;arr的容量:&quot; &lt;&lt; arr.capacity() &lt;&lt; endl;
	cout &lt;&lt; &quot;arr的大小:&quot; &lt;&lt; arr.size() &lt;&lt; endl;

	return 0;
&#125;
out:
    arr的容量:141
    arr的大小:100
    arr的容量:100
    arr的大小:100

</code></pre><h3 id="vector预留空间"><a class="anchor" href="#vector预留空间">#</a> vector 预留空间</h3><p><strong>功能描述：</strong></p><ul><li>减少 vector 在动态扩展容量时的扩展次数</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code> // 容器预留 len 个元素长度，预留位置不初始化，元素不可访问。</li></ul><p>总结：如果数据量较大，可以一开始利用 reserve 预留空间</p><pre><code class="language-c++">	vector&lt;int&gt; v;
	//预留空间
	v.reserve(100000);
	int num = 0;
	int* p = NULL;
	for (int i = 0; i &lt; 100000; i++) &#123;
		v.push_back(i);
		if (p != &amp;v[0]) &#123;
			p = &amp;v[0];
			num++;
		&#125;
	&#125;
	cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl;
</code></pre><h2 id="deque容器"><a class="anchor" href="#deque容器">#</a> deque 容器</h2><h3 id="deque容器基本概念"><a class="anchor" href="#deque容器基本概念">#</a> deque 容器基本概念</h3><p><strong>功能：</strong></p><ul><li>双端数组，可以对头端进行插入删除操作</li></ul><p><strong>deque 与 vector 区别：</strong></p><ul><li>vector 对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque 相对而言，对头部的插入删除速度回比 vector 快</li><li>vector 访问元素时的速度会比 deque 快，这和两者内部实现有关</li></ul><p><img data-src="clip_image002-1547547642923.jpg" alt="deque结构"></p><p><img data-src="c++STL/clip_image002-1547547642923.jpg" alt="deque结构"></p><p>deque 内部工作原理:</p><p>deque 内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p><p>中控器维护的是每个缓冲区的地址，使得使用 deque 时像一片连续的内存空间</p><p><img data-src="clip_image002-1547547896341.jpg" alt="deque内部工作原理"></p><p><img data-src="c++STL/clip_image002-1547547896341.jpg" alt="deque内部工作原理"></p><ul><li>deque 容器的迭代器也是支持随机访问的</li></ul><h3 id="332-deque构造函数"><a class="anchor" href="#332-deque构造函数">#</a> 3.3.2 deque 构造函数</h3><p><strong>功能描述：</strong></p><ul><li>deque 容器构造</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&lt;T&gt;</code> deqT; // 默认构造形式</li><li><code>deque(beg, end);</code> // 构造函数将 [beg, end) 区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code> // 构造函数将 n 个 elem 拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code> // 拷贝构造函数</li></ul><p>** 总结：**deque 容器和 vector 容器的构造方式几乎一致，灵活使用即可</p><h3 id="deque赋值操作"><a class="anchor" href="#deque赋值操作">#</a> deque 赋值操作</h3><p><strong>功能描述：</strong></p><ul><li>给 deque 容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>deque&amp; operator=(const deque &amp;deq);</code> // 重载等号操作符</p></li><li><p><code>assign(beg, end);</code> // 将 [beg, end) 区间中的数据拷贝赋值给本身。</p></li><li><p><code>assign(n, elem);</code> // 将 n 个 elem 拷贝赋值给本身。</p></li></ul><h3 id="deque大小操作"><a class="anchor" href="#deque大小操作">#</a> deque 大小操作</h3><p><strong>功能描述：</strong></p><ul><li>对 deque 容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>deque.empty();</code> // 判断容器是否为空</p></li><li><p><code>deque.size();</code> // 返回容器中元素的个数</p></li><li><p><code>deque.resize(num);</code> // 重新指定容器的长度为 num, 若容器变长，则以默认值填充新位置。</p><p>​ // 如果容器变短，则末尾<strong>超出容器长度的元素被删除</strong>。</p></li><li><p><code>deque.resize(num, elem);</code> // 重新指定容器的长度为 num,<strong> 若容器变长，则以 elem 值填充新位置</strong>。</p><p>​ // 如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><p>总结：</p><ul><li>deque 没有容量的概念</li><li>判断是否为空 --- empty</li><li>返回元素个数 --- size</li><li>重新指定个数 --- resize</li></ul><h3 id="deque-插入和删除"><a class="anchor" href="#deque-插入和删除">#</a> deque 插入和删除</h3><p><strong>功能描述：</strong></p><ul><li>向 deque 容器中插入和删除数据</li></ul><p><strong>函数原型：</strong></p><p>两端插入操作：</p><ul><li><code>push_back(elem);</code> // 在容器尾部添加一个数据</li><li><code>push_front(elem);</code> // 在容器头部插入一个数据</li><li><code>pop_back();</code> // 删除容器最后一个数据</li><li><code>pop_front();</code> // 删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><p><code>insert(pos,elem);</code> // 在 pos 位置插入一个 elem 元素的拷贝，返回新数据的位置。</p></li><li><p><code>insert(pos,n,elem);</code> // 在 pos 位置插入 n 个 elem 数据，无返回值。</p></li><li><p><code>insert(pos,beg,end);</code> // 在 pos 位置插入 [beg,end) 区间的数据，无返回值。</p></li><li><p><code>clear();</code> // 清空容器的所有数据</p></li><li><p><code>erase(beg,end);</code> // 删除 [beg,end) 区间的数据，返回下一个数据的位置。</p></li><li><p><code>erase(pos);</code> // 删除 pos 位置的数据，返回下一个数据的位置。</p></li></ul><p>总结：</p><ul><li>插入和删除提供的位置是迭代器！</li><li>尾插 --- push_back</li><li>尾删 --- pop_back</li><li>头插 --- push_front</li><li>头删 --- pop_front</li></ul><h3 id="deque-数据存取"><a class="anchor" href="#deque-数据存取">#</a> deque 数据存取</h3><p><strong>功能描述：</strong></p><ul><li>对 deque 中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx);</code> // 返回索引 idx 所指的数据</li><li><code>operator[];</code> // 返回索引 idx 所指的数据</li><li><code>front();</code> // 返回容器中第一个数据元素</li><li><code>back();</code> // 返回容器中最后一个数据元素</li></ul><p>总结：</p><ul><li>除了用迭代器获取 deque 容器中元素，[ ] 和 at 也可以</li><li>front 返回容器第一个元素</li><li>back 返回容器最后一个元素</li></ul><h3 id="deque-排序"><a class="anchor" href="#deque-排序">#</a> deque 排序</h3><p><strong>功能描述：</strong></p><ul><li>利用算法实现对 deque 容器进行排序</li></ul><p><strong>算法：</strong></p><ul><li><code>sort(iterator beg, iterator end)</code> // 对 beg 和 end 区间内元素进行排序</li></ul><h2 id="stack容器"><a class="anchor" href="#stack容器">#</a> stack 容器</h2><h3 id="stack-基本概念"><a class="anchor" href="#stack-基本概念">#</a> stack 基本概念</h3><p><strong>概念：<strong>stack 是一种</strong>先进后出</strong> (First In Last Out,FILO) 的数据结构，它只有一个出口</p><p><img data-src="clip_image002-1547604555425.jpg" alt="栈的结构"></p><p><img data-src="c++STL/clip_image002-1547604555425.jpg" alt="栈的结构"></p><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为 --- <strong>入栈</strong> <code>push</code></p><p>栈中弹出数据称为 --- <strong>出栈</strong> <code>pop</code></p><h3 id="stack-常用接口"><a class="anchor" href="#stack-常用接口">#</a> stack 常用接口</h3><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>stack&lt;T&gt; stk;</code> //stack 采用模板类实现， stack 对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code> // 拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code> // 重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code> // 向栈顶添加元素</li><li><code>pop();</code> // 从栈顶移除第一个元素</li><li><code>top();</code> // 返回栈顶元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code> // 判断堆栈是否为空</li><li><code>size();</code> // 返回栈的大小</li></ul><p>总结：</p><ul><li>入栈 --- push</li><li>出栈 --- pop</li><li>返回栈顶 --- top</li><li>判断栈是否为空 --- empty</li><li>返回栈大小 --- size</li></ul><h2 id="queue-容器"><a class="anchor" href="#queue-容器">#</a> queue 容器</h2><h3 id="queue-基本概念"><a class="anchor" href="#queue-基本概念">#</a> queue 基本概念</h3><p><strong>概念：<strong>Queue 是一种</strong>先进先出</strong> (First In First Out,FIFO) 的数据结构，它有两个出口</p><p><img data-src="clip_image002-1547606475892.jpg" alt="队列"></p><p><img data-src="c++STL/clip_image002-1547606475892.jpg" alt="队列"></p><p>队列容器允许从一端新增元素，从另一端移除元素</p><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为 --- <strong>入队</strong> <code>push</code></p><p>队列中出数据称为 --- <strong>出队</strong> <code>pop</code></p><h3 id="queue-常用接口"><a class="anchor" href="#queue-常用接口">#</a> queue 常用接口</h3><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code> //queue 采用模板类实现，queue 对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code> // 拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code> // 重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code> // 往队尾添加元素</li><li><code>pop();</code> // 从队头移除第一个元素</li><li><code>back();</code> // 返回最后一个元素</li><li><code>front();</code> // 返回第一个元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code> // 判断堆栈是否为空</li><li><code>size();</code> // 返回栈的大小</li></ul><p>总结：</p><ul><li>入队 --- push</li><li>出队 --- pop</li><li>返回队头元素 --- front</li><li>返回队尾元素 --- back</li><li>判断队是否为空 --- empty</li><li>返回队列大小 --- size</li></ul><h3 id="priority_queue"><a class="anchor" href="#priority_queue">#</a> priority_queue</h3><p>普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。</p><p>在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。</p><p>优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，<strong>它本质是一个堆实现的</strong>。</p><p>定义：priority_queue&lt;Type, Container, Functional&gt;</p><pre><code class="language-c++">//升序队列，小顶堆
priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;
//降序队列，大顶堆
priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;

//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）
</code></pre><h2 id="list容器"><a class="anchor" href="#list容器">#</a> list 容器</h2><h3 id="list基本概念"><a class="anchor" href="#list基本概念">#</a> list 基本概念</h3><p>** 功能：** 将数据进行链式存储</p><p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><p>链表的组成：链表由一系列<strong>结点</strong>组成</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p><p>STL 中的链表是一个双向循环链表</p><p><img data-src="clip_image002-1547608564071.jpg" alt="双向循环链表"></p><p><img data-src="c++STL/clip_image002-1547608564071.jpg" alt="双向循环链表"></p><p>由于链表的存储方式并不是连续的内存空间，因此链表 list 中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p><p>list 的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p>list 的缺点：</p><ul><li>链表灵活，但是空间 (指针域) 和 时间（遍历）额外耗费较大</li></ul><p>List 有一个重要的性质，插入操作和删除操作都不会造成<strong>原有 list 迭代器</strong>的失效，这在 vector 是不成立的。</p><p>总结：STL 中<strong> List 和 vector 是两个最常被使用的容器</strong>，各有优缺点</p><h3 id="list构造函数"><a class="anchor" href="#list构造函数">#</a> list 构造函数</h3><p><strong>功能描述：</strong></p><ul><li>创建 list 容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>list&lt;T&gt; lst;</code> //list 采用采用模板类实现，对象的默认构造形式：</li><li><code>list(beg,end);</code> // 构造函数将 [beg, end) 区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code> // 构造函数将 n 个 elem 拷贝给本身。</li><li><code>list(const list &amp;lst);</code> // 拷贝构造函数。</li></ul><h3 id="list-赋值和交换"><a class="anchor" href="#list-赋值和交换">#</a> list 赋值和交换</h3><p><strong>功能描述：</strong></p><ul><li>给 list 容器进行赋值，以及交换 list 容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>assign(beg, end);</code> // 将 [beg, end) 区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code> // 将 n 个 elem 拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code> // 重载等号操作符</li><li><code>swap(lst);</code> // 将 lst 与本身的元素互换。</li></ul><h3 id="list-大小操作"><a class="anchor" href="#list-大小操作">#</a> list 大小操作</h3><p><strong>功能描述：</strong></p><ul><li>对 list 容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>size();</code> // 返回容器中元素的个数</p></li><li><p><code>empty();</code> // 判断容器是否为空</p></li><li><p><code>resize(num);</code> // 重新指定容器的长度为 num，若容器变长，则以默认值 0 填充新位置。</p><p>​ // 如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(num, elem);</code> // 重新指定容器的长度为 num，若容器变长，则以 elem 值填充新位置。</p></li></ul><h3 id="list-插入和删除"><a class="anchor" href="#list-插入和删除">#</a> list 插入和删除</h3><p><strong>功能描述：</strong></p><ul><li>对 list 容器进行数据的插入和删除</li></ul><p><strong>函数原型：</strong></p><ul><li>push_back (elem);// 在容器尾部加入一个元素</li><li>pop_back ();// 删除容器中最后一个元素</li><li>push_front (elem);// 在容器开头插入一个元素</li><li>pop_front ();// 从容器开头移除第一个元素</li><li>insert (pos,elem);// 在 pos 位置插 elem 元素的拷贝，返回新数据的位置。</li><li>insert (pos,n,elem);// 在 pos 位置插入 n 个 elem 数据，无返回值。</li><li>insert (pos,beg,end);// 在 pos 位置插入 [beg,end) 区间的数据，无返回值。</li><li>clear ();// 移除容器的所有数据</li><li>erase (beg,end);// 删除 [beg,end) 区间的数据，返回下一个数据的位置。</li><li>erase (pos);// 删除 pos 位置的数据，返回下一个数据的位置。</li><li>remove (elem);// 删除容器中所有与 elem 值匹配的元素。</li></ul><p>总结：</p><ul><li>尾插 --- push_back</li><li>尾删 --- pop_back</li><li>头插 --- push_front</li><li>头删 --- pop_front</li><li>插入 --- insert</li><li>删除 --- erase</li><li>移除 --- remove</li><li>清空 --- clear</li></ul><h3 id="list-数据存取"><a class="anchor" href="#list-数据存取">#</a> list 数据存取</h3><p><strong>功能描述：</strong></p><ul><li>对 list 容器中数据进行存取</li></ul><p><strong>函数原型：</strong></p><ul><li><code>front();</code> // 返回第一个元素。</li><li><code>back();</code> // 返回最后一个元素。</li></ul><pre><code class="language-c++">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据
//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据
//list容器的迭代器是双向迭代器，不支持随机访问
	list&lt;int&gt;::iterator it = L1.begin();
	//it = it + 1;//错误，不可以跳跃访问，即使是+1
</code></pre><p>总结：</p><ul><li>list 容器中不可以通过 [] 或者 at 方式访问数据</li><li>返回第一个元素 --- front</li><li>返回最后一个元素 --- back</li></ul><h3 id="list-反转和排序"><a class="anchor" href="#list-反转和排序">#</a> list 反转和排序</h3><p><strong>功能描述：</strong></p><ul><li>将容器中的元素反转，以及将容器中的数据进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reverse();</code> // 反转链表</li><li><code>sort();</code> // 链表排序，括号中可以插入排序规则函数</li></ul><p>总结：</p><ul><li><p>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</p></li><li><p>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p></li></ul><h2 id="set-multiset-容器"><a class="anchor" href="#set-multiset-容器">#</a> set/multiset 容器</h2><h3 id="set基本概念"><a class="anchor" href="#set基本概念">#</a> set 基本概念</h3><p><strong>简介：</strong></p><ul><li>所有元素都会在插入时自动被排序</li></ul><p><strong>本质：</strong></p><ul><li>set/multiset 属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li></ul><p><strong>set 和 multiset 区别</strong>：</p><ul><li>set<strong> 不允许</strong>容器中有<strong>重复</strong>的元素</li><li>multiset<strong> 允许</strong>容器中有<strong>重复</strong>的元素</li></ul><h3 id="set构造和赋值"><a class="anchor" href="#set构造和赋值">#</a> set 构造和赋值</h3><p>功能描述：创建 set 容器以及赋值</p><p>构造：</p><ul><li><code>set&lt;T&gt; st;</code> // 默认构造函数：</li><li><code>set(const set &amp;st);</code> // 拷贝构造函数</li></ul><p>赋值：</p><ul><li><code>set&amp; operator=(const set &amp;st);</code> // 重载等号操作符</li></ul><p>总结：</p><ul><li>set 容器插入数据时用 insert</li><li>set 容器插入数据的数据会自动排序</li></ul><h3 id="set大小和交换"><a class="anchor" href="#set大小和交换">#</a> set 大小和交换</h3><p><strong>功能描述：</strong></p><ul><li>统计 set 容器大小以及交换 set 容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>size();</code> // 返回容器中元素的数目</li><li><code>empty();</code> // 判断容器是否为空</li><li><code>swap(st);</code> // 交换两个集合容器</li></ul><p>总结：</p><ul><li>统计大小 --- size</li><li>判断是否为空 --- empty</li><li>交换容器 --- swap</li></ul><h3 id="set插入和删除"><a class="anchor" href="#set插入和删除">#</a> set 插入和删除</h3><p><strong>功能描述：</strong></p><ul><li>set 容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code> // 在容器中插入元素。</li><li><code>clear();</code> // 清除所有元素</li><li><code>erase(pos);</code> // 删除 pos 迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code> // 删除区间 [beg,end) 的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(elem);</code> // 删除容器中值为 elem 的元素。</li></ul><p>注：insert () 的返回值类型为 <code>pair&lt;set::iterator, bool&gt;</code> , 为一个对组，其中 first 元素存储的是插入位置的迭代器，second 存储的是布尔值表示是否插入成功</p><pre><code class="language-c++">void printSet(set&lt;int&gt;&amp; a) &#123;
	for (auto it = a.begin(); it != a.end(); it++)
		cout &lt;&lt; &quot; &quot; &lt;&lt; *it;
&#125;

int main()
&#123;
	set&lt;int&gt; a;
	for (int i = 50; i &gt; 0; i--)
	&#123;
		a.insert(i);
	&#125;
	//printSet(a);
	pair&lt;set&lt;int&gt;::iterator, bool&gt; cmp = a.insert(12);
	if (cmp.second)
		cout &lt;&lt; &quot;success!&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;false!&quot; &lt;&lt; endl;

	return 0;
&#125;
out:
	false!

</code></pre><p>总结：</p><ul><li>插入 --- insert</li><li>删除 --- erase</li><li>清空 --- clear</li></ul><h3 id="set查找和统计"><a class="anchor" href="#set查找和统计">#</a> set 查找和统计</h3><p><strong>功能描述：</strong></p><ul><li>对 set 容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code> // 查找 key 是否存在，若存在，返回该键的元素的迭代器；若不存在，返回 set.end ();</li><li><code>count(key);</code> // 统计 key 的元素个数</li></ul><p>总结：</p><ul><li>查找 --- find （返回的是迭代器）</li><li>统计 --- count （对于 set，结果为 0 或者 1）</li></ul><h3 id="pair对组创建"><a class="anchor" href="#pair对组创建">#</a> pair 对组创建</h3><p><strong>功能描述：</strong></p><ul><li>成对出现的数据，利用对组可以<strong>返回两个数据</strong></li><li>第一个数据为 first, 第二个数据为 second</li></ul><p><strong>两种创建方式：</strong></p><ul><li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li><li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li></ul><h3 id="set容器排序"><a class="anchor" href="#set容器排序">#</a> set 容器排序</h3><p>学习目标：</p><ul><li>set 容器默认排序规则为从小到大，掌握如何改变排序规则</li></ul><p>主要技术点：</p><ul><li>利用仿函数，可以改变排序规则</li></ul><p>set 存放内置数据类型:</p><pre><code class="language-c++">class Cmp
&#123;
public:
	bool operator () (int a, int b) const//要放入函数中输出就要加const
	&#123;
		return a &gt; b;//从大到小排
	&#125;
&#125;;
void printSet(set&lt;int, Cmp&gt;&amp; a) &#123;
	for (set&lt;int&gt;::iterator it = a.begin(); it != a.end(); it++)
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
&#125;
int main()
&#123;
	set&lt;int, Cmp&gt; a;
	a.insert(10);
	a.insert(15);
	a.insert(28);
	printSet(a);


	return 0;
&#125;
</code></pre><p>set 存放自定义数据类型</p><pre><code class="language-c++">class Acm
&#123;
public:
	int ACnum;
	int Time_penalty;
	Acm(int ACnum, int Time_penalty) &#123;
		this-&gt;ACnum = ACnum;
		this-&gt;Time_penalty = Time_penalty;
	&#125;
&#125;;
class Cmp
&#123;
public:
	bool operator () (Acm a, Acm b) const
	&#123;
		if (a.ACnum == b.ACnum)
			return a.Time_penalty &lt; b.Time_penalty;//罚时按升序排列
		else
			return a.ACnum &gt; b.ACnum;//AC数按升序排列
	&#125;
&#125;;
void printSet(set&lt;Acm, Cmp&gt;&amp; a) &#123;
	for (auto it = a.begin(); it != a.end(); it++)
		cout &lt;&lt; it-&gt;ACnum &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;Time_penalty &lt;&lt; endl;
&#125;
int main()
&#123;
	set&lt;Acm, Cmp&gt; a;
	a.insert(Acm(3, 10));
	a.insert(Acm(4, 15));
	a.insert(Acm(5, 28));
	a.insert(Acm(5, 10));
	printSet(a);

	return 0;
&#125;
</code></pre><h2 id="map-multimap容器"><a class="anchor" href="#map-multimap容器">#</a> map/multimap 容器</h2><h3 id="map基本概念"><a class="anchor" href="#map基本概念">#</a> map 基本概念</h3><p><strong>简介：</strong></p><ul><li>map 中所有元素都是 pair</li><li>pair 中<strong>第一个元素为 key（键值）</strong>，起到索引作用，<strong>第二个元素为 value（实值）</strong></li><li>所有元素都会<strong>根据元素的键值自动排序</strong></li></ul><p><strong>本质：</strong></p><ul><li>map/multimap 属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li></ul><p><strong>优点：</strong></p><ul><li>可以根据 key 值快速找到 value 值</li></ul><p>map 和 multimap<strong> 区别</strong>：</p><ul><li>map 不允许容器中有重复 key 值元素</li><li>multimap 允许容器中有重复 key 值元素</li></ul><h3 id="map构造和赋值"><a class="anchor" href="#map构造和赋值">#</a> map 构造和赋值</h3><p><strong>功能描述：</strong></p><ul><li>对 map 容器进行构造和赋值操作</li></ul><p><strong>函数原型：</strong></p><p><strong>构造：</strong></p><ul><li><code>map&lt;T1, T2&gt; mp;</code> //map 默认构造函数:</li><li><code>map(const map &amp;mp);</code> // 拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li><code>map&amp; operator=(const map &amp;mp);</code> // 重载等号操作符</li></ul><p>总结：map 中所有元素都是成对出现，插入数据时候要使用对组</p><h3 id="map大小和交换"><a class="anchor" href="#map大小和交换">#</a> map 大小和交换</h3><p><strong>功能描述：</strong></p><ul><li>统计 map 容器大小以及交换 map 容器</li></ul><p>函数原型：</p><ul><li><code>size();</code> // 返回容器中元素的数目</li><li><code>empty();</code> // 判断容器是否为空</li><li><code>swap(st);</code> // 交换两个集合容器</li></ul><h3 id="map插入和删除"><a class="anchor" href="#map插入和删除">#</a> map 插入和删除</h3><p><strong>功能描述：</strong></p><ul><li>map 容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code> // 在容器中插入元素。</li><li><code>clear();</code> // 清除所有元素</li><li><code>erase(pos);</code> // 删除 pos 迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code> // 删除区间 [beg,end) 的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code> // 删除容器中<strong>键值为 key</strong> 的元素。</li></ul><pre><code class="language-c++">	//插入
	map&lt;int, int&gt; m;
	//第一种插入方式
	m.insert(pair&lt;int, int&gt;(1, 10));
	//第二种插入方式
	m.insert(make_pair(2, 20));
	//第三种插入方式
	m.insert(map&lt;int, int&gt;::value_type(3, 30));
	//第四种插入方式
	m[4] = 40; 
	//[]不建议用于访问,若键值不存在,则会创建出一个对应键值且value=0的元素
</code></pre><h3 id="map查找和统计"><a class="anchor" href="#map查找和统计">#</a> map 查找和统计</h3><p><strong>功能描述：</strong></p><ul><li>对 map 容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code> // 查找 key 是否存在，若存在，返回该键的元素的迭代器；若不存在，返回 map.end ();</li><li><code>count(key);</code> // 统计 key 的元素个数</li></ul><pre><code class="language-c++">#include&lt;map&gt;
int main()
&#123;
	map&lt;int, int&gt; m;
	m[1] = 10;
	m[2] = 20;
	m[3] = 30;
	m[4] = 10;

	for (auto it = m.begin(); it != m.end(); it++)
		cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
	

	auto pos = m.find(5);//声明一个迭代器存储find的返回值
	if (pos != m.end())
		cout &lt;&lt; &quot;find&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;not find&quot; &lt;&lt; endl;
	
	return 0;
&#125;
</code></pre><h3 id="map容器排序"><a class="anchor" href="#map容器排序">#</a> map 容器排序</h3><p><strong>学习目标：</strong></p><ul><li>map 容器默认排序规则为 按照 key 值进行 从小到大排序，掌握如何改变排序规则</li></ul><p><strong>主要技术点:</strong></p><ul><li>利用仿函数，可以改变排序规则</li></ul><pre><code class="language-c++">class Cmp &#123;
public:
	bool operator()(int a, int b) const
	&#123;
		return a &gt; b;
	&#125;
&#125;;

int main()
&#123;
	map&lt;int, int, Cmp&gt; m;
	m[1] = 10;
	m[2] = 20;
	m[3] = 30;
	m[4] = 10;

	for (auto it = m.begin(); it != m.end(); it++)
		cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;

	return 0;
&#125;
</code></pre><p>总结：</p><ul><li>利用仿函数可以指定 map 容器的排序规则</li><li>对于自定义数据类型，map 必须要指定排序规则，同 set 容器</li></ul><h2 id="4-stl-函数对象"><a class="anchor" href="#4-stl-函数对象">#</a> 4 STL- 函数对象</h2><h3 id="41-函数对象"><a class="anchor" href="#41-函数对象">#</a> 4.1 函数对象</h3><h4 id="411-函数对象概念"><a class="anchor" href="#411-函数对象概念">#</a> 4.1.1 函数对象概念</h4><p><strong>概念：</strong></p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用重载的 () 时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul><p><strong>本质：</strong></p><p>函数对象 (仿函数) 是一个<strong>类</strong>，不是一个函数</p><h4 id="412-函数对象使用"><a class="anchor" href="#412-函数对象使用">#</a> 4.1.2 函数对象使用</h4><p><strong>特点：</strong></p><ul><li>函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><p><strong>示例:</strong></p><pre><code class="language-C++">#include &lt;string&gt;

//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值
class MyAdd
&#123;
public :
	int operator()(int v1,int v2)
	&#123;
		return v1 + v2;
	&#125;
&#125;;

void test01()
&#123;
	MyAdd myAdd;
	cout &lt;&lt; myAdd(10, 10) &lt;&lt; endl;
&#125;

//2、函数对象可以有自己的状态
class MyPrint
&#123;
public:
	MyPrint()
	&#123;
		count = 0;
	&#125;
	void operator()(string test)
	&#123;
		cout &lt;&lt; test &lt;&lt; endl;
		count++; //统计使用次数
	&#125;

	int count; //内部自己的状态
&#125;;
void test02()
&#123;
	MyPrint myPrint;
	myPrint(&quot;hello world&quot;);
	myPrint(&quot;hello world&quot;);
	myPrint(&quot;hello world&quot;);
	cout &lt;&lt; &quot;myPrint调用次数为： &quot; &lt;&lt; myPrint.count &lt;&lt; endl;
&#125;

//3、函数对象可以作为参数传递
void doPrint(MyPrint &amp;mp , string test)
&#123;
	mp(test);
&#125;

void test03()
&#123;
	MyPrint myPrint;
	doPrint(myPrint, &quot;Hello C++&quot;);
&#125;

int main() &#123;

	//test01();
	//test02();
	test03();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>总结：</p><ul><li>仿函数写法非常灵活，可以作为参数进行传递。</li></ul><h3 id="42-谓词"><a class="anchor" href="#42-谓词">#</a> 4.2 谓词</h3><h4 id="421-谓词概念"><a class="anchor" href="#421-谓词概念">#</a> 4.2.1 谓词概念</h4><p><strong>概念：</strong></p><ul><li>返回 bool 类型的仿函数称为<strong>谓词</strong></li><li>如果 operator () 接受一个参数，那么叫做一元谓词</li><li>如果 operator () 接受两个参数，那么叫做二元谓词</li></ul><h4 id="422-一元谓词"><a class="anchor" href="#422-一元谓词">#</a> 4.2.2 一元谓词</h4><p><strong>示例：</strong></p><pre><code class="language-C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;

//1.一元谓词
struct GreaterFive&#123;
	bool operator()(int val) &#123;
		return val &gt; 5;
	&#125;
&#125;;

void test01() &#123;

	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 10; i++)
	&#123;
		v.push_back(i);
	&#125;

	vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());
	if (it == v.end()) &#123;
		cout &lt;&lt; &quot;没找到!&quot; &lt;&lt; endl;
	&#125;
	else &#123;
		cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;
	&#125;

&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>总结：参数只有一个的谓词，称为一元谓词</p><h4 id="423-二元谓词"><a class="anchor" href="#423-二元谓词">#</a> 4.2.3 二元谓词</h4><p><strong>示例：</strong></p><pre><code class="language-C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;
//二元谓词
class MyCompare
&#123;
public:
	bool operator()(int num1, int num2)
	&#123;
		return num1 &gt; num2;
	&#125;
&#125;;

void test01()
&#123;
	vector&lt;int&gt; v;
	v.push_back(10);
	v.push_back(40);
	v.push_back(20);
	v.push_back(30);
	v.push_back(50);

	//默认从小到大
	sort(v.begin(), v.end());
	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
	&#123;
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	&#125;
	cout &lt;&lt; endl;
	cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;

	//使用函数对象改变算法策略，排序从大到小
	sort(v.begin(), v.end(), MyCompare());
	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
	&#123;
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	&#125;
	cout &lt;&lt; endl;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>总结：参数只有两个的谓词，称为二元谓词</p><h3 id="43-内建函数对象"><a class="anchor" href="#43-内建函数对象">#</a> 4.3 内建函数对象</h3><h4 id="431-内建函数对象意义"><a class="anchor" href="#431-内建函数对象意义">#</a> 4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p><ul><li>STL 内建了一些函数对象</li></ul><p><strong>分类:</strong></p><ul><li><p>算术仿函数</p></li><li><p>关系仿函数</p></li><li><p>逻辑仿函数</p></li></ul><p><strong>用法：</strong></p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li></ul><h4 id="432-算术仿函数"><a class="anchor" href="#432-算术仿函数">#</a> 4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现四则运算</li><li>其中 negate 是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code> // 加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code> // 减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code> // 乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code> // 除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code> // 取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code> // 取反仿函数</li></ul><p><strong>示例：</strong></p><pre><code class="language-C++">#include &lt;functional&gt;
//negate
void test01()
&#123;
	negate&lt;int&gt; n;
	cout &lt;&lt; n(50) &lt;&lt; endl;
&#125;

//plus
void test02()
&#123;
	plus&lt;int&gt; p;
	cout &lt;&lt; p(10, 20) &lt;&lt; endl;
&#125;

int main() &#123;

	test01();
	test02();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p><h4 id="433-关系仿函数"><a class="anchor" href="#433-关系仿函数">#</a> 4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code> // 等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code> // 不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code> // 大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code> // 大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code> // 小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code> // 小于等于</li></ul><p><strong>示例：</strong></p><pre><code class="language-C++">#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class MyCompare
&#123;
public:
	bool operator()(int v1,int v2)
	&#123;
		return v1 &gt; v2;
	&#125;
&#125;;
void test01()
&#123;
	vector&lt;int&gt; v;

	v.push_back(10);
	v.push_back(30);
	v.push_back(50);
	v.push_back(40);
	v.push_back(20);

	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	&#125;
	cout &lt;&lt; endl;

	//自己实现仿函数
	//sort(v.begin(), v.end(), MyCompare());
	//STL内建仿函数  大于仿函数
	sort(v.begin(), v.end(), greater&lt;int&gt;());

	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	&#125;
	cout &lt;&lt; endl;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>总结：关系仿函数中最常用的就是 greater&lt;&gt; 大于</p><h4 id="434-逻辑仿函数"><a class="anchor" href="#434-逻辑仿函数">#</a> 4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code> // 逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code> // 逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code> // 逻辑非</li></ul><p><strong>示例：</strong></p><pre><code class="language-C++">#include &lt;vector&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;
void test01()
&#123;
	vector&lt;bool&gt; v;
	v.push_back(true);
	v.push_back(false);
	v.push_back(true);
	v.push_back(false);

	for (vector&lt;bool&gt;::iterator it = v.begin();it!= v.end();it++)
	&#123;
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	&#125;
	cout &lt;&lt; endl;

	//逻辑非  将v容器搬运到v2中，并执行逻辑非运算
	vector&lt;bool&gt; v2;
	v2.resize(v.size());
	transform(v.begin(), v.end(),  v2.begin(), logical_not&lt;bool&gt;());
	for (vector&lt;bool&gt;::iterator it = v2.begin(); it != v2.end(); it++)
	&#123;
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	&#125;
	cout &lt;&lt; endl;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>总结：逻辑仿函数实际应用较少，了解即可</p><h2 id="5-stl-常用算法"><a class="anchor" href="#5-stl-常用算法">#</a> 5 STL- 常用算法</h2><p><strong>概述</strong>:</p><ul><li><p>算法主要是由头文件 <code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code> 组成。</p></li><li><p><code>&lt;algorithm&gt;</code> 是所有 STL 头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</p></li><li><p><code>&lt;numeric&gt;</code> 体积很小，只包括几个在序列上面进行简单数学运算的模板函数</p></li><li><p><code>&lt;functional&gt;</code> 定义了一些模板类，用以声明函数对象。</p></li></ul><h3 id="51-常用遍历算法"><a class="anchor" href="#51-常用遍历算法">#</a> 5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的遍历算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>for_each</code> // 遍历容器</li><li><code>transform</code> // 搬运容器到另一个容器中</li></ul><h4 id="511-for_each"><a class="anchor" href="#511-for_each">#</a> 5.1.1 for_each</h4><p><strong>功能描述：</strong></p><ul><li>实现遍历容器</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>for_each(iterator beg, iterator end, _func);</code></p><p>// 遍历算法 遍历容器元素</p><p>//beg 开始迭代器</p><p>//end 结束迭代器</p><p>//_func 函数或者函数对象</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

//普通函数
void print01(int val) 
&#123;
	cout &lt;&lt; val &lt;&lt; &quot; &quot;;
&#125;
//函数对象
class print02 
&#123;
 public:
	void operator()(int val) 
	&#123;
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	&#125;
&#125;;

//for_each算法基本用法
void test01() &#123;

	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 10; i++) 
	&#123;
		v.push_back(i);
	&#125;

	//遍历算法
	for_each(v.begin(), v.end(), print01);
	cout &lt;&lt; endl;

	for_each(v.begin(), v.end(), print02());
	cout &lt;&lt; endl;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>** 总结：**for_each 在实际开发中是最常用遍历算法，需要熟练掌握</p><h4 id="512-transform"><a class="anchor" href="#512-transform">#</a> 5.1.2 transform</h4><p><strong>功能描述：</strong></p><ul><li>搬运容器到另一个容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li></ul><p>//beg1 源容器开始迭代器</p><p>//end1 源容器结束迭代器</p><p>//beg2 目标容器开始迭代器</p><p>//_func 函数或者函数对象</p><p><strong>示例：</strong></p><pre><code class="language-C++">#include&lt;vector&gt;
#include&lt;algorithm&gt;

//常用遍历算法  搬运 transform

class TransForm
&#123;
public:
	int operator()(int val)
	&#123;
		return val;
	&#125;

&#125;;

class MyPrint
&#123;
public:
	void operator()(int val)
	&#123;
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	&#125;
&#125;;

void test01()
&#123;
	vector&lt;int&gt;v;
	for (int i = 0; i &lt; 10; i++)
	&#123;
		v.push_back(i);
	&#125;

	vector&lt;int&gt;vTarget; //目标容器

	vTarget.resize(v.size()); // 目标容器需要提前开辟空间

	transform(v.begin(), v.end(), vTarget.begin(), TransForm());

	for_each(vTarget.begin(), vTarget.end(), MyPrint());
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p><h3 id="52-常用查找算法"><a class="anchor" href="#52-常用查找算法">#</a> 5.2 常用查找算法</h3><p>学习目标：</p><ul><li>掌握常用的查找算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>find</code> // 查找元素</li><li><code>find_if</code> // 按条件查找元素</li><li><code>adjacent_find</code> // 查找相邻重复元素</li><li><code>binary_search</code> // 二分查找法</li><li><code>count</code> // 统计元素个数</li><li><code>count_if</code> // 按条件统计元素个数</li></ul><h4 id="521-find"><a class="anchor" href="#521-find">#</a> 5.2.1 find</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器 end ()</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find(iterator beg, iterator end, value);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>//beg 开始迭代器</p><p>//end 结束迭代器</p><p>//value 查找的元素</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
void test01() &#123;

	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 10; i++) &#123;
		v.push_back(i + 1);
	&#125;
	//查找容器中是否有 5 这个元素
	vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5);
	if (it == v.end()) 
	&#123;
		cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;
	&#125;
	else 
	&#123;
		cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;
	&#125;
&#125;

class Person &#123;
public:
	Person(string name, int age) 
	&#123;
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	&#125;
	//重载==
	bool operator==(const Person&amp; p) 
	&#123;
		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) 
		&#123;
			return true;
		&#125;
		return false;
	&#125;

public:
	string m_Name;
	int m_Age;
&#125;;

void test02() &#123;

	vector&lt;Person&gt; v;

	//创建数据
	Person p1(&quot;aaa&quot;, 10);
	Person p2(&quot;bbb&quot;, 20);
	Person p3(&quot;ccc&quot;, 30);
	Person p4(&quot;ddd&quot;, 40);

	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);

	vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2);
	if (it == v.end()) 
	&#123;
		cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;
	&#125;
	else 
	&#123;
		cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;
	&#125;
&#125;
</code></pre><p>总结： 利用 find 可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p><h4 id="522-find_if"><a class="anchor" href="#522-find_if">#</a> 5.2.2 find_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件查找元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find_if(iterator beg, iterator end, _Pred);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>//beg 开始迭代器</p><p>//end 结束迭代器</p><p>//_Pred 函数或者谓词（返回 bool 类型的仿函数）</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

//内置数据类型
class GreaterFive
&#123;
public:
	bool operator()(int val)
	&#123;
		return val &gt; 5;
	&#125;
&#125;;

void test01() &#123;

	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 10; i++) &#123;
		v.push_back(i + 1);
	&#125;

	vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());
	if (it == v.end()) &#123;
		cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;
	&#125;
	else &#123;
		cout &lt;&lt; &quot;找到大于5的数字:&quot; &lt;&lt; *it &lt;&lt; endl;
	&#125;
&#125;

//自定义数据类型
class Person &#123;
public:
	Person(string name, int age)
	&#123;
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	&#125;
public:
	string m_Name;
	int m_Age;
&#125;;

class Greater20
&#123;
public:
	bool operator()(Person &amp;p)
	&#123;
		return p.m_Age &gt; 20;
	&#125;

&#125;;

void test02() &#123;

	vector&lt;Person&gt; v;

	//创建数据
	Person p1(&quot;aaa&quot;, 10);
	Person p2(&quot;bbb&quot;, 20);
	Person p3(&quot;ccc&quot;, 30);
	Person p4(&quot;ddd&quot;, 40);

	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);

	vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20());
	if (it == v.end())
	&#123;
		cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;
	&#125;
	else
	&#123;
		cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;
	&#125;
&#125;

int main() &#123;

	//test01();

	test02();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>总结：find_if 按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p><h4 id="523-adjacent_find"><a class="anchor" href="#523-adjacent_find">#</a> 5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p><ul><li>查找相邻重复元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>adjacent_find(iterator beg, iterator end);</code></p><p>// 查找相邻重复元素，返回相邻元素的第一个位置的迭代器</p><p>//beg 开始迭代器</p><p>//end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

void test01()
&#123;
	vector&lt;int&gt; v;
	v.push_back(1);
	v.push_back(2);
	v.push_back(5);
	v.push_back(2);
	v.push_back(4);
	v.push_back(4);
	v.push_back(3);

	//查找相邻重复元素
	vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end());
	if (it == v.end()) &#123;
		cout &lt;&lt; &quot;找不到!&quot; &lt;&lt; endl;
	&#125;
	else &#123;
		cout &lt;&lt; &quot;找到相邻重复元素为:&quot; &lt;&lt; *it &lt;&lt; endl;
	&#125;
&#125;
</code></pre><p>总结：面试题中如果出现查找相邻重复元素，记得用 STL 中的 adjacent_find 算法</p><h4 id="524-binary_search"><a class="anchor" href="#524-binary_search">#</a> 5.2.4 binary_search</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素是否存在</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>bool binary_search(iterator beg, iterator end, value);</code></p><p>// 查找指定的元素，查到 返回 true 否则 false</p><p>// 注意：在<strong>无序序列中不可用</strong></p><p>//beg 开始迭代器</p><p>//end 结束迭代器</p><p>//value 查找的元素</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

void test01()
&#123;
	vector&lt;int&gt;v;

	for (int i = 0; i &lt; 10; i++)
	&#123;
		v.push_back(i);
	&#125;
	//二分查找
	bool ret = binary_search(v.begin(), v.end(),2);
	if (ret)
	&#123;
		cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl;
	&#125;
	else
	&#123;
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	&#125;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>** 总结：** 二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p><h4 id="525-count"><a class="anchor" href="#525-count">#</a> 5.2.5 count</h4><p><strong>功能描述：</strong></p><ul><li>统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count(iterator beg, iterator end, value);</code></p><p>// 统计元素出现次数</p><p>//beg 开始迭代器</p><p>//end 结束迭代器</p><p>//value 统计的元素</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

//内置数据类型
void test01()
&#123;
	vector&lt;int&gt; v;
	v.push_back(1);
	v.push_back(2);
	v.push_back(4);
	v.push_back(5);
	v.push_back(3);
	v.push_back(4);
	v.push_back(4);

	int num = count(v.begin(), v.end(), 4);

	cout &lt;&lt; &quot;4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;
&#125;

//自定义数据类型
class Person
&#123;
public:
	Person(string name, int age)
	&#123;
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	&#125;
	bool operator==(const Person &amp; p)
	&#123;
		if (this-&gt;m_Age == p.m_Age)
		&#123;
			return true;
		&#125;
		else
		&#123;
			return false;
		&#125;
	&#125;
	string m_Name;
	int m_Age;
&#125;;

void test02()
&#123;
	vector&lt;Person&gt; v;

	Person p1(&quot;刘备&quot;, 35);
	Person p2(&quot;关羽&quot;, 35);
	Person p3(&quot;张飞&quot;, 35);
	Person p4(&quot;赵云&quot;, 30);
	Person p5(&quot;曹操&quot;, 25);

	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);
	v.push_back(p5);
    
    Person p(&quot;诸葛亮&quot;,35);

	int num = count(v.begin(), v.end(), p);
	cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;
&#125;
int main() &#123;

	//test01();

	test02();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p><h4 id="526-count_if"><a class="anchor" href="#526-count_if">#</a> 5.2.6 count_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count_if(iterator beg, iterator end, _Pred);</code></p><p>// 按条件统计元素出现次数</p><p>//beg 开始迭代器</p><p>//end 结束迭代器</p><p>//_Pred 谓词</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class Greater4
&#123;
public:
	bool operator()(int val)
	&#123;
		return val &gt;= 4;
	&#125;
&#125;;

//内置数据类型
void test01()
&#123;
	vector&lt;int&gt; v;
	v.push_back(1);
	v.push_back(2);
	v.push_back(4);
	v.push_back(5);
	v.push_back(3);
	v.push_back(4);
	v.push_back(4);

	int num = count_if(v.begin(), v.end(), Greater4());

	cout &lt;&lt; &quot;大于4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;
&#125;

//自定义数据类型
class Person
&#123;
public:
	Person(string name, int age)
	&#123;
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	&#125;

	string m_Name;
	int m_Age;
&#125;;

class AgeLess35
&#123;
public:
	bool operator()(const Person &amp;p)
	&#123;
		return p.m_Age &lt; 35;
	&#125;
&#125;;
void test02()
&#123;
	vector&lt;Person&gt; v;

	Person p1(&quot;刘备&quot;, 35);
	Person p2(&quot;关羽&quot;, 35);
	Person p3(&quot;张飞&quot;, 35);
	Person p4(&quot;赵云&quot;, 30);
	Person p5(&quot;曹操&quot;, 25);

	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);
	v.push_back(p5);

	int num = count_if(v.begin(), v.end(), AgeLess35());
	cout &lt;&lt; &quot;小于35岁的个数：&quot; &lt;&lt; num &lt;&lt; endl;
&#125;


int main() &#123;

	//test01();

	test02();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>** 总结：** 按值统计用 count，按条件统计用 count_if</p><h3 id="53-常用排序算法"><a class="anchor" href="#53-常用排序算法">#</a> 5.3 常用排序算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的排序算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>sort</code> // 对容器内元素进行排序</li><li><code>random_shuffle</code> // 洗牌 指定范围内的元素随机调整次序</li><li><code>merge</code> // 容器元素合并，并存储到另一容器中</li><li><code>reverse</code> // 反转指定范围的元素</li></ul><h4 id="531-sort"><a class="anchor" href="#531-sort">#</a> 5.3.1 sort</h4><p><strong>功能描述：</strong></p><ul><li>对容器内元素进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>sort(iterator beg, iterator end, _Pred);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>//_Pred 谓词</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

void myPrint(int val)
&#123;
	cout &lt;&lt; val &lt;&lt; &quot; &quot;;
&#125;

void test01() &#123;
	vector&lt;int&gt; v;
	v.push_back(10);
	v.push_back(30);
	v.push_back(50);
	v.push_back(20);
	v.push_back(40);

	//sort默认从小到大排序
	sort(v.begin(), v.end());
	for_each(v.begin(), v.end(), myPrint);
	cout &lt;&lt; endl;

	//从大到小排序
	sort(v.begin(), v.end(), greater&lt;int&gt;());
	for_each(v.begin(), v.end(), myPrint);
	cout &lt;&lt; endl;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>** 总结：**sort 属于开发中最常用的算法之一，需熟练掌握</p><h4 id="532-random_shuffle"><a class="anchor" href="#532-random_shuffle">#</a> 5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p><ul><li>洗牌 指定范围内的元素随机调整次序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>random_shuffle(iterator beg, iterator end);</code></p><p>// 指定范围内的元素随机调整次序</p><p>//beg 开始迭代器</p><p>//end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;ctime&gt;

class myPrint
&#123;
public:
	void operator()(int val)
	&#123;
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	&#125;
&#125;;

void test01()
&#123;
	srand((unsigned int)time(NULL));
	vector&lt;int&gt; v;
	for(int i = 0 ; i &lt; 10;i++)
	&#123;
		v.push_back(i);
	&#125;
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;

	//打乱顺序
	random_shuffle(v.begin(), v.end());
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>** 总结：**random_shuffle 洗牌算法比较实用，使用时记得加随机数种子</p><h4 id="533-merge"><a class="anchor" href="#533-merge">#</a> 5.3.3 merge</h4><p><strong>功能描述：</strong></p><ul><li>两个容器元素合并，并存储到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 容器元素合并，并存储到另一容器中</p><p>// 注意：两个容器必须是<strong>有序的</strong></p><p>//beg1 容器 1 开始迭代器<br>//end1 容器 1 结束迭代器<br>//beg2 容器 2 开始迭代器<br>//end2 容器 2 结束迭代器<br>//dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
&#123;
public:
	void operator()(int val)
	&#123;
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	&#125;
&#125;;

void test01()
&#123;
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	for (int i = 0; i &lt; 10 ; i++) 
    &#123;
		v1.push_back(i);
		v2.push_back(i + 1);
	&#125;

	vector&lt;int&gt; vtarget;
	//目标容器需要提前开辟空间
	vtarget.resize(v1.size() + v2.size());
	//合并  需要两个有序序列
	merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());
	for_each(vtarget.begin(), vtarget.end(), myPrint());
	cout &lt;&lt; endl;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>** 总结：**merge 合并的两个容器必须的有序序列</p><h4 id="534-reverse"><a class="anchor" href="#534-reverse">#</a> 5.3.4 reverse</h4><p><strong>功能描述：</strong></p><ul><li>将容器内元素进行反转</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>reverse(iterator beg, iterator end);</code></p><p>// 反转指定范围的元素</p><p>//beg 开始迭代器</p><p>//end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
&#123;
public:
	void operator()(int val)
	&#123;
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	&#125;
&#125;;

void test01()
&#123;
	vector&lt;int&gt; v;
	v.push_back(10);
	v.push_back(30);
	v.push_back(50);
	v.push_back(20);
	v.push_back(40);

	cout &lt;&lt; &quot;反转前： &quot; &lt;&lt; endl;
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;

	cout &lt;&lt; &quot;反转后： &quot; &lt;&lt; endl;

	reverse(v.begin(), v.end());
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>** 总结：**reverse 反转区间内元素，面试题可能涉及到</p><h3 id="54-常用拷贝和替换算法"><a class="anchor" href="#54-常用拷贝和替换算法">#</a> 5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的拷贝和替换算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>copy</code> // 容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code> // 将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if</code> // 容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code> // 互换两个容器的元素</li></ul><h4 id="541-copy"><a class="anchor" href="#541-copy">#</a> 5.4.1 copy</h4><p><strong>功能描述：</strong></p><ul><li>容器内指定范围的元素拷贝到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>copy(iterator beg, iterator end, iterator dest);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>//beg 开始迭代器</p><p>//end 结束迭代器</p><p>//dest 目标起始迭代器</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
&#123;
public:
	void operator()(int val)
	&#123;
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	&#125;
&#125;;

void test01()
&#123;
	vector&lt;int&gt; v1;
	for (int i = 0; i &lt; 10; i++) &#123;
		v1.push_back(i + 1);
	&#125;
	vector&lt;int&gt; v2;
	v2.resize(v1.size());
	copy(v1.begin(), v1.end(), v2.begin());

	for_each(v2.begin(), v2.end(), myPrint());
	cout &lt;&lt; endl;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>** 总结：** 利用 copy 算法在拷贝时，目标容器记得提前开辟空间</p><h4 id="542-replace"><a class="anchor" href="#542-replace">#</a> 5.4.2 replace</h4><p><strong>功能描述：</strong></p><ul><li>将容器内指定范围的旧元素修改为新元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);</code></p><p>// 将区间内旧元素 替换成 新元素</p><p>//beg 开始迭代器</p><p>//end 结束迭代器</p><p>//oldvalue 旧元素</p><p>//newvalue 新元素</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
&#123;
public:
	void operator()(int val)
	&#123;
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	&#125;
&#125;;

void test01()
&#123;
	vector&lt;int&gt; v;
	v.push_back(20);
	v.push_back(30);
	v.push_back(20);
	v.push_back(40);
	v.push_back(50);
	v.push_back(10);
	v.push_back(20);

	cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;

	//将容器中的20 替换成 2000
	cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;
	replace(v.begin(), v.end(), 20,2000);
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>** 总结：**replace 会替换区间内满足条件的元素</p><h4 id="543-replace_if"><a class="anchor" href="#543-replace_if">#</a> 5.4.3 replace_if</h4><p><strong>功能描述:</strong></p><ul><li>将区间内满足条件的元素，替换成指定元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);</code></p><p>// 按条件替换元素，满足条件的替换成指定元素</p><p>//beg 开始迭代器</p><p>//end 结束迭代器</p><p>//_pred 谓词</p><p>//newvalue 替换的新元素</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
&#123;
public:
	void operator()(int val)
	&#123;
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	&#125;
&#125;;

class ReplaceGreater30
&#123;
public:
	bool operator()(int val)
	&#123;
		return val &gt;= 30;
	&#125;

&#125;;

void test01()
&#123;
	vector&lt;int&gt; v;
	v.push_back(20);
	v.push_back(30);
	v.push_back(20);
	v.push_back(40);
	v.push_back(50);
	v.push_back(10);
	v.push_back(20);

	cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;

	//将容器中大于等于的30 替换成 3000
	cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;
	replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000);
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>** 总结：**replace_if 按条件查找，可以利用仿函数灵活筛选满足的条件</p><h4 id="544-swap"><a class="anchor" href="#544-swap">#</a> 5.4.4 swap</h4><p><strong>功能描述：</strong></p><ul><li>互换两个容器的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>swap(container c1, container c2);</code></p><p>// 互换两个容器的元素</p><p>//c1 容器 1</p><p>//c2 容器 2</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
&#123;
public:
	void operator()(int val)
	&#123;
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	&#125;
&#125;;

void test01()
&#123;
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	for (int i = 0; i &lt; 10; i++) &#123;
		v1.push_back(i);
		v2.push_back(i+100);
	&#125;

	cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;
	for_each(v1.begin(), v1.end(), myPrint());
	cout &lt;&lt; endl;
	for_each(v2.begin(), v2.end(), myPrint());
	cout &lt;&lt; endl;

	cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;
	swap(v1, v2);
	for_each(v1.begin(), v1.end(), myPrint());
	cout &lt;&lt; endl;
	for_each(v2.begin(), v2.end(), myPrint());
	cout &lt;&lt; endl;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>** 总结：**swap 交换容器时，注意交换的容器要同种类型</p><h3 id="55-常用算术生成算法"><a class="anchor" href="#55-常用算术生成算法">#</a> 5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的算术生成算法</li></ul><p><strong>注意：</strong></p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>accumulate</code> // 计算容器元素累计总和</p></li><li><p><code>fill</code> // 向容器中添加元素</p></li></ul><h4 id="551-accumulate"><a class="anchor" href="#551-accumulate">#</a> 5.5.1 accumulate</h4><p><strong>功能描述：</strong></p><ul><li>计算区间内 容器元素累计总和</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>accumulate(iterator beg, iterator end, value);</code></p><p>// 计算容器元素累计总和</p><p>//beg 开始迭代器</p><p>//end 结束迭代器</p><p>//value 起始值</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-c++">#include &lt;numeric&gt;
#include &lt;vector&gt;
void test01()
&#123;
	vector&lt;int&gt; v;
	for (int i = 0; i &lt;= 100; i++) &#123;
		v.push_back(i);
	&#125;

	int total = accumulate(v.begin(), v.end(), 0);

	cout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>** 总结：**accumulate 使用时头文件注意是 numeric，这个算法很实用</p><h4 id="552-fill"><a class="anchor" href="#552-fill">#</a> 5.5.2 fill</h4><p><strong>功能描述：</strong></p><ul><li>向容器中填充指定的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>fill(iterator beg, iterator end, value);</code></p><p>// 向容器中填充元素</p><p>//beg 开始迭代器</p><p>//end 结束迭代器</p><p>//value 填充的值</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-c++">#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class myPrint
&#123;
public:
	void operator()(int val)
	&#123;
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	&#125;
&#125;;

void test01()
&#123;

	vector&lt;int&gt; v;
	v.resize(10);
	//填充
	fill(v.begin(), v.end(), 100);

	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p>** 总结：** 利用 fill 可以将容器区间内元素填充为 指定的值</p><h3 id="56-常用集合算法"><a class="anchor" href="#56-常用集合算法">#</a> 5.6 常用集合算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的集合算法</li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>set_intersection</code> // 求两个容器的交集</p></li><li><p><code>set_union</code> // 求两个容器的并集</p></li><li><p><code>set_difference</code> // 求两个容器的差集</p></li></ul><h4 id="561-set_intersection"><a class="anchor" href="#561-set_intersection">#</a> 5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p><ul><li>求两个容器的交集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的交集</p><p>// <strong>注意：两个集合必须是有序序列</strong></p><p>//beg1 容器 1 开始迭代器<br>//end1 容器 1 结束迭代器<br>//beg2 容器 2 开始迭代器<br>//end2 容器 2 结束迭代器<br>//dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;

class myPrint
&#123;
public:
	void operator()(int val)
	&#123;
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	&#125;
&#125;;

void test01()
&#123;
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	for (int i = 0; i &lt; 10; i++)
    &#123;
		v1.push_back(i);
		v2.push_back(i+5);
	&#125;

	vector&lt;int&gt; vTarget;
	//取两个里面较小的值给目标容器开辟空间
	vTarget.resize(min(v1.size(), v2.size()));

	//返回目标容器的最后一个元素的迭代器地址
	vector&lt;int&gt;::iterator itEnd = 
        set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());

	for_each(vTarget.begin(), itEnd, myPrint());
	cout &lt;&lt; endl;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p><strong>总结：</strong></p><ul><li>求交集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li><li>set_intersection 返回值既是交集中最后一个元素的位置</li></ul><h4 id="562-set_union"><a class="anchor" href="#562-set_union">#</a> 5.6.2 set_union</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的并集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的并集</p><p>// <strong>注意：两个集合必须是有序序列</strong></p><p>//beg1 容器 1 开始迭代器<br>//end1 容器 1 结束迭代器<br>//beg2 容器 2 开始迭代器<br>//end2 容器 2 结束迭代器<br>//dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;

class myPrint
&#123;
public:
	void operator()(int val)
	&#123;
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	&#125;
&#125;;

void test01()
&#123;
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	for (int i = 0; i &lt; 10; i++) &#123;
		v1.push_back(i);
		v2.push_back(i+5);
	&#125;

	vector&lt;int&gt; vTarget;
	//取两个容器的和给目标容器开辟空间
	vTarget.resize(v1.size() + v2.size());

	//返回目标容器的最后一个元素的迭代器地址
	vector&lt;int&gt;::iterator itEnd = 
        set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());

	for_each(vTarget.begin(), itEnd, myPrint());
	cout &lt;&lt; endl;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p><strong>总结：</strong></p><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要<strong>两个容器相加</strong></li><li>set_union 返回值既是并集中最后一个元素的位置</li></ul><h4 id="563-set_difference"><a class="anchor" href="#563-set_difference">#</a> 5.6.3 set_difference</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的差集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的差集</p><p>// <strong>注意：两个集合必须是有序序列</strong></p><p>//beg1 容器 1 开始迭代器<br>//end1 容器 1 结束迭代器<br>//beg2 容器 2 开始迭代器<br>//end2 容器 2 结束迭代器<br>//dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><pre><code class="language-C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;

class myPrint
&#123;
public:
	void operator()(int val)
	&#123;
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	&#125;
&#125;;

void test01()
&#123;
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	for (int i = 0; i &lt; 10; i++) &#123;
		v1.push_back(i);
		v2.push_back(i+5);
	&#125;

	vector&lt;int&gt; vTarget;
	//取两个里面较大的值给目标容器开辟空间
	vTarget.resize( max(v1.size() , v2.size()));

	//返回目标容器的最后一个元素的迭代器地址
	cout &lt;&lt; &quot;v1与v2的差集为： &quot; &lt;&lt; endl;
	vector&lt;int&gt;::iterator itEnd = 
        set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());
	for_each(vTarget.begin(), itEnd, myPrint());
	cout &lt;&lt; endl;


	cout &lt;&lt; &quot;v2与v1的差集为： &quot; &lt;&lt; endl;
	itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());
	for_each(vTarget.begin(), itEnd, myPrint());
	cout &lt;&lt; endl;
&#125;

int main() &#123;

	test01();

	system(&quot;pause&quot;);

	return 0;
&#125;
</code></pre><p><strong>总结：</strong></p><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li><li>set_difference 返回值既是差集中最后一个元素的位置</li></ul></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2021-01-28 20:47:31" itemprop="dateModified" datetime="2021-01-28T20:47:31+08:00">2021-01-28</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Ling yunchi 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Ling yunchi 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Ling yunchi 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Ling yunchi <i class="ic i-at"><em>@</em></i>QWQ</li><li class="link"><strong>本文链接：</strong> <a href="https://ling-yunchi.github.io/2021/01/25/c++STL/" title="c++STL">https://ling-yunchi.github.io/2021/01/25/c++STL/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/01/25/git%E7%AC%94%E8%AE%B0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicit31ffoj20zk0m8naf.jpg" title="git笔记"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>git笔记</h3></a></div><div class="item right"><a href="/2021/01/27/%E8%B4%AA%E5%BF%83/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclxp31goj20zk0m8qv5.jpg" title="贪心"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>贪心</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#stl%E5%88%9D%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">STL 初识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#stl%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="toc-number">1.1.</span> <span class="toc-text">STL 的诞生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">STL 基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">STL 六大组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl%E4%B8%AD%E5%AE%B9%E5%99%A8-%E7%AE%97%E6%B3%95-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">STL 中容器、算法、迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl-%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">STL- 常用容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E5%AE%B9%E5%99%A8"><span class="toc-number">1.6.</span> <span class="toc-text">string 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">string 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.2.</span> <span class="toc-text">string 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.3.</span> <span class="toc-text">string 赋值操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-number">1.6.4.</span> <span class="toc-text">string 字符串拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.6.5.</span> <span class="toc-text">string 查找和替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-number">1.6.6.</span> <span class="toc-text">string 字符串比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AD%97%E7%AC%A6%E5%AD%98%E5%8F%96"><span class="toc-number">1.6.7.</span> <span class="toc-text">string 字符存取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">1.6.8.</span> <span class="toc-text">string 插入和删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AD%90%E4%B8%B2"><span class="toc-number">1.6.9.</span> <span class="toc-text">string 子串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">vector 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.1.</span> <span class="toc-text">vector 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.2.</span> <span class="toc-text">vector 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.3.</span> <span class="toc-text">vector 赋值操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%AE%B9%E9%87%8F%E5%92%8C%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.7.4.</span> <span class="toc-text">vector 容量和大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">1.7.5.</span> <span class="toc-text">vector 插入和删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">1.7.6.</span> <span class="toc-text">vector 数据存取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E4%BA%92%E6%8D%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">1.7.7.</span> <span class="toc-text">vector 互换容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E9%A2%84%E7%95%99%E7%A9%BA%E9%97%B4"><span class="toc-number">1.7.8.</span> <span class="toc-text">vector 预留空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8"><span class="toc-number">1.8.</span> <span class="toc-text">deque 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.1.</span> <span class="toc-text">deque 容器基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#332-deque%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.2.</span> <span class="toc-text">3.3.2 deque 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.8.3.</span> <span class="toc-text">deque 赋值操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">1.8.4.</span> <span class="toc-text">deque 大小操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">1.8.5.</span> <span class="toc-text">deque 插入和删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">1.8.6.</span> <span class="toc-text">deque 数据存取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque-%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.7.</span> <span class="toc-text">deque 排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stack%E5%AE%B9%E5%99%A8"><span class="toc-number">1.9.</span> <span class="toc-text">stack 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stack-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.9.1.</span> <span class="toc-text">stack 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stack-%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.9.2.</span> <span class="toc-text">stack 常用接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#queue-%E5%AE%B9%E5%99%A8"><span class="toc-number">1.10.</span> <span class="toc-text">queue 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#queue-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.10.1.</span> <span class="toc-text">queue 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue-%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.10.2.</span> <span class="toc-text">queue 常用接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#priority_queue"><span class="toc-number">1.10.3.</span> <span class="toc-text">priority_queue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list%E5%AE%B9%E5%99%A8"><span class="toc-number">1.11.</span> <span class="toc-text">list 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.11.1.</span> <span class="toc-text">list 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.2.</span> <span class="toc-text">list 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list-%E8%B5%8B%E5%80%BC%E5%92%8C%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.11.3.</span> <span class="toc-text">list 赋值和交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list-%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">1.11.4.</span> <span class="toc-text">list 大小操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">1.11.5.</span> <span class="toc-text">list 插入和删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">1.11.6.</span> <span class="toc-text">list 数据存取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list-%E5%8F%8D%E8%BD%AC%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">1.11.7.</span> <span class="toc-text">list 反转和排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-multiset-%E5%AE%B9%E5%99%A8"><span class="toc-number">1.12.</span> <span class="toc-text">set&#x2F;multiset 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.12.1.</span> <span class="toc-text">set 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-number">1.12.2.</span> <span class="toc-text">set 构造和赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.12.3.</span> <span class="toc-text">set 大小和交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">1.12.4.</span> <span class="toc-text">set 插入和删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E6%9F%A5%E6%89%BE%E5%92%8C%E7%BB%9F%E8%AE%A1"><span class="toc-number">1.12.5.</span> <span class="toc-text">set 查找和统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pair%E5%AF%B9%E7%BB%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.12.6.</span> <span class="toc-text">pair 对组创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E5%AE%B9%E5%99%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">1.12.7.</span> <span class="toc-text">set 容器排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map-multimap%E5%AE%B9%E5%99%A8"><span class="toc-number">1.13.</span> <span class="toc-text">map&#x2F;multimap 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.13.1.</span> <span class="toc-text">map 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-number">1.13.2.</span> <span class="toc-text">map 构造和赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.13.3.</span> <span class="toc-text">map 大小和交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">1.13.4.</span> <span class="toc-text">map 插入和删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E6%9F%A5%E6%89%BE%E5%92%8C%E7%BB%9F%E8%AE%A1"><span class="toc-number">1.13.5.</span> <span class="toc-text">map 查找和统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E5%AE%B9%E5%99%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.6.</span> <span class="toc-text">map 容器排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-stl-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.14.</span> <span class="toc-text">4 STL- 函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.14.1.</span> <span class="toc-text">4.1 函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#411-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5"><span class="toc-number">1.14.1.1.</span> <span class="toc-text">4.1.1 函数对象概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#412-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8"><span class="toc-number">1.14.1.2.</span> <span class="toc-text">4.1.2 函数对象使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E8%B0%93%E8%AF%8D"><span class="toc-number">1.14.2.</span> <span class="toc-text">4.2 谓词</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#421-%E8%B0%93%E8%AF%8D%E6%A6%82%E5%BF%B5"><span class="toc-number">1.14.2.1.</span> <span class="toc-text">4.2.1 谓词概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#422-%E4%B8%80%E5%85%83%E8%B0%93%E8%AF%8D"><span class="toc-number">1.14.2.2.</span> <span class="toc-text">4.2.2 一元谓词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#423-%E4%BA%8C%E5%85%83%E8%B0%93%E8%AF%8D"><span class="toc-number">1.14.2.3.</span> <span class="toc-text">4.2.3 二元谓词</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.14.3.</span> <span class="toc-text">4.3 内建函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#431-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%84%8F%E4%B9%89"><span class="toc-number">1.14.3.1.</span> <span class="toc-text">4.3.1 内建函数对象意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#432-%E7%AE%97%E6%9C%AF%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">1.14.3.2.</span> <span class="toc-text">4.3.2 算术仿函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#433-%E5%85%B3%E7%B3%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">1.14.3.3.</span> <span class="toc-text">4.3.3 关系仿函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#434-%E9%80%BB%E8%BE%91%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">1.14.3.4.</span> <span class="toc-text">4.3.4 逻辑仿函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-stl-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-number">1.15.</span> <span class="toc-text">5 STL- 常用算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.15.1.</span> <span class="toc-text">5.1 常用遍历算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#511-for_each"><span class="toc-number">1.15.1.1.</span> <span class="toc-text">5.1.1 for_each</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#512-transform"><span class="toc-number">1.15.1.2.</span> <span class="toc-text">5.1.2 transform</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">1.15.2.</span> <span class="toc-text">5.2 常用查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#521-find"><span class="toc-number">1.15.2.1.</span> <span class="toc-text">5.2.1 find</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#522-find_if"><span class="toc-number">1.15.2.2.</span> <span class="toc-text">5.2.2 find_if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#523-adjacent_find"><span class="toc-number">1.15.2.3.</span> <span class="toc-text">5.2.3 adjacent_find</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#524-binary_search"><span class="toc-number">1.15.2.4.</span> <span class="toc-text">5.2.4 binary_search</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#525-count"><span class="toc-number">1.15.2.5.</span> <span class="toc-text">5.2.5 count</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#526-count_if"><span class="toc-number">1.15.2.6.</span> <span class="toc-text">5.2.6 count_if</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.15.3.</span> <span class="toc-text">5.3 常用排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#531-sort"><span class="toc-number">1.15.3.1.</span> <span class="toc-text">5.3.1 sort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#532-random_shuffle"><span class="toc-number">1.15.3.2.</span> <span class="toc-text">5.3.2 random_shuffle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#533-merge"><span class="toc-number">1.15.3.3.</span> <span class="toc-text">5.3.3 merge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#534-reverse"><span class="toc-number">1.15.3.4.</span> <span class="toc-text">5.3.4 reverse</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-%E5%B8%B8%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.15.4.</span> <span class="toc-text">5.4 常用拷贝和替换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#541-copy"><span class="toc-number">1.15.4.1.</span> <span class="toc-text">5.4.1 copy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#542-replace"><span class="toc-number">1.15.4.2.</span> <span class="toc-text">5.4.2 replace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#543-replace_if"><span class="toc-number">1.15.4.3.</span> <span class="toc-text">5.4.3 replace_if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#544-swap"><span class="toc-number">1.15.4.4.</span> <span class="toc-text">5.4.4 swap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%9C%AF%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95"><span class="toc-number">1.15.5.</span> <span class="toc-text">5.5 常用算术生成算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#551-accumulate"><span class="toc-number">1.15.5.1.</span> <span class="toc-text">5.5.1 accumulate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#552-fill"><span class="toc-number">1.15.5.2.</span> <span class="toc-text">5.5.2 fill</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95"><span class="toc-number">1.15.6.</span> <span class="toc-text">5.6 常用集合算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#561-set_intersection"><span class="toc-number">1.15.6.1.</span> <span class="toc-text">5.6.1 set_intersection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#562-set_union"><span class="toc-number">1.15.6.2.</span> <span class="toc-text">5.6.2 set_union</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#563-set_difference"><span class="toc-number">1.15.6.3.</span> <span class="toc-text">5.6.3 set_difference</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Ling yunchi" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Ling yunchi</p><div class="description" itemprop="description">qwqqqq</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">39</span> <span class="name">文章</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpbmcteXVuY2hp" title="https:&#x2F;&#x2F;github.com&#x2F;Ling-yunchi"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/01/25/git%E7%AC%94%E8%AE%B0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/01/27/%E8%B4%AA%E5%BF%83/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Ling yunchi @ Ling Yunchi</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/01/25/c++STL/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->