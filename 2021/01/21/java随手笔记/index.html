<!-- build time:Mon Aug 09 2021 21:53:30 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="QWQ" href="https://ling-yunchi.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="QWQ" href="https://ling-yunchi.github.io/atom.xml"><link rel="alternate" type="application/json" title="QWQ" href="https://ling-yunchi.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://ling-yunchi.github.io/2021/01/21/java%E9%9A%8F%E6%89%8B%E7%AC%94%E8%AE%B0/"><title>java随手笔记 | Ling Yunchi = QWQ</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">java随手笔记</h1><div class="meta"><span class="item" title="创建时间：2021-01-21 09:46:52"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-01-21T09:46:52+08:00">2021-01-21</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Ling Yunchi</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipev1x5e4j20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipetlbztpj20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeuibk9fj20zk0m8ay2.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclxfdlttj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicljgocqbj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipewkhf1zj20zk0m81kx.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://ling-yunchi.github.io/2021/01/21/java%E9%9A%8F%E6%89%8B%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Ling yunchi"><meta itemprop="description" content=", qwqqqq"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="QWQ"></span><div class="body md" itemprop="articleBody"><h1 id="java"><a class="anchor" href="#java">#</a> JAVA</h1><h2 id="三大版本"><a class="anchor" href="#三大版本">#</a> 三大版本</h2><ul><li>JavaSE：标准版（桌面程序，控制台开发）</li><li>JavaME：嵌入式开发（手机，小家电）</li><li>JavaEE：企业级开发（web 端，服务器开发）</li></ul><h2 id="jdk-jre-jvm"><a class="anchor" href="#jdk-jre-jvm">#</a> JDK、JRE、JVM</h2><ul><li>JDK：Java Development Kit</li><li>JRE：Java Runtime Environment</li><li>JVM：Java Virtual Machine</li></ul><h2 id="java程序运行机制"><a class="anchor" href="#java程序运行机制">#</a> Java 程序运行机制</h2><p>半编译半解释</p><p>将 <code>*.java</code> 预编译成 <code>*.class</code> 后，再放入 JVM 的解释器中解释运行</p><h2 id="javadoc"><a class="anchor" href="#javadoc">#</a> JavaDoc</h2><p>javadoc 命令是用于自动生成 API 文档的</p><ul><li>参数信息<ul><li>@author 作者名</li><li>@version 版本号</li><li>@since 指明需要最早使用的 jdk 版本</li><li>@param 参数名</li><li>@return 返回值状况</li><li>@throw 异常抛出情况</li></ul></li></ul><figure class="highlight powershell"><figcaption data-lang="PowerShell"></figcaption><table><tr><td data-num="1"></td><td><pre>javadoc <span class="token operator">-</span>encoding UTF<span class="token operator">-</span>8 <span class="token operator">-</span>charset UTF<span class="token operator">-</span>8 Doc <span class="token operator">*</span><span class="token punctuation">.</span>java</pre></td></tr></table></figure><h2 id="标识符"><a class="anchor" href="#标识符">#</a> 标识符</h2><p>命名方式:</p><p>小驼峰命名法:<strong> 方法、变量</strong></p><ul><li><p>约定 1: 标识符是一个单词的时候，首字母小写</p></li><li><p>范例 1: name</p></li><li><p>约定 2: 标识符由多个单词组成的时候，第一个单词首字母小写，其他单词首字母大写</p></li><li><p>范例 2: firstName</p></li></ul><p>大驼峰命名法:<strong> 类</strong></p><ul><li><p>约定 1: 标识符是一个单词的时候，首字母大写</p></li><li><p>范例 1: Student</p></li><li><p>约定 2: 标识符由多个单词组成的时候，每个单词的首字母大写</p></li><li><p>范例 2: GoodStudent</p></li></ul><h2 id="类型转换"><a class="anchor" href="#类型转换">#</a> 类型转换</h2><h3 id="自动"><a class="anchor" href="#自动">#</a> 自动</h3><p><img data-src="/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt="转换规则"></p><p><img data-src="/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt="转换"></p><p><mark>注:byte 是不能直接转换为 char 的</mark></p><h3 id="强制"><a class="anchor" href="#强制">#</a> 强制</h3><p>会有数值精度丢失</p><h2 id="字符串的操作"><a class="anchor" href="#字符串的操作">#</a> 字符串的 + 操作</h2><p>在 + 的左右操作数中出现字符串时，该 + 号为字符串连接符，而非算术运算.</p><p>+ 号对字符串进行了重载</p><h2 id="赋值运算符"><a class="anchor" href="#赋值运算符">#</a> 赋值运算符</h2><p>扩展的赋值运算符底层<strong>隐含</strong>强制类型转换</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">short</span> s <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>s <span class="token operator">=</span> s <span class="token operator">+</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token comment">// 报错，不兼容的类型，不与下面那句等价</span></pre></td></tr><tr><td data-num="3"></td><td><pre>s <span class="token operator">+=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s <span class="token operator">+</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 这句才和上面那句等价</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="数据输入"><a class="anchor" href="#数据输入">#</a> 数据输入</h2><h3 id="scanner使用的基本步骤"><a class="anchor" href="#scanner使用的基本步骤">#</a> Scanner 使用的基本步骤</h3><ol><li>导包</li></ol><ul><li><code>import java.util.Scanner;</code></li><li>导包的动作必须出现在类定义的上面</li></ul><ol start="2"><li>创建对象<ul><li><code>Scanner sc = new Scanner(System.in);</code></li><li>sc 为变量名，可以更改</li></ul></li><li>接受数据<ul><li><code>int i = sc.nextInt()</code></li><li>数据类型和读入类型一一对应</li><li>int --- nextInt()</li><li>float --- nextFloat()</li><li>...</li></ul></li><li>判断数据<ul><li><code>sc.hasNextInt()</code></li><li>一一对应</li><li>int --- hasNextInt()</li><li>float --- hasNextFloat()</li></ul></li></ol><h2 id="数组"><a class="anchor" href="#数组">#</a> 数组</h2><h3 id="数组的定义格式"><a class="anchor" href="#数组的定义格式">#</a> 数组的定义格式</h3><ol><li>格式 1 (<strong>推荐</strong>)<ul><li>数据类型 [ ] 变量名；</li><li><code>int[] arr;</code></li><li>定义了一个 int 型的数组，数组名为 arr</li></ul></li><li>格式 2<ul><li>数据类型 变量名 [];</li><li><code>int arr[];</code></li><li>定义了一个 int 型的变量，变量名是 arr 数组</li></ul></li></ol><h3 id="数组初始化"><a class="anchor" href="#数组初始化">#</a> 数组初始化</h3><h4 id="动态初始化"><a class="anchor" href="#动态初始化">#</a> 动态初始化</h4><p>初始化时只指定数组长度，由系统分配初始值.</p><ul><li>格式：数据类型 [] 变量名 = new 数据类型 [数组长度]</li><li>范例: <code>int[] arr = new int[3];</code></li></ul><p>初始值:</p><ul><li>整数 0</li><li>浮点数 0.0</li><li>布尔值 false</li><li>字符 空字符</li><li>引用数据类型 <strong>null</strong></li></ul><p>####　静态初始化</p><p>初始化时指定每个元素的初始值，由系统决定长度</p><ol><li>格式<ul><li>数据类型 [] 变量名 = new 数据类型<span 数据1,数据2,...></span>；</li><li><code>int[] arr = new int[]&#123;1,2,3,...&#125;;</code></li></ul></li><li>简化格式<ul><li>数据类型 [] 变量名 = {数据 1, 数据 2,...};</li><li><code>int[] arr = &#123;1,2,3,...&#125;;</code></li></ul></li></ol><h3 id="内存分配"><a class="anchor" href="#内存分配">#</a> 内存分配</h3><p>栈内存 :</p><ul><li>存储局部变量</li><li>定义在方法中的变量</li><li>使用完毕立即消失</li></ul><p>堆内存:</p><ul><li>存储 new 出来的内容</li><li>实体、对象</li></ul><p>每一个 new 出来的东西都有地址值，使用完毕会在垃圾回收器空闲时被回收</p><p>数组名算是一个指针，多个数组名可以指向同一个数组的存储空间</p><h3 id="数组常见操作"><a class="anchor" href="#数组常见操作">#</a> 数组常见操作</h3><h4 id="获取数组元素数量"><a class="anchor" href="#获取数组元素数量">#</a> 获取数组元素数量</h4><p>格式：数组名.length;</p><p>范例: <code>arr.length</code></p><h2 id="方法"><a class="anchor" href="#方法">#</a> 方法</h2><h3 id="什么是方法"><a class="anchor" href="#什么是方法">#</a> 什么是方法</h3><ul><li>方法 (method) 是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集</li></ul><p>注意:</p><ul><li>方法必须先创建才可以使用，该过程称为方法定义</li><li>方法创建后并不是直接运行的，需要手动使用后才执行，该过程称为方法调用</li></ul><p><s>不就是函数吗 qwqq</s></p><h3 id="方法定义和调用"><a class="anchor" href="#方法定义和调用">#</a> 方法定义和调用</h3><h4 id="定义"><a class="anchor" href="#定义">#</a> 定义</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> 返回值类型 方法名<span class="token punctuation">(</span>参数<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    方法体<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span> 数据<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="调用"><a class="anchor" href="#调用">#</a> 调用</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>方法名<span class="token punctuation">(</span>参数<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="方法重载"><a class="anchor" href="#方法重载">#</a> 方法重载</h3><p>好东西ヾ (・ω・`) o</p><p>重载:</p><ul><li>多个方法在同一个类中</li><li>多个方法<strong>具有相同的方法名</strong></li><li>多个方法的参数不同，类型不同或数量不同</li></ul><p>特点:</p><ul><li>重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式</li><li>重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载</li></ul><h2 id="字符串"><a class="anchor" href="#字符串">#</a> 字符串</h2><h3 id="api"><a class="anchor" href="#api">#</a> API</h3><p>Application Programming Interface (应用程序编程接口)</p><p>利用帮助文档</p><h3 id="string"><a class="anchor" href="#string">#</a> String</h3><p>java 中所有双引号字符串都是 String 类的对象</p><p>特点:</p><ul><li>字符串不可变，它们的值在创建后不能修改</li><li>虽然 String 的值是不可变的，但是它们可以被共享</li><li>字符串效果相当于字符数组 (char []), 但是底层原理是字节数组 (byte [])</li></ul><p>构造方法:</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><code>public String()</code></td><td>创建一个空白字符对象</td></tr><tr><td><code>public String(char[] chs)</code></td><td>根据字符数组的内容，创建字符对象</td></tr><tr><td><code>public String(byte[] bys)</code></td><td>根据字节数组的内容，创建字符对象</td></tr><tr><td><code>String s = &quot;abc&quot;</code></td><td>直接赋值的方式创建字符对象</td></tr></tbody></table><p>推荐使用直接赋值的方式获得字符串对象</p><p>String 对象的特点:</p><ol><li>通过 new 创建的字符串对象每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同</li><li>以 &quot;&quot; 创建的字符串，只要字符序列相同 (顺序和大小写), 无论在程序中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护</li></ol><p>字符串的比较:</p><ol><li><p>使用 == 做比较</p><ul><li>基本类型：比较的是<strong>数据值</strong>是否相同</li><li>引用类型：比较的是<strong>地址值</strong>是否相同</li></ul></li><li><p>使用 equals ()</p><ul><li><code>public boolean equals(Object anObject)</code></li><li>返回一个 bool 值</li><li>s1.equals(s2);</li></ul></li></ol><p>字符串的遍历:</p><ol><li>获取字符<ul><li><code>public char str(int index)</code></li><li>返回索引处的 char 值</li></ul></li><li>获取长度<ul><li><code>public int length()</code></li><li>返回字符串长度</li></ul></li></ol><h3 id="stringbuilder"><a class="anchor" href="#stringbuilder">#</a> StringBuilder</h3><p>每次对字符串拼接时，都会构建一个新的 String 对象，既费时又浪费空间，StringBuilder 可以解决这个问题</p><p>概述:</p><p>StringBuilder 是一个可变的字符串类 (对象中的内容可变), 我们可以把它看成一个容器</p><p>构造方法:</p><ul><li>无参构造方法: <code>public StringBuilder();</code> , 创建一个空白字符对象</li><li>含参构造方法: <code>public StringBuilder(String str);</code> , 根据字符串的内容来创建可变字符对象</li></ul><p>添加方法:</p><ul><li><code>public StringBuidler append(任意类型)</code> , 添加数据并返回<strong>对象本身</strong></li><li>返回值为对象，所以可以实现下面这种链式编程<ul><li><code>sb.append(&quot;hello&quot;).append(&quot; world&quot;).append(&quot;!&quot;);</code></li></ul></li></ul><p>翻转方法:</p><ul><li><code>public StringBuilder reverse()</code> , 返回保存倒序的字符序列的对象本身</li><li>也可链式编程，<s> 但是翻转两次就没有意义了 qwqq</s></li></ul><h3 id="string和stringbuilder转换"><a class="anchor" href="#string和stringbuilder转换">#</a> String 和 StringBuilder 转换</h3><ol><li>String 转 StringBuilder<ul><li><code>public String toString()</code> ;</li><li>通过 toString () 可以将 String 转换为 StringBuilder</li></ul></li><li>StringBuilder 转 String<ul><li><code>public StringBuilder(String s);</code></li><li>通过构造方法将 String 转换为 StringBuilder</li></ul></li></ol><h2 id="集合基础"><a class="anchor" href="#集合基础">#</a> 集合基础</h2><p>集合类提供一种存储空间可变的存储模型</p><h3 id="arraylist"><a class="anchor" href="#arraylist">#</a> ArrayList</h3><ul><li>可调整大小的数组实现</li><li><code>&lt;E&gt;</code> 是一种特殊的数据类型，泛型<ul><li>在所有 <code>&lt;E&gt;</code> 的地方使用引用数据类型替换即可</li><li><code>ArrayList&lt;String&gt;;ArrayList&lt;int&gt;;</code></li></ul></li></ul><p>构造方法:</p><ul><li><code>public ArrayList()</code></li><li>创建一个空的集合对象，直接输出空集合会输出 <code>[]</code></li><li><code>ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;()</code> 或 <code>ArrayList&lt;String&gt; arr = new ArrayList&lt;&gt;()</code></li></ul><p>添加方法:</p><ul><li><code>public boolean add(E element);</code><ul><li>将指定的元素追加到此集合的末尾</li></ul></li><li><code>public void add(int Index,E element);</code><ul><li>在此集合中的指定位置插入指定的元素</li><li>指定位置变为指定元素，原来指定位置上的元素和指定位置之后的元素后移一位</li><li>指定位置最多只能到<strong>末尾</strong>，再往后便会越界</li></ul></li></ul><p>删除方法:</p><ul><li><code>public boolean remove(Object o);</code><ul><li>删除指定元素，返回删除是否成功</li><li>指定元素要与集合中的<strong>完全相同</strong>才会被删除，否则不能被删除</li></ul></li><li><code>public E remove(int index);</code><ul><li>删除指定索引处的元素，返回<strong>被删除的元素</strong></li></ul></li></ul><p>修改元素方法:</p><ul><li><code>public E set(int index,E element);</code><ul><li>修改指定索引处的元素，返回<strong>被修改的元素</strong></li></ul></li></ul><p>返回元素方法:</p><ul><li><code>public E get(int index);</code></li><li>返回指定索引处的元素</li></ul><p>返回元素个数方法:</p><ul><li><code>public int size()</code></li><li>返回集合中元素的个数</li></ul><h2 id="命令行传参"><a class="anchor" href="#命令行传参">#</a> 命令行传参</h2><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> a <span class="token operator">:</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 与 c 和 c++ 不同的是，传入参数直接就是命令后接的参数，没有源程序的信息</span></pre></td></tr></table></figure><h2 id="可变参数"><a class="anchor" href="#可变参数">#</a> 可变参数</h2><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            sum<span class="token operator">+=</span>num<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token comment">// 相当于传入一个数组</span></pre></td></tr></table></figure><h1 id="面向对象"><a class="anchor" href="#面向对象">#</a> 面向对象</h1><h2 id="类和对象"><a class="anchor" href="#类和对象">#</a> 类和对象</h2><p>什么是对象:</p><p>​	万物皆对象，客观存在的事物称为对象</p><p>什么是类:</p><p>​	类是对现实生活中一类具有<strong>共同属性</strong>和<strong>行为</strong>的事物的抽象</p><ul><li>特点:<ul><li>类是对象的数据类型</li><li>类是具有相同属性和行为的一组对象的集合</li></ul></li></ul><p>什么是属性:</p><p>​	对象具有的各种特征，每个对象的每个属性都有特定的值</p><p>什么是对象的行为:</p><p>​	对象能进行的操作</p><p>类和对象的关系:</p><p>​	类：一类事物的抽象</p><p>​	对象：是具体存在的某个事物 (实体)</p><p><mark>类是 java 程序的基本组成单位</mark></p><h4 id="类的组成"><a class="anchor" href="#类的组成">#</a> 类的组成</h4><p>属性：在类中通过成员变量来体现</p><p>行为：在类中通过方法来体现</p><h4 id="定义-2"><a class="anchor" href="#定义-2">#</a> 定义</h4><ul><li>步骤<ul><li>定义类</li><li>编写类的成员变量</li><li>编写类的成员方法</li></ul></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> myClass<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 成员变量</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 成员方法</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="使用"><a class="anchor" href="#使用">#</a> 使用</h4><ul><li>步骤<ul><li>创建<strong>对象</strong><ul><li>类名 对象名 = new 类名 ();</li><li><code>myClass test = new myClass();</code></li></ul></li><li>使用对象<ol><li>使用成员变量<ul><li>对象名。变量</li><li><code>test.a</code></li></ul></li><li>使用成员方法<ul><li>对象名。方法名 ()</li><li><code>test.f()</code></li></ul></li></ol></li></ul></li></ul><h3 id="成员变量和局部变量"><a class="anchor" href="#成员变量和局部变量">#</a> 成员变量和局部变量</h3><table><thead><tr><th style="text-align:center">区别</th><th style="text-align:center">成员变量</th><th style="text-align:center">局部变量</th></tr></thead><tbody><tr><td style="text-align:center">类中位置不同</td><td style="text-align:center">类中方法外</td><td style="text-align:center">方法内或方法声明上</td></tr><tr><td style="text-align:center">内存中位置不同</td><td style="text-align:center">堆</td><td style="text-align:center">栈</td></tr><tr><td style="text-align:center">生命周期不同</td><td style="text-align:center">随对象存在而存在，随对象的消失而消失</td><td style="text-align:center">随方法的调用而存在，随方法调用的结束而消失</td></tr><tr><td style="text-align:center">初始化的值不同</td><td style="text-align:center">有初始化的默认值</td><td style="text-align:center">没有默认的初始化值，必须先定义，赋值，才能使用</td></tr></tbody></table><h3 id="封装"><a class="anchor" href="#封装">#</a> 封装</h3><p>封装是面向对象的三大特征之一</p><p>是面向对象对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作的</p><p>将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息<br>的操作和访问成员变量 private，提供对应的 getXxx ()/setXxx () 方法</p><p>封装好处:</p><ul><li>通过方法来控制成员变量的操作，提高了代码的安全性</li><li>把代码用方法进行封装，提高了代码的复用性</li></ul><h4 id="private关键字"><a class="anchor" href="#private关键字">#</a> private 关键字</h4><ul><li>是一个权限修饰符</li><li>可以修饰成员</li><li>作用是保护成员不被别的类使用，被 private 修饰的成员只在本类中才能访问</li></ul><p>对 private 修饰的成员变量，如果需要被其他类使用，应当提供相应的操作</p><ul><li>提供 &quot;get 变量名 ()&quot; 方法返回成员值，方法用 public 修饰</li><li>提供 &quot;set 变量名 ()&quot; 方法设置成员变量的值，方法用 public 修饰</li></ul><h4 id="this关键字"><a class="anchor" href="#this关键字">#</a> this 关键字</h4><ol><li>this 修饰的变量用于指代成员变量<ul><li>方法的形参如果和成员变量同名时<ul><li>带 this 修饰的是成员变量</li><li>不带 this 修饰的是形参</li></ul></li></ul></li><li>在解决局部变量隐藏成员变量时使用</li><li>this 代表所在类的对象引用<ul><li>哪个对象被调用，this 就代表哪个对象</li><li>this 可以看作指向<strong>与该对象名指向地址</strong>相同的一个指针</li></ul></li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> myClass<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    </pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setN</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="构造方法"><a class="anchor" href="#构造方法">#</a> 构造方法</h3><p>构造方法是一种特殊的方法</p><p>作用：创建对象</p><p>功能：完成对象数据的初始化</p><p>格式:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> myClass<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token function">myClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 这里可对类中的参数进行初始化</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>注意事项:</p><ol><li>构造方法的创建<ul><li>如果没有定义构造方法，系统会给出一个<strong>默认</strong>的<strong>无参数</strong>构造方法</li><li>如果定义了构造方法，系统将不再提供默认的构造方法</li></ul></li><li>构造方法的重载<ul><li>如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法</li></ul></li><li>推荐使用方式<ul><li>无论是否使用，都手写一个无参数构造方法</li></ul></li></ol><h4 id="标准类制作"><a class="anchor" href="#标准类制作">#</a> 标准类制作</h4><ol><li>成员变量<ul><li>使用<strong> private</strong> 修饰</li></ul></li><li>构造方法<ul><li>提供一个无参构造方法</li><li>提供一个带多个参数的构造方法</li></ul></li><li>成员方法<ul><li>提供每一个成员变量对应的 setXxx ()/getXxx ()</li><li>提供一个显示对象信息的 show ()</li></ul></li><li>创建对象并为其成员变量赋值的两种方式<ul><li>无参构造方法创建对象后使用 setXxx () 赋值</li><li>使用带参构造方法直接创建带有属性值的对象</li></ul></li></ol><h2 id="继承"><a class="anchor" href="#继承">#</a> 继承</h2><h2 id="多态"><a class="anchor" href="#多态">#</a> 多态</h2><h3 id="instanceof"><a class="anchor" href="#instanceof">#</a> instanceof</h3><p>判断一个对象是什么类型，类似于 c++ 的 <code>dynamic_cast</code></p><p>它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型</p><p><mark>若右边类型为左边对象的<strong>祖宗类</strong></mark>，则返回 true，否则返回 false</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//Object > Person > Student</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">Object</span> studentObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student <span class="token keyword">instanceof</span> <span class="token class-name">Student</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>studentObject <span class="token keyword">instanceof</span> <span class="token class-name">Student</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>studentObject <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>studentObject <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">//out</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">//true</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">//true</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">//true</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">//true</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">//true</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">//true</span></pre></td></tr></table></figure><p><strong>与指向对象指针的类型无关，只与指向对象的类型有关</strong></p><h2 id="单例模式"><a class="anchor" href="#单例模式">#</a> 单例模式</h2><p>单例模式又叫做 Singleton 模式，指的是一个类，在一个 JVM 里，只有一个实例存在。</p><h3 id="饿汉式单例模式"><a class="anchor" href="#饿汉式单例模式">#</a> 饿汉式单例模式</h3><p>通过私有化其构造方法，使得外部无法通过 new 得到新的实例。</p><p>提供一个 public static 的 getInstance 方法，外部调用者通过该方法获取对象，而且每一次都是获取同一个对象。 从而达到单例的目的。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GiantDragon</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 私有化构造方法使得该类无法在外部通过 new 进行实例化</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">GiantDragon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>         </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> </pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个</span></pre></td></tr><tr><td data-num="9"></td><td><pre> </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">GiantDragon</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GiantDragon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>     </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">//public static 方法，提供给调用者获取 12 行定义的对象</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">GiantDragon</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>     </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="懒汉式单例模式"><a class="anchor" href="#懒汉式单例模式">#</a> 懒汉式单例模式</h3><p><strong>懒汉式</strong>单例模式与<strong>饿汉式</strong>单例模式不同，只有在调用 getInstance 的时候，才会创建实例</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GiantDragon</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 私有化构造方法使得该类无法在外部通过 new 进行实例化</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">GiantDragon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       </pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 准备一个类属性，用于指向一个实例化对象，但是暂时指向 null</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">GiantDragon</span> instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">//public static 方法，返回实例对象</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">GiantDragon</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 第一次访问的时候，发现 instance 没有指向任何对象，这时实例化一个对象</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token operator">==</span>instance<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GiantDragon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 返回 instance 指向的对象</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>      </pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="什么时候使用饿汉式什么时候使用懒汉式"><a class="anchor" href="#什么时候使用饿汉式什么时候使用懒汉式">#</a> 什么时候使用饿汉式，什么时候使用懒汉式</h3><p><strong>饿汉式</strong>是立即加载的方式，无论是否会用到这个对象，都会加载。<br>如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。</p><p><strong>懒汉式</strong>，是延迟加载的方式，只有使用的时候才会加载。 并且有线程安全的考量 (鉴于同学们学习的进度，暂时不对线程的章节做展开)。<br>使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。</p><p>看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式</p><h3 id="单例模式三元素"><a class="anchor" href="#单例模式三元素">#</a> 单例模式三元素</h3><ol><li>构造方法私有化</li><li>静态属性指向实例</li><li>public static 的 getInstance 方法，返回第二步的静态属性</li></ol><h2 id="枚举"><a class="anchor" href="#枚举">#</a> 枚举</h2><p>枚举 enum 是一种特殊的类 (还是类)，使用枚举可以很方便的定义常量<br>比如设计一个枚举类型 季节，里面有 4 种常量</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Season</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	SPRING<span class="token punctuation">,</span>SUMMER<span class="token punctuation">,</span>AUTUMN<span class="token punctuation">,</span>WINTER</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>** 注：** 因为是常量，所以一般都是全大写</p><h2 id="接口与继承"><a class="anchor" href="#接口与继承">#</a> 接口与继承</h2><p>接口（英文：Interface），在 JAVA 编程语言中是一个抽象类型，是抽象方法的集合，接口通常以 interface 来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p><p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><h3 id="接口与类相似点"><a class="anchor" href="#接口与类相似点">#</a> 接口与类相似点</h3><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><h3 id="接口与类的区别"><a class="anchor" href="#接口与类的区别">#</a> 接口与类的区别</h3><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了 static 和 final 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul><h3 id="接口特性"><a class="anchor" href="#接口特性">#</a> 接口特性</h3><ul><li>接口中每一个方法也是隐式抽象的，接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li></ul><h3 id="抽象类和接口的区别"><a class="anchor" href="#抽象类和接口的区别">#</a> 抽象类和接口的区别</h3><ul><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li><li>接口中不能含有静态代码块以及静态方法 (用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><blockquote><p><strong>注</strong>：JDK 1.8 以后，接口里可以有静态方法和方法体了。</p></blockquote><p>使用</p><pre><code>[可见度] interface 接口名称 [extends 其他的接口名] &#123;
        // 声明变量
        // 抽象方法
&#125;
</code></pre><h3 id="隐藏"><a class="anchor" href="#隐藏">#</a> 隐藏</h3><p>与重写类似，方法的<strong>重写是</strong>子类覆盖父类的<strong>对象方法</strong></p><p><strong>隐藏</strong>，就是子类覆盖父类的<strong>类方法</strong></p><h3 id="super关键字"><a class="anchor" href="#super关键字">#</a> super 关键字</h3><p>使用关键字<strong> super</strong> 显式调用父类方法</p><h3 id="object类"><a class="anchor" href="#object类">#</a> object 类</h3><p>Object 类是所有类的父类</p><p>声明一个类的时候，默认是继承了 Object<br>public class Hero <strong>extends Object</strong></p><h4 id="tostring"><a class="anchor" href="#tostring">#</a> toString</h4><p>Object 类提供一个 toString 方法，所以所有的类都有 toString 方法<br>toString () 的意思是返回当前对象的<strong>字符串表达</strong><br>通过 System.out.println 打印对象就是打印该对象的 toString () 返回值</p><p>####　finalize()</p><p>当一个对象没有任何引用指向的时候，它就满足垃圾回收的条件</p><p>当它被垃圾回收的时候，它的 finalize () 方法就会被调用。</p><p>finalize () 不是开发人员主动调用的方法，而是由虚拟机 JVM 调用的。</p><h4 id="equals"><a class="anchor" href="#equals">#</a> equals()</h4><p>equals () 用于判断两个对象的内容是否相同</p><h4><a class="anchor" href="#">#</a> ==</h4><p>这不是 Object 的方法，但是用于判断两个对象是否相同<br><strong>更准确的讲</strong>，用于判断两个引用，是否<strong>指向了同一个对象</strong></p><h3 id="final"><a class="anchor" href="#final">#</a> final</h3><p>final 修饰类，方法，基本类型变量，引用的时候分别有不同的意思。</p><h4 id="类"><a class="anchor" href="#类">#</a> 类</h4><p>当类被修饰成 final 的时候，表示该类不能够被继承<br>其子类会出现编译错误</p><h4 id="方法-2"><a class="anchor" href="#方法-2">#</a> 方法</h4><p>当类的方法被修饰成 final 时，表示在子类中该方法不可被重写</p><h4 id="final修饰基本类型变量"><a class="anchor" href="#final修饰基本类型变量">#</a> final 修饰基本类型变量</h4><p>final 修饰基本类型变量，表示该变量只有一次赋值机会</p><h4 id="final修饰引用"><a class="anchor" href="#final修饰引用">#</a> final 修饰引用</h4><p>表示该引用只有<strong> 1</strong> 次指向对象的机会</p><h4 id="常量"><a class="anchor" href="#常量">#</a> 常量</h4><p>常量指的是可以公开，直接访问，不会变化的值</p><p><code>public static final int N = 6;</code></p><h3 id="抽象类"><a class="anchor" href="#抽象类">#</a> 抽象类</h3><p>在类中声明一个方法，这个方法没有实现体，是一个 “空” 方法</p><p>这样的方法就叫抽象方法，使用修饰符 “abstract&quot;</p><p>当一个类有抽象方法的时候，该类必须被声明为<strong>抽象类</strong></p><p>Hero 类可以在不提供抽象方法的前提下，声明为抽象类<br>一旦一个类被声明为抽象类，就不能够被直接实例化</p><h3 id="内部类"><a class="anchor" href="#内部类">#</a> 内部类</h3><h4 id="非静态内部类"><a class="anchor" href="#非静态内部类">#</a> 非静态内部类</h4><p>非静态内部类可以直接在一个类里面定义</p><p>直接实例化内部类语法:<strong>new 外部类 ().new 内部类 ()</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> <span class="token namespace">charactor</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hero</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span> <span class="token comment">// 姓名</span></pre></td></tr><tr><td data-num="5"></td><td><pre> </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">float</span> hp<span class="token punctuation">;</span> <span class="token comment">// 血量</span></pre></td></tr><tr><td data-num="7"></td><td><pre> </pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">float</span> armor<span class="token punctuation">;</span> <span class="token comment">// 护甲</span></pre></td></tr><tr><td data-num="9"></td><td><pre> </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">int</span> moveSpeed<span class="token punctuation">;</span> <span class="token comment">// 移动速度</span></pre></td></tr><tr><td data-num="11"></td><td><pre> </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 非静态内部类，只有一个外部类对象存在的时候，才有意义</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 战斗成绩只有在一个英雄对象存在的时候才有意义</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">class</span> <span class="token class-name">BattleScore</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">int</span> kill<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">int</span> die<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">int</span> assit<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> </pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">legendary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>kill <span class="token operator">>=</span> <span class="token number">8</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">"超神！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token keyword">else</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">"尚未超神！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre> </pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token class-name">Hero</span> garen <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        garen<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"盖伦"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token comment">// 实例化内部类</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token comment">// BattleScore 对象只有在一个英雄对象存在的时候才有意义</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token comment">// 所以其实例化必须建立在一个外部类对象的基础之上</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token class-name">BattleScore</span> score <span class="token operator">=</span> garen<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">BattleScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        score<span class="token punctuation">.</span>kill <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        score<span class="token punctuation">.</span><span class="token function">legendary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre> </pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>非静态内部类，是可以直接访问外部类的 private 实例属性的</strong></p><h4 id="静态内部类"><a class="anchor" href="#静态内部类">#</a> 静态内部类</h4><p>与非静态内部类不同，<strong>静态内部类</strong>的实例化 <strong>不需要一个外部类的实例为基础</strong>，可以直接实例化</p><p>语法：<strong>new 外部类。静态内部类 ();</strong><br>因为没有一个外部类的实例，所以在静态内部类里面<strong>不可以访问外部类的实例属性和方法</strong><br>除了可以访问外部类的<strong>私有静态成员外</strong>，静态内部类和普通类没什么大的区别</p><h4 id="匿名类"><a class="anchor" href="#匿名类">#</a> 匿名类</h4><p>匿名类指的是在<strong>声明一个类的同时实例化它</strong>，使代码更加简洁精练<br>通常情况下，要使用一个接口或者抽象类，都必须创建一个子类</p><p>有的时候，为了快速使用，直接<strong>实例化一个抽象类</strong>，并 “<strong>当场</strong>” 实现其抽象方法。<br>既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。<br>这样的类，叫做匿名类</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> <span class="token namespace">charactor</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Hero</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">String</span> name<span class="token punctuation">;</span> <span class="token comment">// 姓名</span></pre></td></tr><tr><td data-num="5"></td><td><pre>          </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">float</span> hp<span class="token punctuation">;</span> <span class="token comment">// 血量</span></pre></td></tr><tr><td data-num="7"></td><td><pre>          </pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">float</span> armor<span class="token punctuation">;</span> <span class="token comment">// 护甲</span></pre></td></tr><tr><td data-num="9"></td><td><pre>          </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">int</span> moveSpeed<span class="token punctuation">;</span> <span class="token comment">// 移动速度</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">attack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      </pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>          </pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token class-name">ADHero</span> adh<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ADHero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">// 通过打印 adh，可以看到 adh 这个对象属于 ADHero 类</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        adh<span class="token punctuation">.</span><span class="token function">attack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>adh<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>          </pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token class-name">Hero</span> h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token comment">// 当场实现 attack 方法</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">attack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"新的进攻手段"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        h<span class="token punctuation">.</span><span class="token function">attack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token comment">// 通过打印 h，可以看到 h 这个对象属于 Hero$1 这么一个系统自动分配的类名</span></pre></td></tr><tr><td data-num="29"></td><td><pre>          </pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>      </pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在匿名类中使用外部的局部变量:</p><p>在匿名类中使用外部的局部变量，外部的局部变量必须修饰为 final</p><p>为什么要声明为 final，其机制比较复杂，请参考第二个 Hero 代码中的解释</p><p><strong>注：<strong>在 jdk8 中，已经不需要强制修饰成 final 了，如果没有写 final，不会报错，因为编译器</strong>偷偷的</strong>帮你加上了看不见的 final</p><h4 id="本地类"><a class="anchor" href="#本地类">#</a> 本地类</h4><p>本地类可以理解为有名字的匿名类<br>内部类与匿名类不一样的是，内部类必须声明在成员的位置，即与属性和方法平等的位置。<br>本地类和匿名类一样，直接声明在代码块里面，可以是主方法，for 循环里等等地方</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> <span class="token namespace">charactor</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Hero</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">String</span> name<span class="token punctuation">;</span> <span class="token comment">// 姓名</span></pre></td></tr><tr><td data-num="5"></td><td><pre>          </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">float</span> hp<span class="token punctuation">;</span> <span class="token comment">// 血量</span></pre></td></tr><tr><td data-num="7"></td><td><pre>          </pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">float</span> armor<span class="token punctuation">;</span> <span class="token comment">// 护甲</span></pre></td></tr><tr><td data-num="9"></td><td><pre>          </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">int</span> moveSpeed<span class="token punctuation">;</span> <span class="token comment">// 移动速度</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">attack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      </pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>          </pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 与匿名类的区别在于，本地类有了自定义的类名</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">class</span> <span class="token class-name">SomeHero</span> <span class="token keyword">extends</span> <span class="token class-name">Hero</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">attack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> name<span class="token operator">+</span> <span class="token string">" 新的进攻手段"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>         </pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token class-name">SomeHero</span> h  <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">SomeHero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        h<span class="token punctuation">.</span>name <span class="token operator">=</span><span class="token string">"地卜师"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        h<span class="token punctuation">.</span><span class="token function">attack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>      </pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="默认方法"><a class="anchor" href="#默认方法">#</a> 默认方法</h3><p>默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法</p><p>通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2021-07-26 10:51:47" itemprop="dateModified" datetime="2021-07-26T10:51:47+08:00">2021-07-26</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Ling yunchi 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Ling yunchi 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Ling yunchi 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Ling yunchi <i class="ic i-at"><em>@</em></i>QWQ</li><li class="link"><strong>本文链接：</strong> <a href="https://ling-yunchi.github.io/2021/01/21/java%E9%9A%8F%E6%89%8B%E7%AC%94%E8%AE%B0/" title="java随手笔记">https://ling-yunchi.github.io/2021/01/21/java随手笔记/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/01/20/%E5%AF%92%E5%81%87%E5%86%AC%E4%BB%A4%E8%90%A5DAY3/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclxp31goj20zk0m8qv5.jpg" title="寒假冬令营DAY3"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>寒假冬令营DAY3</h3></a></div><div class="item right"><a href="/2021/01/21/%E5%AF%92%E5%81%87%E5%86%AC%E4%BB%A4%E8%90%A5DAY4/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipey0a334j20zk0m8qpt.jpg" title="寒假冬令营DAY4"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>寒假冬令营DAY4</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java"><span class="toc-number">1.</span> <span class="toc-text">JAVA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%89%88%E6%9C%AC"><span class="toc-number">1.1.</span> <span class="toc-text">三大版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jdk-jre-jvm"><span class="toc-number">1.2.</span> <span class="toc-text">JDK、JRE、JVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text">Java 程序运行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#javadoc"><span class="toc-number">1.4.</span> <span class="toc-text">JavaDoc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.5.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.6.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">自动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6"><span class="toc-number">1.6.2.</span> <span class="toc-text">强制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.</span> <span class="toc-text">字符串的 + 操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5"><span class="toc-number">1.9.</span> <span class="toc-text">数据输入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#scanner%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.9.1.</span> <span class="toc-text">Scanner 使用的基本步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.10.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.10.1.</span> <span class="toc-text">数组的定义格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.10.2.</span> <span class="toc-text">数组初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">动态初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.10.3.</span> <span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="toc-number">1.10.4.</span> <span class="toc-text">数组常见操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E6%95%B0%E9%87%8F"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">获取数组元素数量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95"><span class="toc-number">1.11.1.</span> <span class="toc-text">什么是方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8"><span class="toc-number">1.11.2.</span> <span class="toc-text">方法定义和调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8"><span class="toc-number">1.11.2.2.</span> <span class="toc-text">调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">1.11.3.</span> <span class="toc-text">方法重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.12.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#api"><span class="toc-number">1.12.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string"><span class="toc-number">1.12.2.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stringbuilder"><span class="toc-number">1.12.3.</span> <span class="toc-text">StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%92%8Cstringbuilder%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.12.4.</span> <span class="toc-text">String 和 StringBuilder 转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80"><span class="toc-number">1.13.</span> <span class="toc-text">集合基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arraylist"><span class="toc-number">1.13.1.</span> <span class="toc-text">ArrayList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E5%8F%82"><span class="toc-number">1.14.</span> <span class="toc-text">命令行传参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.15.</span> <span class="toc-text">可变参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">类的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">2.1.0.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.0.3.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.1.</span> <span class="toc-text">成员变量和局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">2.1.2.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#private%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">private 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">this 关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.3.</span> <span class="toc-text">构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%B1%BB%E5%88%B6%E4%BD%9C"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">标准类制作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.2.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">2.3.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof"><span class="toc-number">2.3.1.</span> <span class="toc-text">instanceof</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.1.</span> <span class="toc-text">饿汉式单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.2.</span> <span class="toc-text">懒汉式单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E9%A5%BF%E6%B1%89%E5%BC%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">2.4.3.</span> <span class="toc-text">什么时候使用饿汉式，什么时候使用懒汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%89%E5%85%83%E7%B4%A0"><span class="toc-number">2.4.4.</span> <span class="toc-text">单例模式三元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.5.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">2.6.</span> <span class="toc-text">接口与继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E7%9B%B8%E4%BC%BC%E7%82%B9"><span class="toc-number">2.6.1.</span> <span class="toc-text">接口与类相似点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.6.2.</span> <span class="toc-text">接口与类的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%89%B9%E6%80%A7"><span class="toc-number">2.6.3.</span> <span class="toc-text">接口特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.6.4.</span> <span class="toc-text">抽象类和接口的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F"><span class="toc-number">2.6.5.</span> <span class="toc-text">隐藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.6.6.</span> <span class="toc-text">super 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#object%E7%B1%BB"><span class="toc-number">2.6.7.</span> <span class="toc-text">object 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tostring"><span class="toc-number">2.6.7.1.</span> <span class="toc-text">toString</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#equals"><span class="toc-number">2.6.7.2.</span> <span class="toc-text">equals()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.6.7.3.</span> <span class="toc-text">&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">2.6.8.</span> <span class="toc-text">final</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">2.6.8.1.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-2"><span class="toc-number">2.6.8.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E4%BF%AE%E9%A5%B0%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">2.6.8.3.</span> <span class="toc-text">final 修饰基本类型变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E4%BF%AE%E9%A5%B0%E5%BC%95%E7%94%A8"><span class="toc-number">2.6.8.4.</span> <span class="toc-text">final 修饰引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">2.6.8.5.</span> <span class="toc-text">常量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">2.6.9.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.6.10.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.6.10.1.</span> <span class="toc-text">非静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.6.10.2.</span> <span class="toc-text">静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="toc-number">2.6.10.3.</span> <span class="toc-text">匿名类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%B1%BB"><span class="toc-number">2.6.10.4.</span> <span class="toc-text">本地类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.11.</span> <span class="toc-text">默认方法</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Ling yunchi" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Ling yunchi</p><div class="description" itemprop="description">qwqqqq</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">39</span> <span class="name">文章</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpbmcteXVuY2hp" title="https:&#x2F;&#x2F;github.com&#x2F;Ling-yunchi"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/01/20/%E5%AF%92%E5%81%87%E5%86%AC%E4%BB%A4%E8%90%A5DAY3/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/01/21/%E5%AF%92%E5%81%87%E5%86%AC%E4%BB%A4%E8%90%A5DAY4/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Ling yunchi @ Ling Yunchi</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/01/21/java随手笔记/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->