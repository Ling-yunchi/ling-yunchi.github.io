<!-- build time:Mon Aug 09 2021 22:03:48 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="QWQ" href="https://ling-yunchi.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="QWQ" href="https://ling-yunchi.github.io/atom.xml"><link rel="alternate" type="application/json" title="QWQ" href="https://ling-yunchi.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://ling-yunchi.github.io/2021/08/02/javaWeb/"><title>javaWeb | Ling Yunchi = QWQ</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">javaWeb</h1><div class="meta"><span class="item" title="创建时间：2021-08-02 07:46:15"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-08-02T07:46:15+08:00">2021-08-02</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Ling Yunchi</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipesx5fdwj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeyhsblkj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipey84bjtj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeu1usa7j20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giciusoyjnj219g0u0x56.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicli3sbvtj20zk0m8x6p.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://ling-yunchi.github.io/2021/08/02/javaWeb/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Ling yunchi"><meta itemprop="description" content=", qwqqqq"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="QWQ"></span><div class="body md" itemprop="articleBody"><h1 id="javaWeb"><a href="#javaWeb" class="headerlink" title="javaWeb"></a>javaWeb</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>web开发:</p><ul><li>静态网页<ul><li>html,css<ul><li>提供给所有人看的数据始终不会发生变化!</li></ul></li><li>动态web<ul><li>淘宝，几乎是所有的网站;</li><li>提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同!</li><li>技术栈:Servlet/JSP，ASP，PHP</li></ul></li></ul></li></ul><p>在Java中，动态web资源开发的技术统称为JavaWeb;</p><h2 id="静态web"><a href="#静态web" class="headerlink" title="静态web"></a>静态web</h2><ul><li>静态web存在的缺点<ul><li>Web页面无法动态更新，所有用户看到都是同一个页面<ul><li>轮播图，点击特效:伪动态</li><li>JavaScript [实际开发中，它用的最多]</li><li>VBScript</li></ul></li><li>它无法和数据库交互(数据无法持久化)</li></ul></li></ul><h2 id="动态web"><a href="#动态web" class="headerlink" title="动态web"></a>动态web</h2><p>显示效果因人而异</p><ul><li>缺点:<ul><li>加入服务器的动态web资源出现了错误，我们需要重新编写我们的后台程序,重新发布;</li><li>停机维护</li></ul></li><li>优点:<ul><li>Web页面可以动态更新，所有用户看到都不是同一个页面</li><li>它可以与数据库交互</li></ul></li></ul><h2 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h2><ul><li>ASP:<ul><li>微软:国内最早流行的就是ASP;</li><li>在HTML中嵌入了VB的脚本，ASP + COM;</li><li>在ASP开发中，基本一个页面有几千行业务代码</li><li>维护成本高</li></ul></li><li>PHP<ul><li>PHP开发速度块,功能强大,跨平台,代码简单</li><li>无法承载大访问量的情况</li></ul></li><li><strong>JSP/Servlet</strong><ul><li>sun公司主推的B/S架构<ul><li>B/S浏览和服务器</li><li>C/S客户端和服务器</li></ul></li><li>基于java语言</li><li>可以承载三高(高性能高可用高并发)问题带来的影响</li></ul></li></ul><p><strong>服务器是一种被动响应,用来处理用用户的一些请求和给用户一些响应信息;</strong></p><ul><li>IIS<ul><li>微软的自带服务器</li></ul></li><li><strong>Tomcat</strong><ul><li>Tomcat服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP程序的首选。</li><li>Tomcat实际上运行SP页面和Servlet。</li></ul></li></ul><h2 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h2><p><strong>http:</strong></p><p>超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。</p><p><strong>https:</strong></p><p>HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性 。HTTPS 在HTTP 的基础下加入<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9TU0wvMzIwNzc4">SSL</span>，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 <span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9UQ1AvMzMwMTI=">TCP</span> 之间）。这个系统提供了身份验证与加密通讯方法。它被广泛用于万维网上安全敏感的通讯，例如交易支付等方面 。</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>管理java项目依赖工具</p><img data-src="image-20210802112131445.png" alt="image-20210802112131445" style="zoom:67%"><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><ul><li>Servlet就是sun公司开发动态web的一门技术</li><li>Sun在这些API中提供一个接口叫做: Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤:<ul><li>编写一个类，实现Servlet接口</li><li>把开发好的Java类部署到web服务器中。</li></ul></li><li>把实现了Servlet接口的Java程序叫做，Servlet</li></ul><p>sun公司给了两个servlet的默认实现类:<code>HttpServlet,GenericServlet</code></p><h3 id="HelloServlet"><a href="#HelloServlet" class="headerlink" title="HelloServlet"></a>HelloServlet</h3><ul><li><p>引入依赖</p><pre><code class="xml">  &lt;dependencies&gt;
      &lt;!-- tomcat 8 --&gt;
&lt;!--        &lt;dependency&gt;--&gt;
&lt;!--            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;--&gt;
&lt;!--            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;--&gt;
&lt;!--            &lt;version&gt;4.0.1&lt;/version&gt;--&gt;
&lt;!--        &lt;/dependency&gt;--&gt;
&lt;!--        &lt;dependency&gt;--&gt;
&lt;!--            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;--&gt;
&lt;!--            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;--&gt;
&lt;!--            &lt;version&gt;2.2&lt;/version&gt;--&gt;
&lt;!--        &lt;/dependency&gt;--&gt;
      &lt;!-- tomcat 10 --&gt;
      &lt;!-- 因为我使用的tomcat版本为10.0.2,所以之前访问时报错,原因是因为tomcat10将依赖的包改为了jakarta.servlet下的包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;5.0.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jakarta.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;jakarta.servlet.jsp-api&lt;/artifactId&gt;
            &lt;version&gt;3.0.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre></li><li><p>编写一个类,继承HttpServlet类</p></li><li><p>重写方法</p><pre><code class="java">public class HelloServlet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        PrintWriter writer = resp.getWriter();
        writer.println(&quot;Hello Servlet&quot;);
        System.out.println(&quot;Hello Servlet&quot;);
    &#125;

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        super.doPost(req, resp);
    &#125;
&#125;
</code></pre></li><li><p>编写servlet的映射<br>我们写的是Java程序,但浏览器访问的是web服务器,所有我们需要在web服务器中注册servlet,并给它一个可以使用浏览器访问的路径</p><pre><code class="xml">&lt;!-- web.xml --&gt;
&lt;!-- 注册servlet --&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.wang.servlet.HelloServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;!-- servlet的请求路径 --&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre></li><li><p>配置tomcat<br><img data-src="image-20210802165454434.png" alt="image-20210802165454434"></p></li><li><p>访问<code>localhost:8080/hello</code></p></li></ul><h3 id="Servlet原理"><a href="#Servlet原理" class="headerlink" title="Servlet原理"></a>Servlet原理</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2FuZ2ppbWluZy9wLzEwMzYwMzI3Lmh0bWw=">参考博客</span></p><p><img data-src="1066923-20190210235114200-2361046.png" alt="img"></p><ol><li>浏览器向服务器发出GET请求(请求服务器ServletA)</li><li>服务器上的容器逻辑接收到该url,根据该url判断为Servlet请求，此时容器逻辑将产生两个对象：请求对象(HttpServletRequest)和响应对象(HttpServletResponce)</li><li>容器逻辑根据url找到目标Servlet(本示例目标Servlet为ServletA),且创建一个线程A</li><li>容器逻辑将刚才创建的请求对象和响应对象传递给线程A</li><li>容器逻辑调用Servlet的service()方法</li><li>service()方法根据请求类型(本示例为GET请求)调用doGet()(本示例调用doGet())或doPost()方法</li><li>doGet()执行完后，将结果返回给容器逻辑</li><li>线程A被销毁或被放在线程池中</li></ol><p><strong>servlet就是一个处理请求和返回结果的处理器</strong></p><p>Servlet在JavaWeb中，扮演两个角色：页面角色和控制器角色。</p><h3 id="Mapping问题"><a href="#Mapping问题" class="headerlink" title="Mapping问题"></a>Mapping问题</h3><ol><li><p>一个Servlet可以指定一个映射路径</p><pre><code class="xml">&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre></li><li><p>一个Servlet可以指定多个映射路径</p><pre><code class="xml">  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello1&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello3&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello4&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre></li><li><p>一个Servlet可以指定通用映射路径</p><pre><code class="xml">  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;
    &lt;!-- 使用通配符* --&gt;
  &lt;/servlet-mapping&gt;
</code></pre></li><li><p>可以指定默认映射路径</p><pre><code class="xml">  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre></li><li><p>指定一些后缀或者前缀</p><pre><code class="xml">  &lt;!-- 可以自定义后缀实现请求映射
       *前面不能加项目映射的路径 
       --&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre></li><li><p>优先级问题<br>指定了固有的映射路径优先级最高,如果找不到才会走默认的处理请求</p></li></ol><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>web容器在启动时,会为每个web<strong>程序</strong>都创建一个对应的ServletContext对象,它代表了当前的web应用;</p><p><strong>context:上下文</strong></p><p><strong>应用:</strong></p><ul><li><p>共享数据</p><ul><li><p>多个servlet程序中的数据共用一个ServletContext对象</p></li><li><p>可以在一个Servlet中在ServletContext对象中添加信息,在另一个Servlet中去取出ServletContext对象中的信息</p><pre><code class="java">//servletA:
ServletContext context = this.getServletContext();  //获取ServletContext对象
context.setAttribute(&quot;name&quot;,new String(&quot;qwq&quot;)); //添加信息

//servletB:
ServletContext context = this.getServletContext();  //获取ServletContext对象
String name = (String) context.getAttribute(&quot;name&quot;); //获取信息
</code></pre></li></ul></li><li><p>设置程序初始化参数</p><ul><li><p>web.xml</p><pre><code class="xml">  &lt;context-param&gt;
    &lt;param-name&gt;url&lt;/param-name&gt;
    &lt;param-value&gt;jdbc:mysql://localhost:8080&lt;/param-value&gt;
  &lt;/context-param&gt;
</code></pre></li><li><p>servlet.java</p><pre><code class="java">ServletContext context = this.getServletContext();
String url = context.getInitParameter(&quot;url&quot;);//获取参数
</code></pre></li></ul></li><li><p>请求转发</p><pre><code class="java">public class DispatchServlet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        ServletContext context = this.getServletContext();
        RequestDispatcher dispatcher = context.getRequestDispatcher(&quot;/hello&quot;);//参数为转发的地址路径
        dispatcher.forward(req, resp);   //将req与resp转发,起到一个中转站的作用
    &#125;
&#125;
</code></pre><ul><li>转发与重定向不同<ul><li>转发的路径不会改变,是服务器内部的操作</li><li>重定向是将请求的路径改变,是客户端操作的改变</li></ul></li></ul></li><li><p>获取Properties配置文件</p><ul><li><p><img data-src="image-20210802222545909.png" alt="image-20210802222545909"><img data-src="image-20210802222640587.png" alt="image-20210802222640587" style="zoom:67%"></p></li><li><pre><code class="java">public class PropertiesServlet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        ServletContext context = this.getServletContext();

        InputStream resource = context.getResourceAsStream(&quot;/WEB-INF/classes/db.properties&quot;);//此处使用的路径与target下路径一致

        Properties properties = new Properties();
        properties.load(resource);
        //获取properties属性
        String username = properties.getProperty(&quot;username&quot;);
        String password = properties.getProperty(&quot;password&quot;);
    &#125;
&#125;
</code></pre></li></ul></li></ul><p>==<strong>以上内容大部分不会去使用</strong>==,之后有其他的替代技术</p><h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><p>web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse;</p><ul><li>如果要获取客户端请求过来的参数:找HttpServletRequest</li><li>如果要给客户端响应一些信息:找HttpServletResponse</li></ul><p><strong>简单分类:</strong></p><ul><li>向浏览器发送数据的方法</li></ul><pre><code class="java">ServletOutputStream getOutputStream() throws IOException;
PrintWriter getWriter() throws IOException;
</code></pre><ul><li><p>向浏览器发送响应头的方法</p><pre><code class="java">void setCharacterEncoding(String var1);
void setContentLength(int var1);
void setContentLengthLong(long var1);
void setContentType(String var1);
void setDateHeader(String var1, long var2);
void addDateHeader(String var1, long var2);
void setHeader(String var1, String var2);
void addHeader(String var1, String var2);
void setIntHeader(String var1, int var2);
void addIntHeader(String var1, int var2);
</code></pre></li><li><p>响应状态码</p><pre><code class="java">    int SC_OK = 200;
    int SC_MULTIPLE_CHOICES = 300;
    int SC_NOT_FOUND = 404;
    int SC_INTERNAL_SERVER_ERROR = 500;
    int SC_BAD_GATEWAY = 502;
</code></pre></li></ul><p><strong>常见应用:</strong></p><ul><li><p>向浏览器输出消息</p></li><li><p>下载文件</p><ul><li><p>获取下载文件的路径</p></li><li><p>获取下载文件名</p></li><li><p>让浏览器支持下载我们需要的东西</p></li><li><p>获取下载文件的输入流</p></li><li><p>创建缓冲区</p></li><li><p>获取OutputStream对象</p></li><li><p>将FileOutputStream流写入到buffer缓冲区</p></li><li><p>使用OutputStream将缓冲区中的数据输出到客户端</p></li><li><pre><code class="java">public class FileServlet extends HttpServlet &#123;
  @Override
  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
      // 获取下载文件的路径
      String realPath = this.getServletContext().getRealPath(&quot;WEB-INF/classes/1.jpg&quot;);
      System.out.println(&quot;文件路径:&quot;+realPath);
      // 获取下载文件名
      String fileName = realPath.substring(realPath.lastIndexOf(&quot;\\&quot;) + 1);
      System.out.println(&quot;文件名:&quot;+fileName);
      // 让浏览器支持下载我们需要的东西
      resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+ URLEncoder.encode(fileName,&quot;UTF-8&quot;));// 若为中文文件名则需要转码
      // 获取下载文件的输入流
      FileInputStream fileInputStream = new FileInputStream(realPath);
      // 创建缓冲区
      int len = 0;
      byte[] buffer = new byte[1024];
      // 获取OutputStream对象
      ServletOutputStream outputStream = resp.getOutputStream();
      // 将FileOutputStream流写入到buffer缓冲区
      // 使用OutputStream将缓冲区中的数据输出到客户端
      while ((len=fileInputStream.read(buffer))&gt;0)&#123;
          outputStream.write(buffer,0,len);
      &#125;
      // 关闭输入输出流
      fileInputStream.close();
      outputStream.close();
  &#125;
&#125;
</code></pre></li></ul></li><li><p>实现验证码功能</p><pre><code class="java">public class ImageServlet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        // 让浏览器三秒刷新一次
        resp.setHeader(&quot;refresh&quot;,&quot;3&quot;);
        // 在内存中创建一个图片
        BufferedImage image = new BufferedImage(80, 20, BufferedImage.TYPE_INT_RGB);
        // 得到画布
        Graphics2D graphics = (Graphics2D) image.getGraphics();
        // 填充图片背景颜色
        graphics.setColor(Color.PINK);
        graphics.fillRect(0,0,80,20);
        // 写入验证码数字
        graphics.setColor(Color.CYAN);
        graphics.setFont(new Font(null,Font.BOLD,20));
        graphics.drawString(randNum(),5,19);
        // 告诉浏览器这个请求用图片的方式打开
        resp.setContentType(&quot;image/jpeg&quot;);
        // 取消浏览器缓存
        resp.setDateHeader(&quot;expires&quot;,-1);
        resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);
        resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);
        //将图片写入回应
        ImageIO.write(image,&quot;jpg&quot;,resp.getOutputStream());
    &#125;

    // 生成随机数
    private String randNum()&#123;
        Random random = new Random();
        int num = random.nextInt(999999);
        String numStr = String.format(&quot;%06d&quot;, num);
        return numStr;
    &#125;
&#125;
</code></pre></li><li><p><strong>重定向</strong>(重点)</p><ul><li><p><code>resp.sendRedirect(&quot;/xxx&quot;); //就这一句代码</code></p><ul><li><pre><code class="java">//等价于这两句代码
resp.setHeader(&quot;Location&quot;,&quot;/xxx&quot;);
resp.setStatus(HttpServletResponse.SC_FOUND);
</code></pre><h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3></li></ul></li></ul></li></ul><p>HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息。</p><ul><li>获取参数<code>req.getParameter(&quot;name&quot;)</code></li><li>转发/重定向</li></ul><h2 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session-cookie"></a>session-cookie</h2><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>**会话:**用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话。</p><p>**有状态会话:**不同用户访问服务器服务器需要有不同的回应，这种带有用户信息的会话叫有状态会话。</p><p>网站如何知道用户曾经来过：</p><ol><li>服务端给客户端一个 信件，客户端下次访问带上信件就行；cookie</li><li>服务器登记用户来过，下次再来服务器匹配用户；session</li></ol><h3 id="保存会话的两种技术"><a href="#保存会话的两种技术" class="headerlink" title="保存会话的两种技术"></a>保存会话的两种技术</h3><p><strong>cookie</strong></p><ul><li>客户端技术（响应、请求）</li></ul><p><strong>session</strong></p><ul><li>服务器技术，利用该技术可以保存用户的会话信息。</li></ul><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>cookie实现保存用户上次访问时间：</p><pre><code class="java">public class CookieServlet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        //保存用户上一次访问的时间

        //解决中文乱码
        req.setCharacterEncoding(&quot;utf-8&quot;);
        resp.setCharacterEncoding(&quot;GBK&quot;);

        PrintWriter writer = resp.getWriter();

        //获得cookie
        Cookie[] cookies = req.getCookies();

        boolean flag = false;

        for (Cookie cookie : cookies) &#123;
            if(&quot;time&quot;.equals(cookie.getName()))&#123;
                flag = true;
            &#125;
        &#125;

        if (flag) &#123;
            for (int i = 0; i &lt; cookies.length; i++) &#123;
                Cookie cookie = cookies[i];
               if (&quot;time&quot;.equals(cookie.getName()))&#123;
                   writer.println(&quot;上次访问时间:&quot;+ new Date(Long.parseLong(cookie.getValue())).toString());
                   Cookie time = new Cookie(&quot;time&quot;, System.currentTimeMillis()+&quot;&quot;);
                   resp.addCookie(time);
               &#125;
            &#125;
        &#125; else &#123;
            writer.println(&quot;首次访问&quot;);
            Cookie cookie = new Cookie(&quot;time&quot;, System.currentTimeMillis()+&quot;&quot;);
            resp.addCookie(cookie);
        &#125;
    &#125;
&#125;
</code></pre><ul><li>一个cookie只能保存一个信息</li><li>一个web站点可以给浏览器发送cookie，最多存放20个cookie</li><li>cookie大小限制为4kb</li><li>浏览器可以存储300个cookie</li><li>同名cookie会自动替换</li></ul><p>删除cookie的一些方法</p><ul><li>将cookie的有效期设置为0，同名替换</li><li>不设置有效期，关闭浏览器自动失效</li></ul><p>编码解码：</p><pre><code class="java">//出现乱码时注意编码解码
URLEncoder.encode(&quot;qwq&quot;,&quot;UTF-8&quot;);
URLDecoder.decode(&quot;qwq&quot;,&quot;UTF-8&quot;);
</code></pre><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>什么是Session:</p><ul><li>服务器会给每一个用户(浏览器）创建一个Seesion对象;</li><li>一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在;</li><li>用户登录之后，整个网站它都可以访问;</li></ul><p>通过<strong>Attribute</strong>来设置取出数据</p><pre><code class="java">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        //解决乱码
        req.setCharacterEncoding(&quot;utf-8&quot;);
        resp.setCharacterEncoding(&quot;utf-8&quot;);
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        //获得session
        HttpSession session = req.getSession();
        //存入数据
        session.setAttribute(&quot;name&quot;,&quot;qwq&quot;);
        //获取session id
        String sessionId = session.getId();
        //判断session是不是新创建的
        if(session.isNew())&#123;
            resp.getWriter().println(&quot;session创建成功,ID:&quot;+sessionId);
        &#125;else &#123;
            resp.getWriter().println(&quot;session已存在,ID:&quot;+sessionId);
        &#125;
        // Session创建时做了什么
        // Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, sessionId);
        // resp.addCookie(cookie);
    &#125;

session.invalidate();//手动注销session
</code></pre><p>web.xml:</p><pre><code class="xml">&lt;session-config&gt;
    &lt;!-- 配置session失效时间,15分钟后自动失效 --&gt;
    &lt;session-timeout&gt;15&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre><p>Session和cookie的区别:</p><ul><li>Cookie是把用户的数据写给用户的浏览器，浏览器保存(可以保存多个)</li><li>Session把用户的数据写到用户独占Session中，服务器端保存(保存重要的信息，减少服务器资源的浪费)</li><li>Session对象由服务器创建;</li></ul><p>使用场景:</p><ul><li>保存一个登录用户的信息;</li><li>购物车信息;</li><li>在整个网站中经常会使用的数据，我们将它保存在Session中;</li></ul><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>Java Server Pages : Java服务器端页面，也和Servlet一样，用于动态Web技术!</p><p><strong>最大的特点:</strong></p><ul><li><p>写JSP就像在写HTML区别:</p></li><li><p>HTML只给用户提供静态的数据</p></li><li><p>JSP页面中可以嵌入JAVA代码，为用户提供动态数据;</p></li></ul><h3 id="JSP原理"><a href="#JSP原理" class="headerlink" title="JSP原理"></a>JSP原理</h3><p><strong>浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet!</strong></p><p>JSP最终也会被转换成为一个Java类!</p><p><strong>JSP本质上就是一个Servlet</strong></p><pre><code class="java">/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/10.0.2
 * Generated at: 2021-08-02 03:18:15 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp;

import jakarta.servlet.*;
import jakarta.servlet.http.*;
import jakarta.servlet.jsp.*;

public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent,
                 org.apache.jasper.runtime.JspSourceImports &#123;

  private static final jakarta.servlet.jsp.JspFactory _jspxFactory =
          jakarta.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map&lt;java.lang.String,java.lang.Long&gt; _jspx_dependants;

  private static final java.util.Set&lt;java.lang.String&gt; _jspx_imports_packages;

  private static final java.util.Set&lt;java.lang.String&gt; _jspx_imports_classes;

  static &#123;
    _jspx_imports_packages = new java.util.HashSet&lt;&gt;();
    _jspx_imports_packages.add(&quot;jakarta.servlet&quot;);
    _jspx_imports_packages.add(&quot;jakarta.servlet.http&quot;);
    _jspx_imports_packages.add(&quot;jakarta.servlet.jsp&quot;);
    _jspx_imports_classes = null;
  &#125;

  private volatile jakarta.el.ExpressionFactory _el_expressionfactory;
  private volatile org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map&lt;java.lang.String,java.lang.Long&gt; getDependants() &#123;
    return _jspx_dependants;
  &#125;

  public java.util.Set&lt;java.lang.String&gt; getPackageImports() &#123;
    return _jspx_imports_packages;
  &#125;

  public java.util.Set&lt;java.lang.String&gt; getClassImports() &#123;
    return _jspx_imports_classes;
  &#125;

  public jakarta.el.ExpressionFactory _jsp_getExpressionFactory() &#123;
    if (_el_expressionfactory == null) &#123;
      synchronized (this) &#123;
        if (_el_expressionfactory == null) &#123;
          _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
        &#125;
      &#125;
    &#125;
    return _el_expressionfactory;
  &#125;

  public org.apache.tomcat.InstanceManager _jsp_getInstanceManager() &#123;
    if (_jsp_instancemanager == null) &#123;
      synchronized (this) &#123;
        if (_jsp_instancemanager == null) &#123;
          _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
        &#125;
      &#125;
    &#125;
    return _jsp_instancemanager;
  &#125;

  public void _jspInit() &#123;
  &#125;

  public void _jspDestroy() &#123;
  &#125;

  public void _jspService(final jakarta.servlet.http.HttpServletRequest request, final jakarta.servlet.http.HttpServletResponse response)
      throws java.io.IOException, jakarta.servlet.ServletException &#123;

    if (!jakarta.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) &#123;
      final java.lang.String _jspx_method = request.getMethod();
      if (&quot;OPTIONS&quot;.equals(_jspx_method)) &#123;
        response.setHeader(&quot;Allow&quot;,&quot;GET, HEAD, POST, OPTIONS&quot;);
        return;
      &#125;
      if (!&quot;GET&quot;.equals(_jspx_method) &amp;&amp; !&quot;POST&quot;.equals(_jspx_method) &amp;&amp; !&quot;HEAD&quot;.equals(_jspx_method)) &#123;
        response.setHeader(&quot;Allow&quot;,&quot;GET, HEAD, POST, OPTIONS&quot;);
        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, &quot;JSP 只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS&quot;);
        return;
      &#125;
    &#125;

    final jakarta.servlet.jsp.PageContext pageContext;
    jakarta.servlet.http.HttpSession session = null;
    final jakarta.servlet.ServletContext application;
    final jakarta.servlet.ServletConfig config;
    jakarta.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    jakarta.servlet.jsp.JspWriter _jspx_out = null;
    jakarta.servlet.jsp.PageContext _jspx_page_context = null;


    try &#123;
      response.setContentType(&quot;text/html&quot;);
      pageContext = _jspxFactory.getPageContext(this, request, response,
                  null, true, 8192, true);
      //一些在jsp中可以直接使用的对象
      //-------------------------
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;
      //-------------------------
        
      //自动生成输出html页面的代码
      out.write(&quot;&lt;html&gt;\n&quot;);
      out.write(&quot;&lt;body&gt;\n&quot;);
      out.write(&quot;&lt;h2&gt;Hello World!&lt;/h2&gt;\n&quot;);
      out.write(&quot;&lt;/body&gt;\n&quot;);
      out.write(&quot;&lt;/html&gt;\n&quot;);
        
    &#125; catch (java.lang.Throwable t) &#123;
      if (!(t instanceof jakarta.servlet.jsp.SkipPageException))&#123;
        out = _jspx_out;
        if (out != null &amp;&amp; out.getBufferSize() != 0)
          try &#123;
            if (response.isCommitted()) &#123;
              out.flush();
            &#125; else &#123;
              out.clearBuffer();
            &#125;
          &#125; catch (java.io.IOException e) &#123;&#125;
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      &#125;
    &#125; finally &#123;
      _jspxFactory.releasePageContext(_jspx_page_context);
    &#125;
  &#125;
&#125;
</code></pre><img data-src="image-20210803204138452.png" alt="image-20210803204138452" style="zoom:50%"><p>在JSP页面中:</p><ul><li><p>只要是JAVA代码就会原封不动的输出;</p></li><li><p>如果是HTML代码，就会被转换为</p><pre><code class="java">out.write(&quot;&lt;html&gt;\n&quot;);
</code></pre><p>的格式输出</p></li></ul><h3 id="JSP基础语法与指令"><a href="#JSP基础语法与指令" class="headerlink" title="JSP基础语法与指令"></a>JSP基础语法与指令</h3><p>==<strong>JSP过时了!!!!!我不看辣!!!!(暴论</strong>==</p><p>有要用到的时候再看吧qwqq</p><p>算了我还是看吧qwqqqq</p><p><strong>语法:</strong></p><ul><li>jsp表达式<pre><code class="jsp">  &lt;%-- JSP表达式
      作用: 用来将程序的输出,输出到客户端
      &lt;%=变量或者表达式%&gt;
      --%&gt;
  &lt;%=new java.util.Date()%&gt;
</code></pre></li><li>jap脚本片段<pre><code class="jsp">  &lt;%-- JSP脚本片段 --%&gt;
  &lt;%
    int cnt = 1;
    StringBuilder s = new StringBuilder(&quot;qwq&quot;);
    for (int i = 0; i &lt; 5; i++) &#123;
      out.println(String.format(&quot;&lt;h%d&gt;&quot;+s+&quot;&lt;h%d&gt;&quot;, cnt,cnt));
      s.append(&quot;q&quot;);
      cnt++;
    &#125;
  %&gt;

  &lt;%-- JSP脚本中内嵌html --%&gt;
  &lt;%
    for (int i = 0; i &lt; 5; i++) &#123;
  %&gt;
     &lt;p&gt;hello &lt;%=i%&gt;&lt;/p&gt;
  &lt;%
    &#125;
  %&gt;
</code></pre></li><li>jsp声明<pre><code class="jsp">  &lt;%-- JSP声明 --%&gt;
  &lt;%!
    static &#123;
      System.out.println(&quot;load servlet&quot;);
    &#125;

    private int global = 0;

    private void qwq() &#123;
      System.out.println(&quot;qwq&quot;);
    &#125;
  %&gt;
</code></pre><ul><li>JSP声明:会被编译到JSP生成Java的<strong>类中</strong>!其他的，就会被生成到**_jspService方法**中!</li></ul></li></ul><p><strong>指令:</strong></p><pre><code class="jsp">&lt;%@ page args... %&gt;
&lt;%@ include file=&quot;xxx&quot; %&gt; 将两个页面合二为一,不推荐使用,可能出现变量重名
推荐使用 &lt;jsp:include page = &quot;/xxx&quot;/&gt; 拼接页面,本质还是两个页面不相互影响
</code></pre><h3 id="JSP内置对象"><a href="#JSP内置对象" class="headerlink" title="JSP内置对象"></a>JSP内置对象</h3><ul><li>PageContext 存东西<ul><li>存的数据只在一个页面中有效</li></ul></li><li>Request 存东西<ul><li>保存的数据只在一次请求中有效，请求转发会携带这个数据</li></ul></li><li>Response</li><li>Session 存东西<ul><li>保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器</li></ul></li><li>Application 【SerlvetContext】存东西<ul><li>保存的数据在服务器中有效，从打开浏览器到关闭浏览器</li></ul></li><li>config 【SerlvetConfig】</li><li>out</li><li>page</li><li>exception</li></ul><pre><code class="jsp">&lt;%
    pageContext.setAttribute(&quot;name1&quot;, &quot;qwq1&quot;);    //保存的数据只在一个页面中有效
    request.setAttribute(&quot;name2&quot;, &quot;qwq2&quot;);      //保存的数据只在一次请求中有效，请求转发会携带这个数据
    session.setAttribute(&quot;name3&quot;, &quot;qwq3&quot;);       //保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器
    application.setAttribute(&quot;name4&quot;, &quot;qwq4&quot;);  //保存的数据在服务器中有效，从打开浏览器到关闭浏览器
%&gt;
&lt;%
    //从pagecontext取出,我们通过寻找的方式来/从底层到高层（作用域):
    String name1 = (String) pageContext.findAttribute(&quot;name1&quot;);
    String name2 = (String) pageContext.findAttribute(&quot;name2&quot;);
    String name3 = (String) pageContext.findAttribute(&quot;name3&quot;);
    String name4 = (String) pageContext.findAttribute(&quot;name4&quot;);
    String name5 = (String) pageContext.findAttribute(&quot;name5&quot;);   //不存在
%&gt;
&lt;%--使用EL表达式取出--%&gt;
&lt;h1&gt;name:&lt;/h1&gt;
&lt;h4&gt;$&#123;name1&#125;&lt;/h4&gt;
&lt;h4&gt;$&#123;name2&#125;&lt;/h4&gt;
&lt;h4&gt;$&#123;name3&#125;&lt;/h4&gt;
&lt;h4&gt;$&#123;name4&#125;&lt;/h4&gt;
&lt;h4&gt;$&#123;name5&#125;&lt;/h4&gt;
&lt;%--null值不会输出--%&gt;
</code></pre><p>request:客户端向服务器发送请求，产生的数据，用户看完就没用了，比如:新闻，用户看完没用的!</p><p>session:客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如:购物车;</p><p>application:客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如:聊天数据;</p><h3 id="JSP标签、JSTL标签、EL表达式"><a href="#JSP标签、JSTL标签、EL表达式" class="headerlink" title="JSP标签、JSTL标签、EL表达式"></a>JSP标签、JSTL标签、EL表达式</h3><p><strong>EL表达式:</strong></p><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt;
    &lt;artifactId&gt;jakarta.servlet.jsp.jstl&lt;/artifactId&gt;
    &lt;version&gt;2.0.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.taglibs&lt;/groupId&gt;
    &lt;artifactId&gt;taglibs-standard-spec&lt;/artifactId&gt;
    &lt;version&gt;1.2.5&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><ul><li><code>$&#123;&#125;</code><ul><li>获取数据</li><li>执行运算</li><li>获取web开发的常用对象</li></ul></li></ul><p><strong>JSP标签:</strong></p><pre><code class="jsp">&lt;%--jsp:include--%&gt;
&lt;%--http://1ocalhost:8080/xxx.jsp?name=qwq&amp;age=12--%&gt;
&lt;jsp:forward page=&quot;/xxx.jsp&quot;&gt;
  &lt;jsp:param name=&quot;name&quot; value=&quot;qwq&quot;/&gt;
  &lt;jsp:param name=&quot;age&quot; value=&quot;12&quot;/&gt;
&lt;/jsp:forward&gt;
</code></pre><p><strong>JSTL表达式:</strong></p><p>JSTL标签库的使用就是为了弥补HTML标签的不足;它自定义许多标签，可以供我们使用，标签的功能和Java代码一样!</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9qc3AvanNwLWpzdGwuaHRtbA==">JSP 标准标签库（JSTL）</span></p><h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p>实体类</p><p>JavaBean有特定的写法:</p><ul><li>必须要有一个无参构造</li><li>属性必须私有化</li><li>必须有对应的get/set方法;</li></ul><p>一般用来和数据库的字段做映射 ORM</p><p>ORM: 对象关系映射</p><ul><li>表 –&gt; 类</li><li>字段 –&gt; 属性</li><li>行记录 –&gt; 对象</li></ul><h2 id="MVC三层架构"><a href="#MVC三层架构" class="headerlink" title="MVC三层架构"></a>MVC三层架构</h2><p>什么是MVC: Model view Controller 模型 视图 控制器</p><p><img data-src="image-20210804104618878.png" alt="image-20210804104618878"></p><ul><li>Model<ul><li>业务处理: 业务逻辑(Service)</li><li>数据持久层: CRUD (Dao)</li></ul></li><li>View<ul><li>展示数据</li><li>提供链接发起Servlet请求(a,form, img…)</li></ul></li><li>Controller (Servlet)<ul><li>接收用户的请求: (req:请求参数、Session信息….)</li><li>交给业务层处理对应的代码</li><li>控制视图的跳转</li></ul></li></ul><p>இ௰இ</p><h2 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h2><p><img data-src="image-20210804105016860.png" alt="image-20210804105016860"></p><p>编写步骤:</p><ol><li><p>导包 <code>jakarta.servlet.Filter</code></p></li><li><p>编写过滤器</p><pre><code class="java">public class CharacterEncodingFilter implements Filter &#123;
    // 初始化,在web服务器启动时就已经初始化了,随时等待被过滤对象
    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;
        System.out.println(&quot;CharacterEncodingFilter初始化&quot;);
    &#125;

    // FilterChain 过滤器链
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
        servletRequest.setCharacterEncoding(&quot;utf-8&quot;);
        servletResponse.setCharacterEncoding(&quot;utf-8&quot;);
        servletResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);

        System.out.println(&quot;CharacterEncodingFilter执行前&quot;);
        filterChain.doFilter(servletRequest,servletResponse);   // 让请求继续往下交接,若不写,则请求到这个过滤器时就会被拦截
        System.out.println(&quot;CharacterEncodingFilter执行后&quot;);
    &#125;

    // 销毁,在web服务器关闭时就被销毁
    @Override
    public void destroy() &#123;
        System.out.println(&quot;CharacterEncodingFilter销毁&quot;);
    &#125;
&#125;
</code></pre></li><li><p>配置web.xml</p><pre><code class="xml">&lt;filter&gt;
    &lt;filter-name&gt;encodeing&lt;/filter-name&gt;
    &lt;filter-class&gt;com.wang.filter.CharacterEncodingFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encodeing&lt;/filter-name&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre></li></ol><h2 id="Listener监听器"><a href="#Listener监听器" class="headerlink" title="Listener监听器"></a>Listener监听器</h2><p>==不常用，不听了இ௰இ==</p><p>==<strong>再往下翻也没有了啦qwqq</strong>==</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2021-08-04 11:22:29" itemprop="dateModified" datetime="2021-08-04T11:22:29+08:00">2021-08-04</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Ling yunchi 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Ling yunchi 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Ling yunchi 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Ling yunchi <i class="ic i-at"><em>@</em></i>QWQ</li><li class="link"><strong>本文链接：</strong> <a href="https://ling-yunchi.github.io/2021/08/02/javaWeb/" title="javaWeb">https://ling-yunchi.github.io/2021/08/02/javaWeb/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/07/30/Docker/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicm0fdw5cj20zk0m8hdt.jpg" title="Docker"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>Docker</h3></a></div><div class="item right"><a href="/2021/08/06/Redis/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipet4bz0yj20zk0m8e81.jpg" title="Redis"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>Redis</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#javaWeb"><span class="toc-number">1.</span> <span class="toc-text">javaWeb</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81web"><span class="toc-number">1.2.</span> <span class="toc-text">静态web</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81web"><span class="toc-number">1.3.</span> <span class="toc-text">动态web</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">web服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Http"><span class="toc-number">1.5.</span> <span class="toc-text">Http</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Maven"><span class="toc-number">1.6.</span> <span class="toc-text">Maven</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet"><span class="toc-number">1.7.</span> <span class="toc-text">Servlet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HelloServlet"><span class="toc-number">1.7.1.</span> <span class="toc-text">HelloServlet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">Servlet原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mapping%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.3.</span> <span class="toc-text">Mapping问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ServletContext"><span class="toc-number">1.7.4.</span> <span class="toc-text">ServletContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HttpServletResponse"><span class="toc-number">1.7.5.</span> <span class="toc-text">HttpServletResponse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HttpServletRequest"><span class="toc-number">1.7.6.</span> <span class="toc-text">HttpServletRequest</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#session-cookie"><span class="toc-number">1.8.</span> <span class="toc-text">session-cookie</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.8.1.</span> <span class="toc-text">会话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E4%BC%9A%E8%AF%9D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%8A%80%E6%9C%AF"><span class="toc-number">1.8.2.</span> <span class="toc-text">保存会话的两种技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie"><span class="toc-number">1.8.3.</span> <span class="toc-text">cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session"><span class="toc-number">1.8.4.</span> <span class="toc-text">session</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSP"><span class="toc-number">1.9.</span> <span class="toc-text">JSP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSP%E5%8E%9F%E7%90%86"><span class="toc-number">1.9.1.</span> <span class="toc-text">JSP原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSP%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%8C%87%E4%BB%A4"><span class="toc-number">1.9.2.</span> <span class="toc-text">JSP基础语法与指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSP%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.9.3.</span> <span class="toc-text">JSP内置对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSP%E6%A0%87%E7%AD%BE%E3%80%81JSTL%E6%A0%87%E7%AD%BE%E3%80%81EL%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.9.4.</span> <span class="toc-text">JSP标签、JSTL标签、EL表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaBean"><span class="toc-number">1.10.</span> <span class="toc-text">JavaBean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-number">1.11.</span> <span class="toc-text">MVC三层架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Filter%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.12.</span> <span class="toc-text">Filter过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Listener%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">1.13.</span> <span class="toc-text">Listener监听器</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Ling yunchi" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Ling yunchi</p><div class="description" itemprop="description">qwqqqq</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">39</span> <span class="name">文章</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpbmcteXVuY2hp" title="https:&#x2F;&#x2F;github.com&#x2F;Ling-yunchi"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/07/30/Docker/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/08/06/Redis/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Ling yunchi @ Ling Yunchi</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/08/02/javaWeb/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->