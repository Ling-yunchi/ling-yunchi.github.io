<!-- build time:Mon Aug 09 2021 22:03:48 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="QWQ" href="https://ling-yunchi.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="QWQ" href="https://ling-yunchi.github.io/atom.xml"><link rel="alternate" type="application/json" title="QWQ" href="https://ling-yunchi.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://ling-yunchi.github.io/2021/03/13/%E9%9D%A2%E5%90%91%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E7%9A%84%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/"><title>面向问题求解的高级语言设计 | Ling Yunchi = QWQ</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">面向问题求解的高级语言设计</h1><div class="meta"><span class="item" title="创建时间：2021-03-13 19:02:27"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-03-13T19:02:27+08:00">2021-03-13</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Ling Yunchi</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giph4wqtg4j20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclxp31goj20zk0m8qv5.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclx29mstj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipew8gmvyj20zk0m87wh.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclfb3vzhj20zk0m8wny.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclh0m9pdj20zk0m8hdt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://ling-yunchi.github.io/2021/03/13/%E9%9D%A2%E5%90%91%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E7%9A%84%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Ling yunchi"><meta itemprop="description" content=", qwqqqq"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="QWQ"></span><div class="body md" itemprop="articleBody"><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p><strong>注意:通过一些条件缩小枚举范围</strong></p><h2 id="搜索枚举"><a href="#搜索枚举" class="headerlink" title="搜索枚举"></a>搜索枚举</h2><p>可以使用dfs来枚举每一种符合条件的情况,再对符合条件的情况进行检验<br><a href="#####%E6%9D%83%E5%8A%9B%E6%8C%87%E6%95%B0">例题</a></p><h2 id="高斯消元与枚举"><a href="#高斯消元与枚举" class="headerlink" title="高斯消元与枚举"></a>高斯消元与枚举</h2><p>高斯消元即是矩阵方程求解的方法,使用计算机模拟手工计算</p><p>在某些必定有解的题目中使用高斯消元化简方程,再使用枚举可以降低枚举量</p><p><a href="#####%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%A8%A1%E6%9D%BF">高斯消元模板</a></p><p><a href="#####1-2">例题</a></p><h2 id="stl中的全排列函数next-permutation"><a href="#stl中的全排列函数next-permutation" class="headerlink" title="stl中的全排列函数next_permutation"></a>stl中的全排列函数next_permutation</h2><p>需要某些数据的全排列进行枚举时可以使用stl中的permutation来使用数据的全排列qwqq</p><ol><li><p>next_permutation：求下一个排列组合</p><ul><li>函数模板：next_permutation(arr, arr+size);</li><li>参数说明：<ul><li>arr： 数组名</li><li>size：数组元素个数</li></ul></li><li>函数功能： 返回值为bool类型，当当前序列不存在下一个排列时，函数返回false，否则返回true，排列好的数在数组中存储</li><li>注意：在使用前需要对欲排列数组按升序排序，否则只能找出该序列之后的全排列数。<ul><li>比如，如果数组num初始化为2,3,1，那么输出就变为了：{2 3 1} {3 1 2} {3 2 1}</li></ul></li></ul></li><li><p>prev_permutation：求上一个排列组合</p><ul><li>函数模板：prev_permutation(arr, arr+size);</li><li>参数说明：<ul><li>arr： 数组名</li><li>size：数组元素个数</li></ul></li><li>函数功能： 返回值为bool类型，当当前序列不存在上一个排列时，函数返回false，否则返回true</li><li>注意：在使用前需要对欲排列数组按降序排序，否则只能找出该序列之后的全排列数。</li></ul></li></ol><p>==该函数是以字典序排序==</p><p><a href="#####1-3">例题</a></p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><ul><li>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法</li><li>要求查找的线性表是有单调性的（这样可以做到排除一半）</li></ul><p><strong>二分答案：</strong></p><p>在答案所在的范围内使用二分查找法查找答案，根据每次查找的结果缩小答案所在范围，最后找出答案。</p><p>何时使用？</p><ul><li>与答案相关的变量有单调性</li><li>即随着答案的变大，这个变量会单调递减/递增</li><li>相当于我们在一个一次函数上二分寻找目标点</li><li>出现最大值最小/最小值最大时可以考虑</li></ul><pre><code class="c++">int binary(int l, int r)
&#123;
    int ans = 0;
    while (l &lt;= r)
    &#123;
        int mid = (l + r) &gt;&gt; 1;
        //此处是查找符合条件的最大值
        if (check(mid))
            ans = mid, r = mid + 1;
        else
            l = mid + 1;
        // 查找最小值
        // if(check(mid))
        //     ans = mid, r = mid + 1;
        // else
        //     l = mid + 1;
    &#125;
    return ans;
&#125;
</code></pre><p>例题: [Electric Charges](#####Electric Charges)</p><h2 id="三分"><a href="#三分" class="headerlink" title="三分"></a>三分</h2><p><strong>前提</strong></p><p>三分搜索适用于具有凹凸性的函数，如图所示为一个具有凸性质的函数（注意不一定为一个标准的二次函数，只需要在<strong>唯一</strong>极值<strong>两端的单调性不同</strong>即可）在这个函数中我们就可以使用三分搜索。</p><ul><li><p>对于一个有<strong>极大值的单峰函数</strong>，当f(lm)&gt;f(rm)时，只会有两种情况：</p><ol><li><p>lm在对称轴左边，rm在对称轴右边</p></li><li><p>lm和rm都在对称轴右边</p></li></ol></li><li><p>回想二次函数图像，一定可以舍掉右边的区间</p></li><li><p>&lt;的情况同理</p></li><li><p>每次舍掉1/3,复杂度O(2log3(n)),比二分要慢</p></li></ul><pre><code class="c++">const int eps = 1e-6;
double T_search(double l, double r)
&#123;
    double lm = (l + l + r) / 3, rm = (l + r + r) / 3;
    if(f(lm)&gt;f(rm)) r = rm;
    else l = lm;
&#125;
</code></pre><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p><strong>相关定义</strong></p><p>优先队列容器和队列一样，只能从队尾插入元素，从队首删除元素。</p><p>队列中最大的元素总是位于队首，所以出队时，并不是完全一样的遵循先进先出的原则来进行的，而是将队列中最大的元素出队。这点有点儿类似于给队列里元素先进行一个排序，再按照顺序出队。元素的比较规则默认按照元素值由大到小排序，我们可以<strong>重载 “&lt;” 操作符</strong>来重新定义比较规则。</p><p>优先队列可以用容器vector 或双向队列（deque）来实现（特殊情况：list container不能用来实现queue，因为list的迭代器不是任意存取iterator，而pop中所用到的堆排序时要求randomaccess iterator）</p><pre><code class="c++">priority_queue&lt;vector&lt;int&gt;,less&lt;int&gt;&gt; a1;  //使用递增less&lt;int&gt; 函数对象排序
priority_queue&lt;deque&lt;int&gt;,greater&lt;int&gt;&gt; a2 ;  //使用递增greater&lt;int&gt;函数对象排序
</code></pre><p>里边还有的函数有：”判空(empty)”，”大小(size)” , “栈顶元素(top)”,”入栈(push)”,”出栈(pop)”等</p><h2 id="中位数与带权中位数"><a href="#中位数与带权中位数" class="headerlink" title="中位数与带权中位数"></a>中位数与带权中位数</h2><p><strong>中位数:</strong></p><p>数轴上的中位数:</p><p>​ 我们可以把所选定的位置左右的两个点看成一对，只要所选位置在两者之间，那么长度恒等于两点的线性距离和，所以我们可以从两边开始,根据每一对点位不断缩小我们所选位置的范围，最后如果有奇数个点，那么就会在中间的那个点上，如果是偶数那么在中间两个数和他们所构成的区间，这样想就容易发现中位数这一规律了。</p><p>数列中的中位数:</p><p>设$a[m]$为一个数列,求中位数,当m为偶数时,求较小的那个中位数</p><ul><li>a中元素<strong>不重复</strong>:<ul><li>排序后直接取</li><li>不排序使用二分法查找验算<ul><li>m为奇数,小于中位数的数的个数为$\left \lfloor m/2 \right \rfloor$</li><li>m为偶数,小于中位数的数的个数为$m/2-1$</li></ul></li></ul></li><li>a中元素<strong>存在重复</strong><ul><li>排序</li><li>不排序使用二分法查找验算<ul><li>m为奇数,查找<strong>最大</strong>的数a,使小于a的数的个数为<strong>小于等于</strong>$\left \lfloor m/2 \right \rfloor$</li><li>m为偶数,查找<strong>最大</strong>的数a,使小于a的数的个数为<strong>小于等于</strong>$m/2-1$</li></ul></li></ul></li></ul><p><strong>带权中位数:</strong></p><p>带权中位数问题就是<strong>权值的中位数</strong>，我们可以这么想，不带权的相当于权为1，每个点只有一个人，那么带权就相当每个点有该点权值个人，这样理解就与上面的思路相同,通过从两边开始利用对点缩小查找范围,最后找到答案qwqq</p><p><a href="#####2-1">例题</a></p><p>参考:<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nsb3Zlcl9oeHkvYXJ0aWNsZS9kZXRhaWxzLzUwNjE4NzM2">中位数与带权中位数</span></p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="什么是贪心"><a href="#什么是贪心" class="headerlink" title="什么是贪心"></a>什么是贪心</h2><p>贪心算法，有些教材上又称为贪婪算法，正是采纳了“贪心”中的“只顾眼前”这一点。贪心算法往往用来解决<strong>最优化问题</strong>，即求在一定约束下的全局最优解。因为对局部进行处理往往比长远考虑要容易的多。而且在一定的问题中，“只顾眼前”反而能得到“长远最优”，此时使用贪心算法来求解就非常方便。</p><p>换一句话讲，贪心算法就是把问题的求解<strong>分为好多步</strong>，在每一步内取当前的<strong>局部最优</strong>，并且最终能够通过这些局部的最优解达到<strong>全局最优</strong>。</p><h2 id="贪心算法的设计过程"><a href="#贪心算法的设计过程" class="headerlink" title="贪心算法的设计过程"></a>贪心算法的设计过程</h2><p><strong>阶段划分</strong></p><p><strong>求局部最优解</strong></p><p><strong>得到全局贪心解</strong></p><p><strong>正确性证明</strong></p><h2 id="贪心算法的正确性证明"><a href="#贪心算法的正确性证明" class="headerlink" title="贪心算法的正确性证明"></a>贪心算法的正确性证明</h2><p>贪心算法的<strong>正确性</strong>，指的是一个贪心算法<strong>能否通过局部最优最终推得全局最优</strong>。贪心算法虽然在每一步只用考虑当前步骤，处理起来非常简单。然而，如果不证明正确性，我们就没法确定最终得到的解就是最优的。因此，在设计出一种贪心算法后，我们都需要证明其正确性。</p><p>然而，贪心算法的正确性证明非常困难。而且针对不同的问题，证明方法多种多样。</p><p>一种比较常用的证明思路为：</p><ol><li>用贪心算法得到的所有局部最优解构造一个解的序列/集合（根据题目的解是否有序）</li><li>列举出其他<strong>所有</strong>可能的解的序列/集合</li><li>证明所有其他序列/集合的解<strong>都</strong>不优于贪心算法得到的解</li></ol><p>==<strong>贪心法的证伪只需要构造一个反例！</strong>==</p><h2 id="贪心的优劣"><a href="#贪心的优劣" class="headerlink" title="贪心的优劣"></a>贪心的优劣</h2><ul><li><p>优势</p><ol><li><p>算法思想比较简洁、直观</p></li><li><p>只用考虑局部情况，实现非常简单</p></li><li><p>复杂度较优，效率较高</p></li></ol></li><li><p>劣势</p><ol><li><p>正确性证明非常困难</p></li><li><p>证伪时的反例构造比较困难</p></li><li><p>有些贪心题的结论很难想到</p></li></ol></li></ul><h2 id="多种贪心"><a href="#多种贪心" class="headerlink" title="多种贪心"></a>多种贪心</h2><p>这种题的贪心策略往往不是很好想，这个时候我们就需要依照尽量逼近正解的思路，进行多种贪心，在每种贪心都保证正确的前提下，取多个答案的最值，这样往往就是正解。</p><p>而这种 多线程贪心 可以有两种：</p><ul><li>单独做每种，然后取最优。</li><li>每一步转移都用多种贪心取得，然后直接取最后的状态值。</li></ul><p>显然后一种的正确性比较高，但是往往因为“贪心”的奇葩性，而并不能写出这样的贪心</p><p><a href="#####2-2">例题</a></p><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>关键:<strong>队列</strong>的使用</p><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><a href="./%E5%9B%BE-DFS%E4%B8%8Etarjan.md">dfs</a></p><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><h4 id="减少搜索宽度"><a href="#减少搜索宽度" class="headerlink" title="减少搜索宽度"></a>减少搜索宽度</h4><p>无论是搜索最优解还是搜索确定解，我们总希望尽快的找到解，因此就要调整搜索树的遍历顺序。</p><p><strong>怎样调整搜索顺序？</strong></p><ul><li>我们需要优先搜索那些可能很快就能得到解的子问题，往往可以通过对<strong>子问题进行排序</strong>来达到调整搜索顺序的目的</li></ul><p>这样就可以比较早的得到问题的解或最优解。如果要求一个确定的解，到此就结束搜索了，可以有效减小搜索宽度；如果要求一个最优解，还需要减少搜索深度。</p><h4 id="减少搜索深度"><a href="#减少搜索深度" class="headerlink" title="减少搜索深度"></a>减少搜索深度</h4><p>通过<strong>减少搜索宽度</strong>可以较早的得到一个搜索目标，接下来我们若想求最优解，按道理来说是每种情况遍历到底后再进行比较，但这样的话效率太低，这时我们就需要通过估计减少搜索深度</p><p><strong>如何减少搜索深度？</strong></p><ul><li>对每一个子问题进行搜索前可以先获得该子问题的搜索目标的<strong>极限</strong>，通过该极限可以判断对该子问题搜索出的解能否比当前最优解更优；</li><li>对该子问题搜索出的搜索目标能否满足要求进行检查，如果不能，就没必要了搜下去了，直接跳过对该子问题的搜索。该剪枝可以有效减小对某一子问题的搜索深度。</li></ul><p>例题：<a href="#####poj1190">poj 1190</a></p><h1 id="分治与递归"><a href="#分治与递归" class="headerlink" title="分治与递归"></a>分治与递归</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><a href="#####5-1">数列</a></p><p><a href="#####%E8%81%AA%E6%98%8E%E7%9A%84%E5%AD%A6%E7%94%9F">聪明的学生</a></p><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p><a href="#####%E7%81%AB%E6%9F%B4%E6%8E%92%E9%98%9F">火柴排队</a></p><h3 id="莫队算法"><a href="#莫队算法" class="headerlink" title="莫队算法"></a>莫队算法</h3><p>莫队算法可以解决一类离线区间询问问题，适用性极为广泛。同时将其加以扩展，便能轻松处理树上路径询问以及支持修改操作。</p><h4 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h4><p>假设$n=m$ ，那么对于序列上的区间询问问题，如果从$[l,r]$的答案能够$O(1)$扩展到$[l-1,r],[l+1,r],[l,r+1],[l,r-1]$（即与$[l,r]$相邻的区间）的答案，那么可以在$O(n\sqrt{n})$的复杂度内求出所有询问的答案。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>离线后排序，顺序处理每个询问，暴力从上一个区间的答案转移到下一个区间答案（一步一步移动即可）。</p><h4 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h4><p>对于区间$[l,r]$, 以$l$所在块的编号为第一关键字，$r$为第二关键字从小到大排序。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>若按照上面排序方法的话，将会有多次指针从块$p$中的$r_{max}$移动到块$p+1$中的$r_{min}$,使得移动次数大大怎加,此时我们可以用到奇偶化排序对其进行优化。</p><p>什么是奇偶化排序？奇偶化排序即对于属于<strong>奇数块</strong>的询问，r 按从<strong>小到大</strong>排序，对于属于<strong>偶数块</strong>的排序，r 从<strong>大到小</strong>排序，这样我们的 r 指针在处理完这个奇数块的问题后，将在返回的途中处理偶数块的问题，再向 n 移动处理下一个奇数块的问题，优化了 r 指针的移动次数，一般情况下，这种优化能让程序快 30% 左右。</p><p><span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9taXNjL21vLWFsZ28v">oi wiki</span></p><p>[Point on Plane](######Point on Plane)</p><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为$O(logN)$ 。而未优化的空间复杂度为$2N$ ，因此有时需要离散化让空间压缩</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在$O(logN)$的时间复杂度内实现如：<strong>单点修改</strong>、<strong>区间修改</strong>、<strong>区间查询</strong>（如：区间求和，求区间最大值，求区间最小值……）还有很多…… 总之线段树维护的信息，需要满足可加性，且要以可以接受的速度合并信息和修改信息，如果使用标记，标记也要满足<strong>可加性</strong>（例如取模就不满足可加性，对$4$取模然后对$3$取模，两个操作就不能合并在一起做（事实上某些情况下可以暴力单点取模）</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>数组$arr[maxn]$存储原始数据，数组$p[maxn\times4]$用于存储结点信息(<strong>记得开足四倍空间哦qwqq</strong>)</p><p>对于节点$p[i],i&gt;0$,都有他的左子节点为$p[i\times 2]$,右子节点为$p[i \times 2+1]$</p><p>还要满足$p[i]=p[i\times2]+p[i\times2+1]$</p><pre><code class="c++">//采用递归建树
void build(int n, int l, int r) //n为当前结点
&#123;                    //l,r为当前结点下面子节点在原数组中对应的范围
    if (l == r) //递归到叶子结点,进行赋值 
    &#123;
        p[n] = arr[l];//将数组中对应数字赋值给对应结点
        return;
    &#125;
    int mid = l + r &gt;&gt; 1;
    //以当前结点为根节点,左右递归建树
    build(n &lt;&lt; 1, l, mid);//递归左子结点
    build(n &lt;&lt; 1 | 1, mid + 1, r);//递归右子结点
    //维护父子节点的关系
    p[n] = p[n &lt;&lt; 1] + p[n &lt;&lt; 1 | 1];
&#125;
</code></pre><h4 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h4><p>线段树主要采用的是分块思想，它所维护的标记也要满足<strong>区间可加性</strong>，所以对于一个区间修改，它总是可以被拆分为多个被该区间<strong>完全包含</strong>的<strong>块</strong>和<strong>单个元素</strong>，然后分开处理：</p><p>​ <strong>如果整个块被包含，就修改整个区间；如果是单个元素被包含，就只修改它自己</strong></p><p>在线段树中，无论是元素还是区间都是线段树上的结点，所以比较方便实现</p><h5 id="懒标记"><a href="#懒标记" class="headerlink" title="懒标记"></a>懒标记</h5><p>若对区间内每个元素都进行同一个修改，那么还是要递归到底层进行修改，效率不高；但线段树的优势不在于<strong>全修改</strong>，而在于<strong>全记录</strong>，对于对整个区间进行的修改，我们不对其下放（$push,dowm$），而是在这个区间的根节点上做一个记录，在要使用被修改过的数据时，我们再对其进行下放，用啥放啥。这样就能尽量减少下放的操作次数，提高修改效率</p><h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><p>增加一个数组$d[maxn\times4]$用于存储对于对应结点下的数据的修改，即$delta$</p><p>下放时满足$d[i\times2]=d[i\times2+1]=d[i]$,下放完毕后记得清空下放的标记$d[i]=0$</p><pre><code class="c++">
</code></pre><h3 id="CDQ分治"><a href="#CDQ分治" class="headerlink" title="CDQ分治"></a>CDQ分治</h3><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>动态规划</strong> <strong>(dynamic programming)</strong> 是运筹学的一个分支，是求解<strong>决策过程</strong> <strong>(decision process)</strong> 最优化的数学方法。其特点在于将一个多阶段的问题转化为一系列的单阶段问题，利用各个阶段之间的关系，逐个求解。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><strong>最优子结构（最优化原理）：</strong>整个问题的最优策略可以通过将问题划分成多个子问题，并且分别求对应的最优策略得出。</li><li><strong>无后效性：</strong>当前的决策无法影响未来的决策。</li><li><strong>子问题的重叠性：</strong>将整个问题划分为子问题后，子问题之间具有相似性。</li></ul><h2 id="dp类型"><a href="#dp类型" class="headerlink" title="dp类型"></a>dp类型</h2><ul><li><strong>区间</strong> <strong>DP</strong> <strong>：</strong>对一个区间进行 DP 操作。用 <em>dp</em>[<em>i</em>][<em>j</em>] 表示区间[<em>i</em>*..*<em>j</em>] 的结果。</li><li><strong>树形</strong> <strong>DP</strong> <strong>：</strong>在树上进行 DP，通常是用叶子节点去更新根节点的答案。</li><li><strong>状压</strong> <strong>DP</strong> <strong>：</strong>将复杂的，非一维的状态压缩（HASH）成一个数，表示当前的状态，然后进行 DP。</li><li><strong>概率</strong> <strong>DP</strong> <strong>：</strong>用来计算概率的 DP。</li><li><strong>数位</strong> <strong>DP</strong> <strong>：</strong>通过用不同的数位表示不同的状态，进行 DP。</li></ul><h2 id="dp例题"><a href="#dp例题" class="headerlink" title="dp例题"></a>dp例题</h2><p><a href="#####0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">01背包问题</a></p><p><a href="#####%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">完全背包问题</a></p><p>[Big Event in HDU(多重背包问题)](#####Big Event in HDU)</p><p>[Anniversary party(树形DP)](#####Anniversary party)</p><h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="最短路的性质"><a href="#最短路的性质" class="headerlink" title="最短路的性质"></a>最短路的性质</h2><p>连通图中，最短路存在且为简单路径的充要条件为，这个连通图中不存在<strong>负权回路(一个首尾相接的环,环的总路径长度小于0)</strong></p><h2 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h2><h3 id="Flody"><a href="#Flody" class="headerlink" title="Flody"></a>Flody</h3><p>O(n^3) 求图上任意两点间距离</p><p>在离散数学课上讲过 Floyd-Warshall 算法传递闭包</p><p>两个做法是几乎一样的</p><pre><code>function Floyd(G&lt;V, E&gt;):
    for k in 1..|V|:
        for i in 1..|V|:
            for j in 1..|V|:
                (i, j) &lt;-relax-- (i, k) + (k, j))
</code></pre><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>O(n^2) 求图上源点到任意点间距离</p><p><strong>松弛操作</strong>：$dist[v] = min(dist[v], dist[u] + len(u, v))$</p><p>遍历图上的所有点,进行松弛</p><h3 id="堆优化Dijkstra"><a href="#堆优化Dijkstra" class="headerlink" title="堆优化Dijkstra"></a>堆优化Dijkstra</h3><p>跟 SPFA 思路类似，也是 BFS</p><p>但是用一个 priority_queue 来维护队列</p><p>优先弹出 dist 最小的点</p><p>一般不用它来搞负权回路</p><p>时间复杂度 O((n+m) log n)</p><p><a href="#####%E5%A0%86%E4%BC%98%E5%8C%96Dijkstra%E6%A8%A1%E6%9D%BF">堆优化dijstra模板</a></p><h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><p>这是一个检测<strong>是否有副权回路</strong>的算法</p><p>上述算法都对负权回路不免疫</p><p>也就是说有负权回路你的代码就炸了 (Floyd只是会给出错误解)</p><p><strong>检验方法:</strong></p><p>若算法跑了 n – 1 次</p><p>如果这时候还有边可以被“松弛”</p><p>那说明图可以跑 n 遍，肯定有个负权回路</p><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>据说随手被卡qwqqq</p><h2 id="一些应用"><a href="#一些应用" class="headerlink" title="一些应用"></a>一些应用</h2><h3 id="超源-超汇点"><a href="#超源-超汇点" class="headerlink" title="超源,超汇点"></a>超源,超汇点</h3><ul><li>构建一个虚拟的源点</li><li>适用于“多源最短路问题”</li></ul><p>比如有一堆不连通子图</p><p>那么我们直接构建一个 S，分别连一下 $S-&gt;s_1, S-&gt;s_2, …, S-&gt;s_n, t_1-&gt;T, t_2-&gt;T, …, t_n-&gt;T$</p><h3 id="差分约束系统"><a href="#差分约束系统" class="headerlink" title="差分约束系统"></a>差分约束系统</h3><p>不等式 $x_j – x_i &lt;= b_k$</p><p>形式上等同于 $dist[v] &lt;= dist[u] + len(u, v)$</p><p>移一下项</p><p>$dist[v] – dist[u] &lt;= len(u, v)$</p><p>所以对于这个不等式，比如 $x_v – x_u &lt;= p$</p><p>那么连一条有向边，从 u 到 v，长度为 p</p><p>跑 SPFA，如果不能满足那么一定有负权回路（充要条件）</p><h1 id="最小生成树MST"><a href="#最小生成树MST" class="headerlink" title="最小生成树MST"></a>最小生成树MST</h1><p>一个有n个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有n个结点，并且有保持图连通的最少的边。</p><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p><strong>算法过程:</strong></p><ol><li>对边进行排序</li><li>按边的权值从小到大在<strong>不出现环</strong>的情况下加边</li></ol><p><strong>如何判断新加的边是否构成环?</strong></p><ul><li><p>判断新加的边的两个端点是否已经连通了</p></li><li><p>判断新加的边的两个端点是否在一个集合里</p></li><li><p>使用并查集</p><pre><code class="c++">int find(int x) &#123;
    return x == f[x] ? x : f[x] = find(f[x]);
&#125;
</code></pre></li></ul><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集是一种树形结构，又叫“不相交集合”，保持了一组不相交的动态集合，每个集合通过一个代表来识别，代表即集合中的某个成员，通常选择根做这个代表。</p><p><strong>并查集的操作：</strong></p><ul><li>合并：把两个不相交的集合合并为一个集合</li><li>查询：查询两个元素是否在同一个集合中</li></ul><p><strong>并查集的原理：</strong></p><p>并查集的思想是<strong>通过标记确定该顶点所在的组</strong></p><p>建立关系：</p><ol><li>初始化一个数组$father[i]$，使$father[i]=i$，表示最初时每个元素都是自己组的代表</li><li>对于任意两个元素$i,j$，若它们之间存在关系，则令$father[j]=i$（j所在的组的代表为i）</li><li>若存在元素$k$与$i，j$所在的组$x$有关系，则令$father[组x的代表元素]=k$</li><li>依此类推就建立好了一颗关系树，利用一维数组</li></ol><p>查找：</p><ul><li><p>判断任意两个元素$x，y$是否存在关系，我们只需要找到它们所在组的代表进行比较即可</p></li><li><p>对于任意一个为代表的元素来说，总存在$father[i]=i$，所以当$father[x]!=x$时，我们就继续查询元素$x$的father，直到查找到组代表为止</p></li><li><p>可以使用递归和循环两种方式完成</p><pre><code class="c++">int getFather(int x) &#123;
    return father[x] == x ? x : getFather(father[x]);
&#125;
int getFather(int x) &#123;
    while (f[x] != x)
        x = f[x];
    return x;
&#125;
</code></pre></li></ul><p><a href="#####kruskai%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF">例题</a></p><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p><strong>算法过程:</strong></p><ol><li>随便选一个点作为起始点</li><li>选择到当前已经访问过的点u最近的未访问点v</li><li>将v加入集合中，同时更新剩下的未访问点到访问点的距离</li><li>循环执行直到所有点都被访问过了</li></ol><p><strong>如何找v?</strong></p><ul><li>枚举所有点排序$O(n^3)$</li><li>堆优化$O(m,logn)$</li></ul><h1 id="数论基础"><a href="#数论基础" class="headerlink" title="数论基础"></a>数论基础</h1><h2 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h2><ul><li>如果整数a能被m整除，即$a=km$，那么记作$m|a$。</li><li>整除具有传递性，即$a|b，b|c$，那么$a|c$。</li><li>对于线性运算，整除性质仍然保持。即$a|b,b|c$，那么$a|kb+tc$。</li><li>如果$a|b,b|a$那么 a=b。</li></ul><h2 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h2><ul><li>设有两个数$a，b$，如果$m \mid (a-b)$，那么就称为a与b对模m同余，记作$a\equiv b(mod\ m)$</li><li>对于加减乘运算，同余的性质仍然保持，即$a \equiv b(mod m),\ ka+n \equiv kb+n (mod m)$</li><li>同样的，在只有加减乘运算的式子中可以随时取模。$(a+bk)\equiv(a\mod m+(b\mod m)\times(k\mod m))\ (mod\ m)$</li><li>$(a\mod m+m)\mod m$保证结果为正</li><li>$ac\equiv bc (mod\ m)$且c与m互质时$a \equiv b(mod m)$</li><li>$ac\equiv bc (mod\ m) \Rightarrow a \equiv b(mod\ m)$</li></ul><h2 id="gcd与lcm"><a href="#gcd与lcm" class="headerlink" title="gcd与lcm"></a>gcd与lcm</h2><ul><li><p>gcd</p><ul><li><p>n和m的最大公约数是满足$d\mid n$且$d\mid m$的最大的d。将其记为$gcd(n,m)$</p></li><li><p>若$gcd(n,m)=1$，则称n，m互质</p></li><li><p>辗转相除法（欧几里得算法）:</p><p><code>return n % m == 0 ? m : gcd(n % m, m)</code></p></li></ul></li><li><p>lcm</p><ul><li>n和m的最小公倍数是满足$n \mid D$且$m \mid D$的最小的D，记作$lcm(n,m)$</li><li><code>nm = gcd(n, m) * lcm(n, m)</code></li><li>注意不能写成<code>n * m / gcd</code>，最好写成<code>n / gcd * m</code>。</li></ul></li></ul><h2 id="裴蜀定理（贝祖定理）"><a href="#裴蜀定理（贝祖定理）" class="headerlink" title="裴蜀定理（贝祖定理）"></a>裴蜀定理（贝祖定理）</h2><ul><li>若a,b是整数,且$gcd(a,b)=d$，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使ax+by=d成立。</li><li>它的一个重要推论是:a,b互质的<strong>充要条件</strong>是存在整数x,y使$ax+by=1$</li></ul><h2 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h2><ul><li>exgcd可以用来判断并求解形如$ax +by =c$的方程，当且仅当$gcd(a,b)\mid c$时，存在整数解x, y。</li><li>也就是说，exgcd可以用来求解方程$ax +by = gcd(a, b)$</li><li>令$a =b, b = a\ %\ b$，则有方程$b\times x_1+(a\ %\ b)\times y1=gcd(b,a\ %\ b)$又因为$gcd (a,b)=gcd (b, a\ %\ b)$，且$a\ %\ b = a - b \times \left \lfloor \frac{a}{b} \right \rfloor$</li><li>则$b\times x_1+(a-b\times \left \lfloor \frac{a}{b} \right \rfloor)\times y_1= gcd(a,b)$</li><li>整理得:$a\times y_1+b\times (x_1-\left \lfloor \frac{a}{b} \right \rfloor\times y_1) =gcd (a,b)$</li><li>所以原方程中:$x = y_1,y = x_1-\left \lfloor \frac{a}{b} \right \rfloor \times y_1$。于是我们只要递归求出$x_1,\ y_1$就能求出$x_0,\ y_0$</li></ul><pre><code class="c++">int exgcd(int a, int b, int &amp;x, int &amp;y)
&#123;
    if (b == 0)
    &#123;
        x = 1, y = 0;
        return a;
    &#125;
    int q = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return q;
&#125;
</code></pre><h2 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h2><h3 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h3><p><strong>普通实现：</strong></p><pre><code class="c++">int vis[MAXN], p[MAXN], cnt;
//朴素筛
//筛出[2,n]之间的所有素数
//复杂度: O(nlogn)
void naive_sieve(int n)
&#123;
    for (int i = 2; i &lt;= n; i++)
    &#123;
        if (!vis[i])
            p[cnt++] = i;
        for (int j = i + 1; j &lt;= n; j++)
            vis[j] = 1;
    &#125;
&#125;
</code></pre><p><strong>优化：</strong></p><p>复杂度$O(n)$</p><pre><code class="c++">bool check[100005];
int prime[100005]; //储存第i个素数
void getprime(int n)
&#123;
    memset(check, 0, sizeof(check)); // 标记数组初始化，初始均为 0
    int tot = 0;                     // tot 初始为 0，用来记录质数总个数
    for (int i = 2; i &lt;= n; ++i)
    &#123;                                // 从 2 开始枚举
        if (!check[i])               // 如果 i 没有被划去，则 i 为质数，加入质数表中
            prime[++tot] = i;
        for (int j = 1; j &lt;= tot; ++j)
        &#123;                            // 划去 i 与所有已筛出的质数的乘积
            if (i * prime[j] &gt; n)    // 判断合数是否在区间内
                break;
            check[i * prime[j]] = 1; // 划去在区间内的合数
            if (i % prime[j] == 0)   // 保证合数只被其最小的质因子划去，提高筛选效率
                break;
        &#125;
    &#125;
&#125;
</code></pre><h3 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉<strong>筛</strong></h3><p><strong>欧拉函数:</strong></p><ul><li><p>完全剩余系:将所有模m同余的数成为一个等价类，那么显然对于m存在m个等价类，也被称为剩余类。从每个等价类中取出一个数组成一个集合，这个集合被称为模m的剩余系。最基础的剩余系即为0,1,……, m-1。完全剩余系也被称为完系。</p></li><li><p>简化剩余系:在模m的所有剩余类中，若存在一个数<strong>与m互质</strong>，则其被称作简化剩余类。从m的所有简化剩余类中取一个数出来组成一个集合，这个集合被称为模m的简化剩余系，也被称作缩系。一般即为从0,1,……, m-1中取出所有与m互质的数组成简化剩余系。</p></li><li><p>欧拉函数：$\phi (n)$表示从$1\sim n-1$中有多少个数与n互素。定义$\phi (1) =1$</p></li><li><p>欧拉函数的性质:</p><ol><li>如果p为质数,$\phi (n)p-1$。</li><li>又对于整数$n=p^{a_1}_1p^{a_2}_2…p^{a_n}<em>n,\ \phi (n)=x\prod</em>{i=1}^{n}(1-\frac{1}{p_i})$</li><li>如果p为质数且$n=p^k,\ \phi (n)=p^k-p^{k-1}$</li><li>欧拉函数为积性函数,即若m,n互质，则$\phi (mn)=\phi (m)\phi (n)$。</li><li>整数n的所有因数(包括1和他自己)的欧拉函数之和等于n。$n=\sum_{d\mid n}\phi (d)$</li><li>小于n的数中，与n互质的数的总和为:$\frac{\phi (n)\times n}{2}$</li></ol></li></ul><pre><code class="c++">void Init()
&#123;
    for (int i = 1; i &lt; MAX; i++)
        phi(i) = i;
    for (int i = 2; i &lt; MAX; i++)
        if (phi[i] == i)
            for (int j = i; j &lt; MAX; j += i)
                phi[j] = phi[j] / i * (i - 1);
&#125;
</code></pre><p><strong>欧拉线性筛:</strong></p><pre><code class="c++">void shai()
&#123;
    phi[1] = 1;
    for (int i = 2, tot = 0; i &lt;= n; i++)
    &#123;
        if (!vis[i])
            pri[++tot] = i, phi[i] = i - 1;
        for (int j = 1, m; j &lt;= tot &amp;&amp; (m = i * pri[j]) &lt;= n; j++)
        &#123;
            vis[m] = 1;
            if (i % pri[j] == 0)
            &#123;
                phi[m] = phi[i] * pri[j];
                break;
            &#125;
            else
                phi[m] = phi[i] * (pri[j] - 1);
        &#125;
    &#125;
&#125;
</code></pre><h2 id="数论四大定理"><a href="#数论四大定理" class="headerlink" title="数论四大定理"></a>数论四大定理</h2><p><img data-src="Users\10051\AppData\Roaming\Typora\typora-user-images\image-20210420210734640.png" alt="image-20210420210734640"></p><h2 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h2><p><img data-src="Users\10051\AppData\Roaming\Typora\typora-user-images\image-20210420210808179.png" alt="image-20210420210808179"></p><h2 id="欧拉降幂公式"><a href="#欧拉降幂公式" class="headerlink" title="欧拉降幂公式"></a>欧拉降幂公式</h2><p><img data-src="Users\10051\AppData\Roaming\Typora\typora-user-images\image-20210420210852955.png" alt="image-20210420210852955"></p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><pre><code class="c++">int fast_pow(int a, int n)
&#123;
    int res = 1, tmp = a;
    while (n &gt; 0)
    &#123;
        if (n &amp; 1)
            res = res * tmp;
        tmp = tmp * tmp;
        n &gt;&gt;= 1;
    &#125;
    return res;
&#125;
</code></pre><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h5 id="权力指数"><a href="#权力指数" class="headerlink" title="权力指数"></a>权力指数</h5><p><img data-src="Users\10051\AppData\Roaming\Typora\typora-user-images\image-20210316105816771.png" alt="image-20210316105816771"></p><pre><code class="c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
int a[20], ans[20], sum = 0, n;
float mid;
bool ext[20];
void dfs(int nowSum, int now) &#123;
    if (now == n)
    &#123;
        if (nowSum &lt; mid)
            return;
        for (int i = 0; i &lt; n; i++)
            if (ext[i] &amp;&amp;nowSum - a[i] &lt; mid)
                ans[i]++;
    &#125;
    else &#123;
        ext[now] = true;
        dfs(nowSum, now + 1);
        ext[now] = false;
        dfs(nowSum - a[now], now + 1);
    &#125;    
&#125;

int main()
&#123;
    int T;
    cin &gt;&gt; T;
    for (int l = 0; l &lt; T; l++)
    &#123;
        cin &gt;&gt; n;
        sum = 0;
        for (int i = 0; i &lt; n; i++) &#123;
            cin &gt;&gt; a[i];
            sum += a[i];
        &#125;
        mid = sum / 2.0;

        memset(ans, 0, n * sizeof(int));
        dfs(sum, 0);

        for (int i = 0; i &lt; n; i++) &#123;
            if (i == 0)
                cout &lt;&lt; ans[i];
            else
                cout &lt;&lt; &quot; &quot; &lt;&lt; ans[i];
        &#125;
        cout &lt;&lt; endl;
    &#125;
&#125;
</code></pre><h5 id="1-2"><a href="#1-2" class="headerlink" title="1-2"></a>1-2</h5><p><img data-src="Users\10051\AppData\Roaming\Typora\typora-user-images\image-20210316110911010.png" alt="image-20210316110911010"></p><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
using namespace std;

int arr[10][10];
int x[10];
int sum;

int Gauss(int m, int n)//矩阵行数列数
&#123;
    int row = 0, col = 0;
    while (row &lt; m &amp;&amp; col &lt; n)
    &#123;
        if (arr[row][col] == 0)
            for (int i = row + 1; i &lt; m; i++)
                if (arr[i][col])
                    for (int j = col; j &lt;= n; j++)
                        swap(arr[i][j], arr[row][j]);

        if (arr[row][col] == 0)
        &#123;
            col++;
            continue;
        &#125;

        for (int i = row + 1; i &lt; m; i++) 
            if (arr[i][col])
            &#123;
                //因为这里使用的是int型,所以消列首元素不一定为1
                int ta = arr[i][col];//被消列首元素大小
                int tb = arr[row][col];//消列首元素大小
                for (int j = col; j &lt;= n; j++)
                &#123;
                    arr[i][j] = arr[i][j] * tb - arr[row][j] * ta;//使被消列首元素为0
                    arr[i][j] = (arr[i][j] % 4 + 4) % 4;//使该数亦然在0-4范围内
                &#125;
            &#125;
        row++;
        col++;
    &#125;

    for (int i = n - 1; i &gt;= 0; i--)
    &#123;
        int temp = arr[i][n];
        for (int j = i + 1; j &lt; n; j++) 
            if (arr[i][j])
                temp -= arr[i][j] * x[j];
        temp = (temp % 4 + 4) % 4;

        //此处开始枚举
        for (x[i] = 0; x[i] &lt;= 3; x[i]++)  // 转5次和转1次没区别，所以只有4种
            if ((x[i] * arr[i][i] % 4 + 4) % 4 == temp) // 依题意必定有解,所以找到解之后回代到上面去继续求其他未知数的值qwqq
                break;
        sum += x[i];
    &#125;
    return 0;
&#125;

int main()
&#123;
    //    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);

    arr[0][0] = arr[1][0] = arr[3][0] = arr[4][0] = 1;
    arr[0][1] = arr[1][1] = arr[2][1] = 1;
    arr[1][2] = arr[2][2] = arr[4][2] = arr[5][2] = 1;
    arr[0][3] = arr[3][3] = arr[6][3] = 1;
    arr[1][4] = arr[3][4] = arr[4][4] = arr[5][4] = arr[7][4] = 1;
    arr[2][5] = arr[5][5] = arr[8][5] = 1;
    arr[3][6] = arr[4][6] = arr[6][6] = arr[7][6] = 1;
    arr[6][7] = arr[7][7] = arr[8][7] = 1;
    arr[4][8] = arr[5][8] = arr[7][8] = arr[8][8] = 1;

    for (int i = 0; i &lt; 9; i++)
    &#123;
        scanf(&quot;%d&quot;, &amp;arr[i][9]);
        arr[i][9] = (4 - arr[i][9]) % 4; // 将钟的位置转化为要转的次数
    &#125;
    Gauss(9, 9);
    for (int j = 0; j &lt; 9; j++)
        while (x[j])
        &#123;
            printf(&quot;%d&quot;, j + 1);
            x[j]--;
            sum--;
            printf(sum &gt; 0 ? &quot; &quot; : &quot;\n&quot;);
        &#125;
&#125;
</code></pre><h5 id="1-3"><a href="#1-3" class="headerlink" title="1-3"></a>1-3</h5><p><img data-src="Users\10051\AppData\Roaming\Typora\typora-user-images\image-20210316111158152.png" alt="image-20210316111158152"></p><pre><code class="c++">#include &lt;iostream&gt;
#include&lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;string&gt;
using namespace std;
map&lt;string, int&gt; my;
int N, Map[10], restCard[10];
string ans;
char tab[7][20];
bool win;
void check()
&#123;
    int eneny[] = &#123; 0,1,2,3,4,5,6 &#125;;
    //cout&lt;&lt;n&lt;&lt;&quot;  &quot;&lt;&lt;endl;
    do &#123;
        int i = 0, j = 0;
        while (i &lt; N &amp;&amp; j &lt; N)
        &#123;
            if (1 &lt;&lt; Map[i] &amp; restCard[eneny[j]]) i++;
            else j++;
        &#125;
        if (i == N) return;
    &#125; while (next_permutation(eneny, eneny + N));
    string tmp = &quot;&quot;;
    for (int i = 0; i &lt; N; i++)
    &#123;
        if (i) tmp += &quot; &quot;;
        tmp += string(tab[Map[i]]);
    &#125;
    win = true;
    if (ans == &quot;&quot; || ans &gt; tmp) ans = tmp;
&#125;
int main()
&#123;
    int t, ncas = 1;
    scanf(&quot;%d&quot;, &amp;t);
    for (; ncas &lt;= t; ncas++)
    &#123;
        char name[20];
        scanf(&quot;%d&quot;, &amp;N);
        for (int i = 0; i &lt; N; i++)
        &#123;
            getchar();
            scanf(&quot;%s&quot;, name);
            strcpy(tab[i], name);
            my[string(name)] = i;
        &#125;
        memset(restCard, 0, sizeof(restCard));
        for (int i = 0; i &lt; N; i++)
        &#123;
            int m;
            scanf(&quot;%d&quot;, &amp;m);
            getchar();
            for (int j = 0; j &lt; m; j++)
            &#123;
                scanf(&quot;%s&quot;, name);
                restCard[i] |= 1 &lt;&lt; my[string(name)];
            &#125;
        &#125;
        win = false;
        for (int i = 0; i &lt; N; i++)
            Map[i] = i;
        ans = &quot;&quot;;
        do &#123;
            check();
        &#125; while (next_permutation(Map, Map + N));
        printf(&quot;Case %d: &quot;, ncas);
        puts(win ? &quot;Yes&quot; : &quot;No&quot;);
        if (win)
            cout &lt;&lt; ans &lt;&lt; endl;
    &#125;
    system(&quot;PAUSE&quot;);
    return 0;
&#125;
</code></pre><h5 id="高斯消元模板"><a href="#高斯消元模板" class="headerlink" title="高斯消元模板"></a>高斯消元模板</h5><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzODk=">洛谷p3389</span></p><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;

const int MAXN = 1000;
const double eps = 1e-10;
void swap(double&amp; a, double&amp; b)
&#123;
    double tmp = a;
    a = b;
    b = tmp;
&#125;

int n;//矩阵的阶数
double arr[MAXN][MAXN];//矩阵及增广矩阵
double ans[MAXN];//答案向量
int gauss() &#123;
    int r, c;//row, column
    for (r = 0, c = 0; c &lt; n; c++)                              //现在在消第c列的元
    &#123;                            
        int t = r;                                              //这里找到第c列r行及其之下中最大非0元素,将其行与目前行交换
        for (int i = r; i &lt; n; i++)
            if (fabs(arr[i][c]) &gt; fabs(arr[t][c])) t = i;
        if (fabs(arr[t][c]) &lt; eps) continue;                    //此处判断是否该列第r行及其以下所有元素是否均为0,若均为0则不需要消元
        for (int i = c; i &lt;= n; i++) swap(arr[t][i], arr[r][i]);//交换两行,这里包括增广矩阵的一列,所以为&#39;&lt;=n&#39;
        for (int i = n; i &gt;= c; i--) arr[r][i] /= arr[r][c];    //从后往前依此除以该行第一个非0元素,将该非0元素变成1

        //此处开始消元
        for (int i = r + 1; i &lt; n; i++)                         //从第r+1行开始,下面每一行减去r行的对应倍数使首非0元素为0
            if (fabs(arr[i][c]) &gt; eps)
                for (int j = n; j &gt;= c; j--)
                    arr[i][j] -= arr[r][j] * arr[i][c];         //这里就是第i行减去 arr[i][c]*第r行 使得arr[i][c] -= arr[i][c] * arr[r][c] (arr[r][c]=1)

        r++;                                                    //切换到下一行
    &#125;
    //此处消元结束，r即为矩阵的行秩，判断是否有解
    if (r &lt; n)                                                  //行秩小于行数，判断增广矩阵中最后一列在r行之后是否有非0数
    &#123;                                                           //若无则方程有无数解，若有则方程无解
        for (int i = r; i &lt; n; i++)
            if (arr[i][n]) return 0;//无解
        return 1;//有无数解
    &#125;
    //行满秩，m=n
    for (int i = n - 1; i &gt;= 0; i--)                            //回代求解
        for (int j = i + 1; j &lt; n; j++)                         
            arr[i][n] -= arr[i][j] * arr[j][n];
    for (int i = 0; i &lt; n; i++)
        ans[i] = arr[i][n];
    return 2;//有唯一解
&#125;
int main()
&#123;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i++)
        for (int j = 0; j &lt;= n; j++)
            scanf(&quot;%lf&quot;, &amp;arr[i][j]);
    int a = gauss();
    if (a != 2) cout &lt;&lt; &quot;No Solution&quot; &lt;&lt; endl;
    else
    &#123;
        for (int i = 0; i &lt; n; i++)
            printf(&quot;%.2lf\n&quot;, ans[i]);
    &#125;
    return 0;
&#125;
</code></pre><h5 id="2-1"><a href="#2-1" class="headerlink" title="2-1"></a>2-1</h5><p>百慕大的每一座城市都坐落在一维直线上。这个国家的政府决定建造一个新的广播电视台。经过了许多次试验后，百慕大的科学家们提出了一个结论，在每座城市的不满意度等于这座城市的市民数与这座城市与广播电视台的距离的乘积。找到这个一维直线上的一点来建造广播电视台，使得所有城市的不满意度的和最小。</p><p>Input</p><p>Input begins from line with integer positive number N (0&lt;N&lt;15000) – amount of cities in Berland. Following N pairs (X, P) describes cities (0&lt;X, P&lt;50000), where X is a coordinate of city and P is an amount of citizens. All numbers separated by whitespace(s).</p><p>Output</p><p>Write the best position for TV-station with accuracy 10-5.</p><p>Sample Input</p><p>4<br>1 3<br>2 1<br>5 2<br>6 2<br>Sample Output</p><p>3.00000</p><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;

int n, sum = 0;
struct city &#123;
    double distance;
    int people;
&#125;cities[15010];

int main() &#123;

    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++) &#123;
        scanf(&quot;%lf%d&quot;, &amp;cities[i].distance, &amp;cities[i].people);
        sum += cities[i].people;
    &#125;
    sort(cities + 1, cities + n + 1, [](city a, city b) &#123;
        return a.distance &lt; b.distance;
        &#125;);

    sum = sum / 2 + 1;

    int tmp = 0;
    for (int i = 1; i &lt;= n; i++) &#123;
        tmp += cities[i].people;
        if (tmp &gt;= sum) &#123;//权值大于一半则结束
            printf(&quot;%.5lf\n&quot;, cities[i].distance);
            return 0;
        &#125;
    &#125;
&#125;
</code></pre><h5 id="2-2"><a href="#2-2" class="headerlink" title="2-2"></a>2-2</h5><p>【POJ1700】Crossing River</p><p>题意：一群人过河，船每次只能装两人，每次过河时间为两人权值较大的那个。</p><p>本题的两种策略则是</p><ol><li>耗时最短的人一直在船上来回送人</li><li>耗时最短的来回送船，然后俩耗时最长的一起走。（实现：最短送船回来，俩人过去，次短来接最短过岸）</li></ol><p>这样就又满足了一个性质，就是影响答案的几种条件都可以有针对策略时，我们将它们都进行选择，然后再加一些在几种条件之间进行妥协的策略，即牺牲某条件，迎合另一个条件的一系列策略。这样基本就是，或者说就已经是绝对正确的代码了。</p><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 1005;
int time[N], timeNow[N], n;
int main()
&#123;
    //freopen(&quot;in&quot;, &quot;r&quot;, stdin);
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while (T--)
    &#123;
        scanf(&quot;%d&quot;, &amp;n);
        for (int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;, &amp;time[i]);
        sort(time + 1, time + n + 1);
        timeNow[1] = time[1], timeNow[2] = time[2];
        //timeNow[i]表示送过去i个人所用的最小时间
        int ta, tb;//两种策略达到下一个相同状态使用的时间
        for (int i = 3; i &lt;= n; i++)
        &#123;
            ta = timeNow[i - 1] + time[i] + time[1];
            //该策略循环一次送一个人
            tb = timeNow[i - 2] + time[1] + time[2] + time[i] + time[2];
            //该策略循环一次送两个人,time[i]的人把time[i-1]的人带上了
            timeNow[i] = min(ta, tb);
        &#125;
        printf(&quot;%d\n&quot;, timeNow[n]);
    &#125;
    return 0;
&#125;
</code></pre><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZtdXJkZXIvYXJ0aWNsZS9kZXRhaWxzLzQwODI2MTUxP3V0bV9tZWRpdW09ZGlzdHJpYnV0ZS5wY19yZWxldmFudC5ub25lLXRhc2stYmxvZy1CbG9nQ29tbWVuZEZyb21NYWNoaW5lTGVhcm5QYWkyLTEuY29udHJvbCZkaXN0X3JlcXVlc3RfaWQ9JmRlcHRoXzEtdXRtX3NvdXJjZT1kaXN0cmlidXRlLnBjX3JlbGV2YW50Lm5vbmUtdGFzay1ibG9nLUJsb2dDb21tZW5kRnJvbU1hY2hpbmVMZWFyblBhaTItMS5jb250cm9s">参考</span></p><h5 id="poj1190"><a href="#poj1190" class="headerlink" title="poj1190"></a>poj1190</h5><p>由于深度一定(m),所以使用深度优先搜索,自上而下的设定蛋糕序号,最顶层的为第1层,……,最底层的蛋糕为第m层,很明显满足题目条件的前i层的(从顶层(也就是编号为1的层)开始计数)最小面积$mins[i]$和体积$minv[i]$是在该层的半径以及高度都为i时取得,如果采用一般的dfs肯定会超时,所以这题还需要剪枝,剪枝条件有(从m层向上搜,假设前dep层的体积为sumv,面积为sums,当前所得的最小面积为best):</p><ol><li>因为前dep层的体积为sumv,如果剩下的几层的体积都取最小可能值,总体积还是比n大,那么则说明前dep层的方案不可行,所以可以剪枝(剪枝条件为:$sumv+minv[dep-1]&gt;n$)</li><li>因为前dep层的面积为sums,如果剩下的几层的面积都取最小可能值,所得的面积和比已经得到的所求的最小面积best大,也可以进行剪枝(剪枝条件为:$sums+mins[dep-1]&gt;best$)</li><li>因为前dep层的体积为sumv,那么剩余的m-dep层的体积满足:$n-sumv=(h[k]<em>(r[k]^2)+……+h[m]</em>(r[m]^2)) (k=dep+1,……,m)$，而剩余部分的表面积满足:$lefts=2*(r[k]<em>h[k]+……+r[m]<em>h[m])&gt;2</em>(n-sumv)/r[dep] (k=dep+1,……,m)$<br>显然有上述不等式$lefts=best-sums&gt;2</em>(n-sumv)/r$,即$2*(n-sumv)/r+sums&lt;best$,所以当$2*(n-sumv)/r[i]+sums&gt;=best$时也可以进行剪枝.</li></ol><pre><code class="c++">//我的剪枝太菜了qwqqq,会超时qwqq
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
using namespace std;
const int maxn = 25;
int N, M, ans = 0x7fffffff;
int sizeMin(int, int, int, int);
void dfs(int now, int r, int h, int nowSize, int nowArea) //从上往下数现在第几层
&#123;
    if (nowArea &gt; ans)
        return;
    else if (now == M + 1)
    &#123;
        if (nowSize == N)//体积刚好为N
        &#123;
            nowArea += r * r;//表面积加上顶面的面积
            if (nowArea &lt; ans)
                ans = nowArea;//存在更优解,替换解
        &#125;
    &#125;
    else
    &#123;
        for (int i = r + 1; i &lt; sqrt(static_cast&lt;float&gt;(N)); i++)
        &#123;
            if (sizeMin(i, h + 1, now, nowSize) &gt; N)
                break;
            for (int j = h + 1; j &lt; sqrt(static_cast&lt;float&gt;(N)); j++)
            &#123;
                if (j != h + 1 &amp;&amp; sizeMin(i, j, now, nowSize) &gt; N)
                &#123;
                    break;
                &#125;
                else
                    dfs(now + 1, i, j, nowSize + i * i * j, nowArea + 2 * i * j);
            &#125;
        &#125;
    &#125;
&#125;
int sizeMin(int ri, int hi, int now, int size)//计算当前r,h取值下最小体积 
&#123;
    int sum = size;
    for (int i = now; i &lt;= M; i++) &#123;
        sum += ri * ri * hi;
        ri += 1, hi += 1;
    &#125;
    return sum;
&#125;//这个每次检验都要计算一次,消耗大量时间qwqq
int main()
&#123;
    //freopen(&quot;in&quot;, &quot;r&quot;, stdin);
    scanf(&quot;%d%d&quot;, &amp;N, &amp;M);
    for (int r = 1; r &lt; N; r++) &#123;
        if (r, 1, 1, 0 &gt; N)
            break;
        for (int h = 1; h &lt; N; h++)
        &#123;
            if (h!=1&amp;&amp;sizeMin(r, h, 1, 0) &gt; N)
                break;
            else
                dfs(2, r, h, r * r * h, 2 * r * h);
        &#125;
    &#125;
    if (ans == 0x7fffffff)
        printf(&quot;0&quot;);
    else
        printf(&quot;%d&quot;, ans);
    return 0;
&#125;
//----------------------------------------
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;
int ans=0x7fffffff,minv[25], mins[25],n, m;
//这种用于验证的数据最好最开始就算出来,然后用数组存起来qwqq

void dfs(int sumv, int sums, int now, int r, int h)
&#123;
    int realh;
    if (now == 0)
    &#123;
        if (sumv == n &amp;&amp; sums &lt; ans)
        &#123;
            ans = sums;
            return;
        &#125;
    &#125;
    if (sumv + minv[now - 1] &gt; n || sums + mins[now - 1] &gt; ans || 2 * (n - sumv) / r + sums &gt;= ans)
    &#123;
        return;
    &#125;
    for (int i = r - 1; i &gt;= now; --i)
    &#123;
        if (now == m)
        &#123;
            sums = i * i;
        &#125;
        realh = min((n - minv[now - 1] - sumv) / (i * i), h - 1);
        for (int j = realh; j &gt;= now; --j)
        &#123;
            dfs(sumv + i * i * j, sums + 2 * i * j, now - 1, i, j);
        &#125;
    &#125;

&#125;
int main()
&#123;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    minv[0] = mins[0] = 0;
    for (int i = 1; i &lt;= m; ++i)
    &#123;
        minv[i] = minv[i - 1] + i * i * i;
        mins[i] = mins[i - 1] + 2 * i * i;
    &#125;
    dfs(0, 0, m, n + 1, n + 1);
    if (ans == 0x7fffffff)
    &#123;
        printf(&quot;0\n&quot;);
    &#125;
    else
        printf(&quot;%d\n&quot;, ans);
    return 0;
&#125;
</code></pre><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nMjAwNzI4NDQvYXJ0aWNsZS9kZXRhaWxzLzc0NzE1Mjg/dXRtX21lZGl1bT1kaXN0cmlidXRlLnBjX3JlbGV2YW50Lm5vbmUtdGFzay1ibG9nLWJhaWR1anNfdGl0bGUtMCZzcG09MTAwMS4yMTAxLjMwMDEuNDI0Mg==">参考</span></p><p>还有更猛的qwqq：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbmNsZS9hcnRpY2xlL2RldGFpbHMvNzAxNjE5MQ==">估值函数</span></p><h5 id="5-1"><a href="#5-1" class="headerlink" title="5-1"></a>5-1</h5><p><img data-src="Users\10051\AppData\Roaming\Typora\typora-user-images\image-20210329111335189.png" alt="image-20210329111335189"></p><p>关键就是拆数,一直向下拆会发现最终都可以用$A_1$来表示,高精 py yyds qwqqq</p><pre><code class="python">def f(a, na, b, nb):
    if a == 1:
        print(na)
        return
    if a &amp; 1: # 根据a的奇偶性拆数
        f(a // 2 + 1, na, b // 2, na + nb)
    else:
        f(a // 2, na + nb, b // 2, nb)


if __name__ == &#39;__main__&#39;:
    T = int(input())
    for i in range(0, T):
        num = int(input())
        while num % 2 == 0:
            num //= 2
        f(num // 2 + 1, 1, num // 2, 1)
</code></pre><h5 id="聪明的学生"><a href="#聪明的学生" class="headerlink" title="聪明的学生"></a>聪明的学生</h5><p><img data-src="Users\10051\AppData\Roaming\Typora\typora-user-images\image-20210330201828515.png" alt="image-20210330201828515"></p><pre><code class="c++">#include &lt;cstdio&gt;
using namespace std;
const int maxn = 3e4 + 111;
int N, M;
int next[3] = &#123;1, 2, 0&#125;, last[3] = &#123;2, 0, 1&#125;;
int ans[maxn][3];
int dfs(int x, int y, int now)//A对应t=0，B对应t=1，C对应t=2
&#123;
    if (x == y)
        return now + 1;//加上猜出来的那一轮
    else
        return x &gt; y ?
        dfs(y, x - y, next[now]) + 2//转一圈回来，所以加2 
        : dfs(y - x, x, last[now]) + 1;//直接下一个
&#125;
int main()
&#123;
    // freopen(&quot;in&quot;, &quot;r&quot;, stdin);
    // freopen(&quot;out&quot;, &quot;w&quot;, stdout);
    while (~scanf(&quot;%d%d&quot;, &amp;N, &amp;M))
    &#123;
        if (N == -1)
            break;
        //计算是a、b还是c最后猜出，第N轮可得出结论，不用猜，所以（N-1）%3为猜出数字的人的编号
        int p0 = (N - 1) % 3, p1 = next[p0], p2 = last[p0];

        int cnt = 0;
        for (int i = 1; i &lt; M; i++)
            if (dfs(i, M - i, p0) == N)
                ans[++cnt][p0] = M, ans[cnt][p1] = i, ans[cnt][p2] = M - i;

        printf(&quot;%d\n&quot;, cnt);

        if (p0 != 1)
            for (int i = 1; i &lt;= cnt; i++)
                printf(&quot;%d %d %d\n&quot;, ans[i][0], ans[i][1], ans[i][2]);
        else
            for (int i = cnt; i &gt;= 1; i--)
                printf(&quot;%d %d %d\n&quot;, ans[i][0], ans[i][1], ans[i][2]);
    &#125;
    return 0;
&#125;
</code></pre><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvU0hFRVAtQk9MRy9zb2x1dGlvbi1wNTc3OQ==">参考</span></p><h5 id="火柴排队"><a href="#火柴排队" class="headerlink" title="火柴排队"></a>火柴排队</h5><p><img data-src="Users\10051\AppData\Roaming\Typora\typora-user-images\image-20210330202813078.png" alt="image-20210330202813078"></p><p>一个小结论,一个数列的<strong>逆序数</strong>等于<strong>使用冒泡排序将其排序</strong>后的<strong>交换次数</strong></p><p><a href="./%E6%8E%92%E5%BA%8F.md">排序</a>里面的归并排序可以计算逆序数,但那里的写法是申请空间,这里是直接开数组qwqq</p><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
const int MAXN = 1e5 + 5, Mod = 99999997;
struct Node
&#123;
    int X, num;
&#125;;
Node a[MAXN], b[MAXN];
int c[MAXN], Merge[MAXN]; //数组c中记录ai在bi中出现的位置
int n, ans;
bool cmp(Node x, Node y)
&#123;
    return x.X &lt; y.X;
&#125;
void merge_sort(int l, int r)
&#123; //归并
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    merge_sort(l, mid);
    merge_sort(mid + 1, r);
    int flag = l, i = l, j = mid + 1;
    while (i &lt;= mid &amp;&amp; j &lt;= r)
    &#123;
        if (c[i] &lt;= c[j])
        &#123;
            Merge[flag] = c[i];
            flag++;
            i++;
        &#125;
        else
        &#123;
            Merge[flag] = c[j];
            flag++;
            j++;
            ans = (ans + (mid - i + 1)) % Mod;
        &#125;
    &#125;
    while (i &lt;= mid)
    &#123;
        Merge[flag] = c[i];
        i++;
        flag++;
    &#125;
    while (j &lt;= r)
    &#123;
        Merge[flag] = c[j];
        j++;
        flag++;
    &#125;
    for (int i = l; i &lt;= r; i++)
        c[i] = Merge[i];
&#125;
int main()
&#123;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++)
    &#123;
        scanf(&quot;%d&quot;, &amp;a[i].X);
        a[i].num = i; //将数列离散化
    &#125;
    for (int i = 1; i &lt;= n; i++)
    &#123;
        scanf(&quot;%d&quot;, &amp;b[i].X);
        b[i].num = i;
    &#125;
    //这里排序是因为若不进行排序，b数列为无序，便不好用归并排序求其逆序数qwqq
    sort(a + 1, a + 1 + n, cmp);
    sort(b + 1, b + 1 + n, cmp);
    //将ai在bi中出现的位置记录下来，对其排序即能得到将ai变成bi需要交换的次数
    for (int i = 1; i &lt;= n; i++)
    &#123;
        c[a[i].num] = b[i].num;
    &#125;
    merge_sort(1, n);
    printf(&quot;%d&quot;, ans);
    return 0;
&#125;
</code></pre><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NsZXZlcl9IYXJkL2FydGljbGUvZGV0YWlscy8xMDcyNTM3NTk=">参考</span></p><h5 id="Point-on-Plane"><a href="#Point-on-Plane" class="headerlink" title="Point on Plane"></a>Point on Plane</h5><p><img data-src="Users\10051\AppData\Roaming\Typora\typora-user-images\image-20210331215522518.png" alt="image-20210331215522518"></p><p>此处dist可以看作莫队中表示$l,r$的指针分别移动的距离,普通莫队的优化中正好使这个距离达到一个相对较小的情况,所以直接使用莫队对x分块奇偶排序,然后按照y的升降序访问便是一条使移动数相对较小的路径了qwqq</p><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
const int maxn = 1e6 + 5, divLen = 1000;//分块长度为sqrt(maxn)
int n, distance;
struct node
&#123;
    int x, y, id, divId;
&#125;;
node point[maxn];
int dist(node a,node b)&#123;
    return abs(a.x - b.x) + abs(a.y - b.y);
&#125;
int main()
&#123;
    //freopen(&quot;in&quot;, &quot;r&quot;, stdin);
    //freopen(&quot;out&quot;, &quot;w&quot;, stdout);
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1;i&lt;=n;i++)
    &#123;
        scanf(&quot;%d %d&quot;, &amp;point[i].x, &amp;point[i].y);
        point[i].id = i;
        point[i].divId = (point[i].x - 1) / divLen + 1; //计算所在块的id
    &#125;
    
    sort(point + 1, point + 1 + n, [](node a, node b) &#123;
        return a.x &lt; b.x;
    &#125;);
    /*
     *主要思想就是分治
     *将大块分为多个小块，每个小块中取相对较短的路径
     *为了避免多次从第p块的最高点走到第p+1块的最低点
     *对其进行优化，使偶数块按y升序走，奇数块按y降序走，即可避免
     */
    sort(point + 1, point + 1 + n, [](node a, node b) &#123;
        if(a.divId!=b.divId)//按块序号升序排序
            return a.divId &lt; b.divId;
        if(a.divId&amp;1)//块编号为奇数,块内按y升序排列
            return a.y &lt; b.y;
        else//为偶数，按y降序排列
            return a.y &gt; b.y;
    &#125;);
    for (int i = 1; i &lt; n;i++)
        printf(&quot;%d &quot;, point[i].id);
    printf(&quot;%d\n&quot;, point[n].id);
    return 0;
&#125;
</code></pre><h5 id="Electric-Charges"><a href="#Electric-Charges" class="headerlink" title="Electric Charges"></a>Electric Charges</h5><p><img data-src="Users\10051\AppData\Roaming\Typora\typora-user-images\image-20210401090022280.png" alt="image-20210401090022280"></p><p>二分答案,问题转化为是否存在一个划分方案使得</p><p>$$\left{\begin{aligned}\max_{i\in X}{x_i^2}+\max_{i\in Y}{y_i^2}\leq mid\\max_{i,j\in X}{x_i-x_j}\leq \sqrt{mid}\\max_{i,j\in Y}{y_i-y_j}\leq \sqrt{mid}\end{aligned}\right.$$</p><p>其中 $X$为映射在 $x$轴上的点的集合, $Y $为映射在 $y $轴上的点的集合</p><p>将点按$x$排序</p><p>显然,如果存在方案,一定存在使得 $X$中的点编号<strong>连续</strong>的划分方案</p><p>枚举钦定一个点作为 $X$中产生贡献的那个点,将尽可能多的点划分进 $X$ 中,将剩下的点划分进$Y$,通过预处理前缀 $\min$,前缀 $\max$,后缀$\min$,后缀$\max$可以$O(1)$计算这部分的贡献</p><pre><code class="c++">#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
using namespace std;
const int maxn = 1e5 + 7;
long long lmin[maxn], rmin[maxn];
long long lmax[maxn], rmax[maxn];
pair&lt;long long, long long&gt; point[maxn];
long long xmin, xmax, ymin, ymax;
int n;
long long sq(long long x)
&#123;
    return x * x;
&#125;
bool check(long long mid)
&#123;
    int r = 1;
    for (int l = 1; l &lt;= n; l++)
    &#123;
        if (point[l].first &gt; 0)
            break;
        while (r &lt; n &amp;&amp;
               sq(point[r + 1].first - point[l].first) &lt;= mid &amp;&amp;
               abs(point[r + 1].first) &lt;= abs(point[l].first))
            r++;
        while (abs(point[r].first) &gt; abs(point[l].first))
            r--;
        long long low = min(lmin[l - 1], rmin[r + 1]);
        long long high = max(lmax[l - 1], rmax[r + 1]);
        if (sq(high - low) &lt;= mid &amp;&amp;
            sq(max(abs(low), abs(high))) + sq(max(abs(point[l].first), abs(point[r].first))) &lt;= mid)
            return true;
    &#125;
    int l = n;
    for (int r = n; r &gt;= 1; r--)
    &#123;
        if (point[r].first &lt; 0)
            break;
        while (l &gt; 1 &amp;&amp;
               sq(point[l - 1].first - point[r].first) &lt;= mid &amp;&amp;
               abs(point[l - 1].first) &lt;= abs(point[r].first))
            l--;
        while (abs(point[l].first) &gt; abs(point[r].first))
            l++;
        long long low = min(lmin[l - 1], rmin[r + 1]);
        long long high = max(lmax[l - 1], rmax[r + 1]);
        if (sq(high - low) &lt;= mid &amp;&amp;
            sq(max(abs(low), abs(high))) + sq(max(abs(point[l].first), abs(point[r].first))) &lt;= mid)
            return true;
    &#125;
    return false;
&#125;
int main()
&#123;
    xmin = ymin = 1e16, xmax = ymax = -1e16;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++)
    &#123;
        scanf(&quot;%lld%lld&quot;, &amp;point[i].first, &amp;point[i].second);
        //记录最大小值
        xmin = min(xmin, point[i].first);
        xmax = max(xmax, point[i].first);
        ymin = min(ymin, point[i].second);
        ymax = max(ymax, point[i].second);
    &#125;
    //x为第一关键字,y为第二关键字排序
    sort(point + 1, point + 1 + n);
    /*
     * 预处理从第1个点起到第i个点结束(从左边起到i结束)
     * 的点中最大的y值和最小的y值
     */
    for (int i = 1; i &lt;= n; i++)
    &#123;
        lmin[i] = min(point[i].second, lmin[i - 1]);
        lmax[i] = max(point[i].second, lmax[i - 1]);
    &#125;
    /*
     * 预处理从第n个点起到第i个点结束(从右边起到i结束)
     * 的点中最大的y值和最小的y值
     */
    for (int i = n; i &gt;= 1; i--)
    &#123;
        rmin[i] = min(point[i].second, rmin[i + 1]);
        rmax[i] = max(point[i].second, rmax[i + 1]);
    &#125;
    //二分答案
    long long l = -1, r = min(sq(xmax - xmin), sq(ymax - ymin)), ans = r;
    while (l &lt;= r)
    &#123;
        long long mid = (l + r) / 2;
        if (check(mid))
            ans = mid, r = mid - 1;
        else
            l = mid + 1;
    &#125;
    printf(&quot;%lld\n&quot;, ans);
&#125;
</code></pre><h5 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h5><p><img data-src="Users\10051\AppData\Roaming\Typora\typora-user-images\image-20210404150949833.png" alt="image-20210404150949833"></p><p>$dp[i][j]$表示前$i$个物体$(1≤ i ≤N)$在背包承重为$j$时，所能达到的最大价值</p><p>对于第$i$个物品，$w[i]$为它的重量，$p[i]$为它的价值</p><p>可得递推公式为$$dp[i][j]=\left{\begin{matrix}<br>max(dp[i][j],dp[i-1][j-w[i]]+p[i]) &amp; i\geqslant 1,j\geqslant 1\<br>0 &amp; i=0 ,or, j=0<br>\end{matrix}\right.$$</p><p>说人话就是对于每个物品（第$i$个物品），我们从小到大枚举最大承重量$j,(W\geqslant j\geqslant w[i])$，<strong>更新</strong>每个最大承重量能够取到的最大值</p><p><strong>空间优化：</strong></p><p>我们发现实际上对于每一个$dp[i][x]$，我们都是通过$dp[i-1][y]$求得，所以我们可以利用一维数组，通过覆盖的方式完成递推，而从前往后枚举的话会出现原数据被覆盖的情况，即$dp[i-1][y]$被$dp[i][y]$覆盖，而枚举的顺序不会导致答案的变化，所以我们从后往前枚举，这样被覆盖的数据在之后这一轮的运算中不会被用到，就不会导致错误了（这里其实实际上是为了避免重复取出物品$i$，因为利用$dp[i][y]$来更新$dp[i][x]$实质上是在取了一次物品i的情况下再取一次物品i所能达到的最大价值）</p><p>此时$dp[j]=max(dp[j],dp[j-w[i]]+p[i])，W\geqslant j\geqslant w[i] $，$j$表示最大承重量</p><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
int N, W, w[105], p[105], dp[100005];

int main()
&#123;
    scanf(&quot;%d %d&quot;, &amp;N, &amp;W);
    for (int i = 1; i &lt;= N; i++)
        scanf(&quot;%d %d&quot;, &amp;w[i], &amp;p[i]);
    for (int i = 1; i &lt;= N; i++)
        for (int j = W; j &gt;= w[i]; j--)//反向更新
            dp[j] = max(dp[j], dp[j - w[i]] + p[i]);
    printf(&quot;%d\n&quot;, dp[W]);

    return 0;
&#125;
</code></pre><h5 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h5><p><img data-src="Users\10051\AppData\Roaming\Typora\typora-user-images\image-20210404151015416.png" alt="image-20210404151015416"></p><p>因为完全背包问题中每种物品的数量没有限制，所以我们可以将上面空间优化版的遍历顺序修改，变成从小到大遍历，上面是为了避免重复，而这里需要重复qwqq</p><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
int N, W, w[105], p[105], dp[100005];

int main()
&#123;
    scanf(&quot;%d %d&quot;, &amp;N, &amp;W);
    for (int i = 1; i &lt;= N; i++)
        scanf(&quot;%d %d&quot;, &amp;w[i], &amp;p[i]);
    for (int i = 1; i &lt;= N; i++)
        for (int j = w[i]; j &lt;= W; j++)//真就只改了一行qwqq
            dp[j] = max(dp[j], dp[j - w[i]] + p[i]);
    printf(&quot;%d\n&quot;, dp[W]);

    return 0;
&#125;
</code></pre><h5 id="Big-Event-in-HDU"><a href="#Big-Event-in-HDU" class="headerlink" title="Big Event in HDU"></a>Big Event in HDU</h5><p><strong>多重背包问题：</strong></p><p>与0-1背包问题的唯一区别在于给出了第$i$个物品的数量$n_i$，使用$n[i]$保存</p><p>解决方法：</p><p>在对第i个物品更新最大值时增加一个个数的循环，$k，1\leqslant k\leqslant n[i]$为第i个物品放入的个数</p><p>递推式变为$dp[j]=max(dp[j],dp[j-k\times w[i]]+k\times p[i])，W\geqslant j\geqslant w[i],1\leqslant k\leqslant min(n[i],\frac{j}{w[i]})$</p><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
int N, W, w[105], p[105], n[105], dp[100005];

int main()
&#123;
    scanf(&quot;%d %d&quot;, &amp;N, &amp;W);
    for (int i = 1; i &lt;= N; i++)
        scanf(&quot;%d %d %d&quot;, &amp;w[i], &amp;p[i], &amp;n[i]);
    for (int i = 1; i &lt;= N; i++)
        for (int j = W; j &gt;= w[i]; j--)
            for (int k = 1; k &lt;= min(j / n[i], n[i]); k++)//这里多了一重循环qwqq
            &#123;
                dp[j] = max(dp[j], dp[j - k * w[i]] + k * p[i]);
            &#125;
            
    printf(&quot;%d\n&quot;, dp[W]);

    return 0;
&#125;
</code></pre><p><img data-src="Users\10051\AppData\Roaming\Typora\typora-user-images\image-20210404170617506.png" alt="image-20210404170617506"></p><p>大意：给出物品种类的个数和每种物品的价值，个数，让你把它们分成两堆，使得它们的价值的差的绝对值最小</p><p>将所有物品的价值之和除以二便成了不计重量的多重背包问题（实际上是01背包问题qwqq</p><p>$dp[j]$表示最大承重为j的时候，能装进的最大重量</p><p>递推关系为$dp[j] = max(dp[j], dp[j - k\times w[i]] + k\times w[i])，dp[j - k\times w[i]] + k\times w[i]\leqslant j$</p><pre><code class="c++">//--------当成多重背包超时了qwqq---------
int N, W,sum, w[105], n[105], dp[100005];
int main()
&#123;
    while (scanf(&quot;%d&quot;, &amp;N) &amp;&amp; N &gt; 0) &#123;
        sum = 0;
        memset(dp, 0, sizeof(dp));
        for (int i = 1; i &lt;= N; i++)
        &#123;
            scanf(&quot;%d %d&quot;, &amp;w[i], &amp;n[i]);
            sum += w[i] * n[i];
        &#125;
        W = sum / 2;
        for (int i = 1; i &lt;= N; i++)
            for (int j = W; j &gt;= w[i]; j--)
                for (int k = 1; k &lt;= min(j / n[i], n[i]); k++)
                    if (dp[j - k * w[i]] + k * w[i] &lt;= j)
                        dp[j] = max(dp[j], dp[j - k * w[i]] + k * w[i]);

        printf(&quot;%d %d\n&quot;, sum - dp[W], dp[W]);
    &#125;

    return 0;
&#125;
//--------改成01背包过了qwqq---------
int N, W,sum, w[1000005], dp[100005];
int main()
&#123;
    while (scanf(&quot;%d&quot;, &amp;N) &amp;&amp; N &gt; 0) &#123;
        sum = 0;
        memset(dp, 0, sizeof(dp));
        int cnt = 1;
        for (int i = 1; i &lt;= N; i++)
        &#123;
            int weight, n;
            scanf(&quot;%d %d&quot;, &amp;weight, &amp;n);
            sum += weight * n;
            for (int i = 0; i &lt; n; i++)
                w[cnt++] = weight;    
        &#125;
        W = sum / 2;
        for (int i = 1; i &lt; cnt; i++)
            for (int j = W; j &gt;= w[i]; j--)
                if (dp[j - w[i]] + w[i] &lt;= j)
                    dp[j] = max(dp[j], dp[j - w[i]] + w[i]);

        printf(&quot;%d %d\n&quot;, sum - dp[W], dp[W]);
    &#125;

    return 0;
&#125;
</code></pre><h5 id="Anniversary-party"><a href="#Anniversary-party" class="headerlink" title="Anniversary party"></a>Anniversary party</h5><p><strong>题目描述</strong><br>Ural 大学有N 个职员，编号为 1~N。他们有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。每个职员有一个快乐指数。现在有个周年庆宴会，要求与会职员的快乐指数最大。但是，没有职员愿和直接上司一起与会。</p><p><strong>输入格式</strong><br>第一行一个整数 N (1&lt;=N&lt;=6000)。<br>接下来 N 行，第i+1行表示i 号职员的快乐指数Ri(-128&lt;=Ri&lt;=127) 。<br>接下来 N-1 行，每行输入一对整数 L 和 K。表示 K 是 L 的直接上司<br>最后一行输入0 0。</p><p><strong>输出格式</strong><br>输出最大的快乐指数。</p><p><strong>输入</strong></p><p>7<br>1<br>1<br>1<br>1<br>1<br>1<br>1<br>1 3<br>2 3<br>6 4<br>7 4<br>4 5<br>3 5<br>0 0</p><p><strong>输出</strong><br>5</p><p>树形DP</p><p>设$dp[i][1]$表示邀请i的最大值，$dp[i][0]$表示不邀请i的最大值 ,$R[i]$表示第i个人的快乐指数，$sup[j]=i$表示$j$为$i$号的下属</p><p>初始化$dp[i][0]=0,dp[i][1]=R[i]$</p><p>递推式为$$\left{\begin{matrix}<br>dp[i][1] += dp[j][0] \<br>dp[i][0] += max(dp[j][1], dp[j][0])<br>\end{matrix}\right.$$ 其中$sup[j]=i$</p><p>采用dfs从根结点开始搜索,根节点为没有上司的人</p><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
const int maxn = 6005;
int N, sup[maxn], dp[maxn][2]; //R[maxn]
bool visited[maxn];
void dfs(int root) &#123;
    visited[root] = 1;
    for (int i = 1; i &lt;= N; i++)
    &#123;
        if ((!visited[i]) &amp;&amp; sup[i] == root)
        &#123;
            dfs(i);
            dp[root][1] += dp[i][0];                //dp[i][1] 邀请i的最大值
            dp[root][0] += max(dp[i][1], dp[i][0]);    //dp[i][0] 不邀请i的最大值 
        &#125;
    &#125;
&#125;

int main()
&#123;
    scanf(&quot;%d&quot;, &amp;N);
    for (int i = 1; i &lt;= N; i++)
        scanf(&quot;%d&quot;, &amp;dp[i][1]); //scanf(&quot;%d&quot;, &amp;R[i]);
    for (int i = 1; i &lt; N; i++)
    &#123;
        int L, K;
        scanf(&quot;%d %d&quot;, &amp;L, &amp;K);
        sup[L] = K;
    &#125;
    int rootNode = 0;
    for (int i = 1; i &lt;= N; i++)
        if (!sup[i])
        &#123;
            rootNode = i;
            break;
        &#125;
    dfs(rootNode);
    printf(&quot;%d&quot;, max(dp[rootNode][0], dp[rootNode][1]));

    return 0;
&#125;
</code></pre><h5 id="堆优化Dijkstra模板"><a href="#堆优化Dijkstra模板" class="headerlink" title="堆优化Dijkstra模板"></a>堆优化Dijkstra模板</h5><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
using namespace std;
const int maxn = 1e3;
struct edge &#123;
    int edgeWeight;
    int nodeNum;
    edge* next;
&#125;;
struct head &#123;
    //int weight;
    edge* fisrt;
&#125;p[maxn];
struct point
&#123;
    int dis;
    int num;
    inline bool operator &lt; (const point&amp; a) const &#123; return dis &gt; a.dis; &#125;
&#125;;
int N, M, dist[maxn];
bool v[maxn];
void creatMap() &#123;
    for (int i = 1; i &lt;= N; i++)
        p[i].fisrt = nullptr;
    for (int i = 0, j, k, weight; i &lt; M; i++)
    &#123;
        scanf(&quot;%d%d%d&quot;, &amp;j, &amp;k, &amp;weight);
        edge* e = new edge&#123; weight, k, p[j].fisrt &#125;;
        p[j].fisrt = e;
        e = new edge&#123; weight, j, p[k].fisrt &#125;;
        p[k].fisrt = e;
    &#125;
&#125;
void dijistra(int start) &#123;
    priority_queue&lt;point&gt; q;
    //初始化dist
    for (int i = 1; i &lt;= N; i++)
        dist[i] = 0x7f7f7f7f;
    dist[start] = 0;
    //初始化v
    memset(v, 0, sizeof(v));

    q.push(point&#123; 0,start &#125;);
    while (!q.empty()) &#123;
        int here = q.top().num;
        q.pop();
        if (v[here])
            continue;
        v[here] = true;
        edge* pe = p[here].fisrt;
        while (pe != nullptr) &#123;
            if (dist[pe-&gt;nodeNum] &gt; pe-&gt;edgeWeight + dist[here])
            &#123;
                dist[pe-&gt;nodeNum] = pe-&gt;edgeWeight + dist[here];
                q.push(point&#123; dist[pe-&gt;nodeNum],pe-&gt;nodeNum &#125;);
            &#125;
            pe = pe-&gt;next;
        &#125;
    &#125;
&#125;

int main()
&#123;
    //freopen(&quot;in&quot;, &quot;r&quot;, stdin);
    while (scanf(&quot;%d%d&quot;, &amp;N, &amp;M) &amp;&amp; N != 0)
    &#123;
        creatMap();
        dijistra(1);
        printf(&quot;%d\n&quot;, dist[N]);
    &#125;
    return 0;
&#125;
</code></pre><h5 id="kruskai算法模板"><a href="#kruskai算法模板" class="headerlink" title="kruskai算法模板"></a>kruskai算法模板</h5><p><img data-src="Users\10051\AppData\Roaming\Typora\typora-user-images\image-20210415195315393.png" alt="image-20210415195315393"></p><pre><code class="c++">#include&lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
const int N = 108;
using namespace std;
struct Node
&#123;
    int x, y, len;
    friend bool operator &lt; (const Node &amp;a, const Node &amp;b)
    &#123;
        return a.len &lt; b.len;
    &#125;
&#125;node[10009];
int father[N], n, m;
int find(int x)
&#123;
    if (x != father[x])
        father[x] = find(father[x]);
    return father[x];
&#125;

int main()
&#123;
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m), n)
    &#123;
        int ans = 0, a, b;
        for (int i = 0; i &lt;= m; i++)
            father[i] = i;
        for (int i = 0; i &lt; n; i++)
            scanf(&quot;%d%d%d&quot;, &amp;node[i].x, &amp;node[i].y, &amp;node[i].len);
        sort(node, node+n);
        for (int i = 0; i &lt; n; i++)
        &#123;
            a = find(node[i].x);
            b = find(node[i].y);
            if (a == b)
                continue;
            ans += node[i].len;
            father[a] = b;
        &#125;
        a = 0;
        for (int i = 1; i &lt;= m; i++)
            if (i == father[i])
                a++;
        if (a &gt; 1)
            cout &lt;&lt; &quot;?\n&quot;;
        else
            cout &lt;&lt; ans &lt;&lt; endl;
    &#125;

    return 0;
&#125;
</code></pre><h5 id="Prim算法模板"><a href="#Prim算法模板" class="headerlink" title="Prim算法模板"></a>Prim算法模板</h5><p>题意：先输入一个数字n，接下来n-1行数据，每行第一个数据表示城市代号，第二个数据m表示有m个城市与这个城市相连，接下来有m*2个数据，表示与该城市相连的城市和相距的距离，例如数据：A 2 B 12 I 25，表示城市A能和其他2个城市相连，这两个分别是B和I，距离分别是12和15，求出将所有城市连通的最小距离。</p><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
const int maxn = 1e3;
const int INF = 0x7f7f7f7f;
int edge[maxn][maxn], vis[maxn], dis[maxn];

int main()
&#123;
    int m, n, m1;
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    &#123;
        if (n == 0)
            break;
        getchar();
        memset(edge, 0, sizeof(edge));
        memset(vis, 0, sizeof(vis));
        memset(dis, 0, sizeof(dis)); //初始化数据
        for (int i = 1; i &lt;= 900; i++)
        &#123;
            for (int j = 1; j &lt;= 900; j++)
            &#123;
                if (i == j)
                    edge[i][j] = 0;
                else
                    edge[i][j] = INF;
            &#125;
        &#125; //初始化数组a

        for (int i = 1; i &lt; n; i++)
        &#123;
            char s[5], s1[5];
            scanf(&quot;%s%d&quot;, &amp;s, &amp;m); //读入每一行前两个数据
            int t1 = s[0] - &#39;A&#39; + 1;
            for (int j = 1; j &lt;= m; j++)
            &#123;
                scanf(&quot;%s%d&quot;, &amp;s1, &amp;m1);
                int t2 = s1[0] - &#39;A&#39; + 1;
                edge[t1][t2] = m1;
                edge[t2][t1] = m1; //将连通情况正反存储到数组
            &#125;
        &#125;
        for (int i = 1; i &lt;= n; i++)
            dis[i] = edge[1][i];

        vis[1] = 1;
        int cnt = 1, sum = 0, min, maxp;
        while (cnt &lt; n) //Prim核心算法
        &#123;
            min = INF;
            for (int i = 1; i &lt;= n; i++)
                if (vis[i] == 0 &amp;&amp; dis[i] &lt; min)
                &#123;
                    maxp = i;
                    min = dis[i];
                &#125;
            sum += dis[maxp];
            vis[maxp] = 1;
            cnt++;
            for (int i = 1; i &lt;= n; i++)
                if (vis[i] == 0 &amp;&amp; dis[i] &gt; edge[maxp][i])
                    dis[i] = edge[maxp][i];
        &#125;
        printf(&quot;%d\n&quot;, sum);
    &#125;
    return 0;
&#125;
</code></pre></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2021-04-20 21:41:00" itemprop="dateModified" datetime="2021-04-20T21:41:00+08:00">2021-04-20</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Ling yunchi 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Ling yunchi 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Ling yunchi 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Ling yunchi <i class="ic i-at"><em>@</em></i>QWQ</li><li class="link"><strong>本文链接：</strong> <a href="https://ling-yunchi.github.io/2021/03/13/%E9%9D%A2%E5%90%91%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E7%9A%84%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/" title="面向问题求解的高级语言设计">https://ling-yunchi.github.io/2021/03/13/面向问题求解的高级语言设计/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/03/11/maven%E9%9A%8F%E7%AC%94/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giph4wqtg4j20zk0m8x6p.jpg" title="maven随笔"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>maven随笔</h3></a></div><div class="item right"><a href="/2021/04/01/Spring5/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipevgoki5j20zk0m84qp.jpg" title="Spring5"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>Spring5</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.1.</span> <span class="toc-text">搜索枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E4%B8%8E%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.2.</span> <span class="toc-text">高斯消元与枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl%E4%B8%AD%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97%E5%87%BD%E6%95%B0next-permutation"><span class="toc-number">1.3.</span> <span class="toc-text">stl中的全排列函数next_permutation</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">2.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86"><span class="toc-number">2.1.</span> <span class="toc-text">二分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%88%86"><span class="toc-number">2.2.</span> <span class="toc-text">三分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">2.3.</span> <span class="toc-text">优先队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%8E%E5%B8%A6%E6%9D%83%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">中位数与带权中位数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-number">3.</span> <span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%AA%E5%BF%83"><span class="toc-number">3.1.</span> <span class="toc-text">什么是贪心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">贪心算法的设计过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E"><span class="toc-number">3.3.</span> <span class="toc-text">贪心算法的正确性证明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%9A%84%E4%BC%98%E5%8A%A3"><span class="toc-number">3.4.</span> <span class="toc-text">贪心的优劣</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%A7%8D%E8%B4%AA%E5%BF%83"><span class="toc-number">3.5.</span> <span class="toc-text">多种贪心</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-number">4.</span> <span class="toc-text">搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">4.1.</span> <span class="toc-text">广度优先搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">4.2.</span> <span class="toc-text">深度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AA%E6%9E%9D"><span class="toc-number">4.2.2.</span> <span class="toc-text">剪枝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E6%90%9C%E7%B4%A2%E5%AE%BD%E5%BA%A6"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">减少搜索宽度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E6%90%9C%E7%B4%A2%E6%B7%B1%E5%BA%A6"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">减少搜索深度</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E4%B8%8E%E9%80%92%E5%BD%92"><span class="toc-number">5.</span> <span class="toc-text">分治与递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">5.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%B2%BB"><span class="toc-number">5.2.</span> <span class="toc-text">分治</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.1.</span> <span class="toc-text">莫队算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A2%E5%BC%8F"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">排序方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">5.2.1.4.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">5.2.2.</span> <span class="toc-text">线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">区间修改</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%87%92%E6%A0%87%E8%AE%B0"><span class="toc-number">5.2.2.3.1.</span> <span class="toc-text">懒标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">5.2.2.3.2.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CDQ%E5%88%86%E6%B2%BB"><span class="toc-number">5.2.3.</span> <span class="toc-text">CDQ分治</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">6.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">6.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dp%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.3.</span> <span class="toc-text">dp类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dp%E4%BE%8B%E9%A2%98"><span class="toc-number">6.4.</span> <span class="toc-text">dp例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">7.</span> <span class="toc-text">最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">7.1.</span> <span class="toc-text">最短路的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text">常见算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Flody"><span class="toc-number">7.2.1.</span> <span class="toc-text">Flody</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dijkstra"><span class="toc-number">7.2.2.</span> <span class="toc-text">Dijkstra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E4%BC%98%E5%8C%96Dijkstra"><span class="toc-number">7.2.3.</span> <span class="toc-text">堆优化Dijkstra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bellman-Ford"><span class="toc-number">7.2.4.</span> <span class="toc-text">Bellman-Ford</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPFA"><span class="toc-number">7.2.5.</span> <span class="toc-text">SPFA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8"><span class="toc-number">7.3.</span> <span class="toc-text">一些应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%BA%90-%E8%B6%85%E6%B1%87%E7%82%B9"><span class="toc-number">7.3.1.</span> <span class="toc-text">超源,超汇点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.3.2.</span> <span class="toc-text">差分约束系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91MST"><span class="toc-number">8.</span> <span class="toc-text">最小生成树MST</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">Kruskal算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">8.1.1.</span> <span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">Prim算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">9.</span> <span class="toc-text">数论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E9%99%A4"><span class="toc-number">9.1.</span> <span class="toc-text">整除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E6%A8%A1"><span class="toc-number">9.2.</span> <span class="toc-text">取模</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gcd%E4%B8%8Elcm"><span class="toc-number">9.3.</span> <span class="toc-text">gcd与lcm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86%EF%BC%88%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86%EF%BC%89"><span class="toc-number">9.4.</span> <span class="toc-text">裴蜀定理（贝祖定理）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97"><span class="toc-number">9.5.</span> <span class="toc-text">扩展欧几里得</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A0%E6%95%B0%E7%AD%9B"><span class="toc-number">9.6.</span> <span class="toc-text">素数筛</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%83%E6%B0%8F%E7%AD%9B"><span class="toc-number">9.6.1.</span> <span class="toc-text">埃氏筛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E7%AD%9B"><span class="toc-number">9.6.2.</span> <span class="toc-text">欧拉筛</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA%E5%9B%9B%E5%A4%A7%E5%AE%9A%E7%90%86"><span class="toc-number">9.7.</span> <span class="toc-text">数论四大定理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83"><span class="toc-number">9.8.</span> <span class="toc-text">乘法逆元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82%E5%85%AC%E5%BC%8F"><span class="toc-number">9.9.</span> <span class="toc-text">欧拉降幂公式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">9.10.</span> <span class="toc-text">快速幂</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">10.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%83%E5%8A%9B%E6%8C%87%E6%95%B0"><span class="toc-number">10.0.0.0.1.</span> <span class="toc-text">权力指数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2"><span class="toc-number">10.0.0.0.2.</span> <span class="toc-text">1-2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3"><span class="toc-number">10.0.0.0.3.</span> <span class="toc-text">1-3</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%A8%A1%E6%9D%BF"><span class="toc-number">10.0.0.0.4.</span> <span class="toc-text">高斯消元模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1"><span class="toc-number">10.0.0.0.5.</span> <span class="toc-text">2-1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2"><span class="toc-number">10.0.0.0.6.</span> <span class="toc-text">2-2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#poj1190"><span class="toc-number">10.0.0.0.7.</span> <span class="toc-text">poj1190</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1"><span class="toc-number">10.0.0.0.8.</span> <span class="toc-text">5-1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%AA%E6%98%8E%E7%9A%84%E5%AD%A6%E7%94%9F"><span class="toc-number">10.0.0.0.9.</span> <span class="toc-text">聪明的学生</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%81%AB%E6%9F%B4%E6%8E%92%E9%98%9F"><span class="toc-number">10.0.0.0.10.</span> <span class="toc-text">火柴排队</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Point-on-Plane"><span class="toc-number">10.0.0.0.11.</span> <span class="toc-text">Point on Plane</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Electric-Charges"><span class="toc-number">10.0.0.0.12.</span> <span class="toc-text">Electric Charges</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">10.0.0.0.13.</span> <span class="toc-text">0-1背包问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">10.0.0.0.14.</span> <span class="toc-text">完全背包问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Big-Event-in-HDU"><span class="toc-number">10.0.0.0.15.</span> <span class="toc-text">Big Event in HDU</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Anniversary-party"><span class="toc-number">10.0.0.0.16.</span> <span class="toc-text">Anniversary party</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%E4%BC%98%E5%8C%96Dijkstra%E6%A8%A1%E6%9D%BF"><span class="toc-number">10.0.0.0.17.</span> <span class="toc-text">堆优化Dijkstra模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#kruskai%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="toc-number">10.0.0.0.18.</span> <span class="toc-text">kruskai算法模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="toc-number">10.0.0.0.19.</span> <span class="toc-text">Prim算法模板</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Ling yunchi" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Ling yunchi</p><div class="description" itemprop="description">qwqqqq</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">39</span> <span class="name">文章</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpbmcteXVuY2hp" title="https:&#x2F;&#x2F;github.com&#x2F;Ling-yunchi"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/03/11/maven%E9%9A%8F%E7%AC%94/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/04/01/Spring5/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Ling yunchi @ Ling Yunchi</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/03/13/面向问题求解的高级语言设计/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->