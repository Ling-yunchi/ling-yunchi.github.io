<!-- build time:Fri Feb 24 2023 15:17:52 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="QWQ" href="https://ling-yunchi.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="QWQ" href="https://ling-yunchi.github.io/atom.xml"><link rel="alternate" type="application/json" title="QWQ" href="https://ling-yunchi.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://ling-yunchi.github.io/2023/01/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/"><title>设计模式 | Ling Yunchi = QWQ</title><meta name="generator" content="Hexo 5.4.1"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">设计模式</h1><div class="meta"><span class="item" title="创建时间：2023-01-30 10:05:15"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-01-30T10:05:15+08:00">2023-01-30</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Ling Yunchi</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclh5u05ej20zk0m87df.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeuv80yoj20zk0m8kjl.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciuja1j1j20zk0m8kjl.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclip4jbpj20zk0m87cv.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeu7txpzj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicis3attqj20zk0m8k7l.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://ling-yunchi.github.io/2023/01/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Ling yunchi"><meta itemprop="description" content=", qwqqqq"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="QWQ"></span><div class="body md" itemprop="articleBody"><h1 id="软件开发与设计模式"><a class="anchor" href="#软件开发与设计模式">#</a> 软件开发与设计模式</h1><h2 id="设计模式概述"><a class="anchor" href="#设计模式概述">#</a> 设计模式概述</h2><h3 id="概念与意义"><a class="anchor" href="#概念与意义">#</a> 概念与意义</h3><p>软件设计模式是对软件设计经验的总结，是对软件设计中反复出现的设计问题的成功解决方案的描述。</p><ul><li>模式名称</li><li>问题</li><li>解决方案</li><li>效果</li></ul><p>软件设计模式的重要意义在于设计复用。</p><h3 id="软件设计模式与软件体系结构"><a class="anchor" href="#软件设计模式与软件体系结构">#</a> 软件设计模式与软件体系结构</h3><p>​ 用于软件体系结构的设计模式通常称为架构模式或体系结构风格。</p><p>软件设计模式分为三个层次：</p><ul><li>架构模式：高层模式，用于描述系统级的结构组成、相互关系及相关约束。对架构模式的选择是最基本的设计决策，将决定系统的基本架构，并决定后续的设计及开发活动。</li><li>设计模式：中层模式，是针对系统局部设计问题给出的解决方案。一般情况下，人们所讲的设计模式都是指中层模式。设计模式的选择对系统的基本架构没有影响，但在实现架构模式时，则可能采用多种设计模式。</li><li>习惯用法：底层模式，一般与具体语言相关。</li></ul><h3 id="软件设计模式的分类"><a class="anchor" href="#软件设计模式的分类">#</a> 软件设计模式的分类</h3><p>&lt;img src=&quot;设计模式 /image-20230130111236538.png&quot; alt=&quot;image-20230130111236538&quot; style=&quot;zoom: 67%;&quot; /&gt;</p><h2 id="创建型设计模式"><a class="anchor" href="#创建型设计模式">#</a> 创建型设计模式</h2><p>​ 将创建对象的责任委托给某个特殊的类。使用该类为客户创建对象，而不是客户直接初始化对象。大量减少客户程序中对象初始化的代码量。</p><p>两个主导思想：</p><ul><li>封装系统使用的具体类的知识。</li><li>隐藏这些具体类的实例被创建与结合的细节。</li></ul><h3 id="工厂方法与抽象工厂模式"><a class="anchor" href="#工厂方法与抽象工厂模式">#</a> 工厂方法与抽象工厂模式</h3><p>​ 工厂方法：将创建对象的方法从主程序类中分离出来，由另一个类来封装对象的创建工作。该设计将类的选择和对象的创建封装在一个方法 (即工厂方法) 中，而将这个方法封装在一个独立的类 (即工厂类) 里面。</p><blockquote><p>​ 因为客户使用的是超类类型，并不需要知道具体的子类是什么，但是在创建对象时，需要根据条件来选择具体的子类，而条件语句可能会很复杂，所以需要将这些条件语句封装在一个方法中，这个方法就是工厂方法。</p></blockquote><p>工厂方法的优点：</p><ol><li>简化应用程序，应用程序本身不再含有大量的条件语句判定何时选取哪个类。</li><li>工厂方法实现了一些特殊的初始化某个类的机制，尤其是层次结构不同的类需要不同的初始化方法的时候。工厂方法隐藏了这些创建对象的不同方法的细节，使得应用程序无须处理这些细节。</li><li>工厂方法返回一个父类的对象，客户程序不必知道这个被初始化的类的存在。因为工厂方法知道哪个类的对象被创建了，但是返回给应用程序的对象是所考虑的类的层次结构的父类，所以应用程序不知道哪个具体的类的对象被创建了。</li></ol><h4 id="简单工厂方法模式"><a class="anchor" href="#简单工厂方法模式">#</a> 简单工厂方法模式</h4><p>&lt;img src=&quot;设计模式 /image-20230130113529061.png&quot; alt=&quot;image-20230130113529061&quot; style=&quot;zoom: 50%;&quot; /&gt;</p><p>​ <code>fatory</code> 方法是静态的。</p><p>简单工厂方法模式的优点如下:</p><ol><li>工厂方法包含从一个类的结构中选择初始类的业务逻辑。</li><li>客户类不直接创建产品类的对象，客户类只作为对象的消费者。</li><li>简单工厂方法模式实现了责任分离。</li><li>客户类不负有创建类的对象的责任，因此如果有新产品子类加人，不必修改已有的客户类代码 (前提是客户类暂时不需要使用新的产品子类对象)。</li><li>因为工厂类中包含了对象生成的必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，所以客户端类中没有创建对象所需要的条件语句。</li></ol><p>简单工厂方法模式的缺点如下:</p><ol><li>由于工厂类必须知道怎样创建每个子类的对象，所以每当增加产品类的时候，都需要修改工厂类的代码。简单工厂方法模式<strong>不符合开闭原则</strong>。</li><li>因为工厂类的工厂方法是静态的，所以工厂类中的方法不能被继承，简单工厂类只能是一个单独的类，而不能成为一个层次的类。</li></ol><h4 id="工厂方法模式"><a class="anchor" href="#工厂方法模式">#</a> 工厂方法模式</h4><p>将简单工厂方法模式中单一的工厂类改写为一个层次类来解决不符合开闭原则的问题。</p><p>&lt;img src=&quot;设计模式 /image-20230130163331986.png&quot; alt=&quot;image-20230130163331986&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>每一种子类都有一个对应的工厂子类，该工厂子类负责创建该子类的对象。</p><p>简单工厂方法模式与工厂方法模式的区别如下:</p><ol><li>两个模式的中心不同。工厂方法模式的中心是抽象工厂类或者接口，而简单工厂方法模式的中心是一个实际的工厂类 (Concrete Factory Class）。在简单工厂模式类中，工厂方法是静态 (Static) 的，而在工厂模式中工厂方法是动态的 (Dynamic)。</li><li>简单工厂模式不支持开闭原则，工厂方法模式支持开闭原则。</li><li>在简单工厂模式中，必要的创建对象的逻辑判断包含在工厂类中；在工厂方法模式中，工厂类不必包含创建对象的逻辑判断。</li></ol><p>在以下任何一种情况下，可以使用工厂方法模式。</p><ol><li>创建某些类的对象的逻辑比较复杂，并且有很多条件分支，而且还可能增加新的条件。</li><li>一个类不能预先准确地知道它必须创建一个层次类中哪个子类的对象。</li><li>一个类使用它的子类决定所要创建的对象。</li><li>需要封装创建类的对象的逻辑，使得这些逻辑局部化。</li></ol><p>工厂方法模式的优点如下:</p><ol><li>工厂方法模式将创建对象的逻辑与任务交给了工厂类。</li><li>工厂方法模式支持开闭原则。</li></ol><h4 id="抽象工厂模式"><a class="anchor" href="#抽象工厂模式">#</a> 抽象工厂模式</h4><p>&lt;img src=&quot;设计模式 /image-20230130164500821.png&quot; alt=&quot;image-20230130164500821&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 抽象工厂模式是工厂方法模式的进一步扩展，在<strong>抽象工厂模式中，一个工厂可以创建一族子类对象</strong>。</p><p>​ 抽象工厂是为了解决当存在大量子类对象时，工厂方法模式中的工厂子类会变得很庞大，而抽象工厂模式可以将同一族的子类对象的创建逻辑封装在一个工厂中，从而减少工厂子类的数量。并且可以在工厂抽象父类中定义一个静态工厂方法，用于创建抽象工厂的子类对象，避免用户代码中出现创建工厂子类的条件语句。</p><p>抽象工厂模式中包含:</p><ol><li>一系列互相有关联的产品类，这些产品类有相同的结构。</li><li>一系列实的工厂类，实现由抽象工厂类提供的接口。每个实的工厂类生产一组相关的产品类的对象。</li></ol><h3 id="生成器模式"><a class="anchor" href="#生成器模式">#</a> 生成器模式</h3><p>​ 生成器模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不知道内部的具体构建细节。</p><p>&lt;img src=&quot;设计模式 /image-20230130223802424.png&quot; alt=&quot;image-20230130223802424&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>使用生成器模式的特点如下。</p><ol><li>生成器让用户可以变化它建造产品的内部表达形式，它也隐藏了产品怎样被装配的细节。</li><li>每个具体的生成器都独立于程序的其他生成器，因此改善了程序的模块化，并且使添加其他生成器变得相对简单。</li><li>由于每个生成器根据数据逐步构建最终产品，用户对生成器构建的最终产品有更多的控制。</li><li>生成器模式与抽象工厂模式有相似之处，都返回由其他一些对象组成的类的对象。主要区别是，抽象工厂模式返回一个类族，而生成器模式逐步按照次序构建一个复杂的对象，最后该对象被返回。</li></ol><p>生成器模式与工厂模式的区别：</p><p>​ 工厂方法模式提供了一个接口来创建对象，但不指定对象的具体类型。它的具体实现由子类决定。工厂方法模式的目的是<strong>使用工厂类隔离对象的创建过程</strong>。</p><p>​ 生成器模式则更加灵活，因为它不仅提供了一个接口来创建对象，而且还提供了一个具体的生成器，用于生成预定义的复杂对象。客户不需要了解复杂对象的具体构建过程，只需要知道生成器提供的构建接口。<strong>生成器模式更加注重于构建步骤，而不是隔离对象的创建过程</strong>。</p><h3 id="单例模式"><a class="anchor" href="#单例模式">#</a> 单例模式</h3><p>​ 单例模式是指确保一个类仅有一个唯一的实例，并且提供一个全局的访问点。</p><p>​ 实现单例模式的思路是，为了防止客户程序利用构造方法创建多个对象，将构造方法声明为 private 类型，并提供一个静态方法来返回该类的唯一实例，通常将该静态方法命名为 <code>getInstance()</code> 。</p><p>&lt;img src=&quot;设计模式 /image-20230130231803751.png&quot; alt=&quot;image-20230130231803751&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>单例模式的优点如下：</p><ol><li>严格控制客户程序访问其唯一的实例。因为单例类封装了其唯一的实例，它可以严格控制在何时客户程序以怎样的方式访问它。</li><li>单例类可以带有一些子类，它的每个子类都是单例类。每个子类有不同的行为，从而使应用客户程序可以在运行时配置不同的子类对象。</li><li>该模式的 Singleton 类可以比较容易地改变为允许创建一定数目对象的类。</li></ol><h2 id="结构型设计模式"><a class="anchor" href="#结构型设计模式">#</a> 结构型设计模式</h2><p>​ 结构型软件设计模式的主要目的是<strong>将不同的类和对象组合在一起，形成更大或者更复杂的结构体</strong>。它不是简单地将这些类摆在一起，而是要提供这些类之间的关联方式。</p><h3 id="组合模式"><a class="anchor" href="#组合模式">#</a> 组合模式</h3><p>&lt;img src=&quot;设计模式 /image-20230131104501362.png&quot; alt=&quot;image-20230131104501362&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 组合模式用于将对象组合成<strong>树形结构</strong>以表示 &quot;部分 - 整体&quot; 的层次结构。它使得用户<strong>以相同的方式对待单个对象或一组对象，即组合对象</strong>。</p><p>组合模式的优点如下。</p><ol><li>定义了包含基本对象和组合对象的类层次结构，基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合。</li><li>简化了客户代码。客户可以一致地使用组合结构和单个对象，通常用户不知道处理的是一个叶结点还是一个组合组件。</li><li>使得更容易增加新类型的组件。新定义的 Composite 或 Leaf 子类自动与已有的结构和客户代码一起工作，客户程序不需要因为新的 Component 类而改变。</li><li>使设计变得更通用。</li></ol><h4 id="组合模式的安全形式与透明形式"><a class="anchor" href="#组合模式的安全形式与透明形式">#</a> 组合模式的安全形式与透明形式</h4><p>​ 安全形式是在 Composite 类中声明所有的用来管理子类对象的方法，包括 add ()，remove () 以及 getChild () 方法，而在<strong> Component 接口和树叶类型的对象中不包含管理子类对象的方法</strong>。这样的做法是安全的做法。因为如果客户端对树叶类对象使用这些方法时，程序将会在编译时报错。</p><p>&lt;img src=&quot;设计模式 /image-20230131142614475.png&quot; alt=&quot;image-20230131142614475&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 透明形式的组合模式在<strong> Component 类中声明所有的用来管理子类对象的方法</strong>，包括 add ()，remove ()，以及 getChild () 方法，这样做的好处是所有的构件类都有相同的接口。这个选择的缺点是不够安全，因为树叶类对象和组合类对象在本质上是有区别的。树叶类对象不可能有下一个层次的对象，因此 add ()，remove () 以及 getChild () 方法没有意义。因此，需要将 Composite 类中需要的，但是在 Leaf 类中不需要的方法 add ()、remove () 和 getChild () 方法给屏蔽 (Deprecated) 掉，并且抛出适当的异常。</p><p>&lt;img src=&quot;设计模式 /image-20230131143052019.png&quot; alt=&quot;image-20230131143052019&quot; style=&quot;zoom:50%;&quot; /&gt;</p><h3 id="适配器模式"><a class="anchor" href="#适配器模式">#</a> 适配器模式</h3><p>​ 在软件设计中，为了解决接口不一致的问题，两个软件模块之间往往也需要通过一个适配器类 Adapter 进行 “适配”。这样的模式叫做适配器设计模式。</p><h4 id="类适配器模式"><a class="anchor" href="#类适配器模式">#</a> 类适配器模式</h4><p>&lt;img src=&quot;设计模式 /image-20230131143657543.png&quot; alt=&quot;image-20230131143657543&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 类适配器模式使用<strong>继承</strong>来为一个已有的类添加新的功能。这种方式的缺点是，如果同时有多个类需要被适配，则不能使用类适配器模式，因为 Java 不支持多重继承。</p><h4 id="对象适配器模式"><a class="anchor" href="#对象适配器模式">#</a> 对象适配器模式</h4><p>&lt;img src=&quot;设计模式 /image-20230131143735020.png&quot; alt=&quot;image-20230131143735020&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 对象适配器模式使用<strong>对象聚合的方式</strong>来实现适配器功能。这种方式的缺点是，如果需要适配的类过多，那么适配器类的代码会很复杂，因为聚合不像继承能保留被适配类的方法，适配类需要写出所有被适配的类的方法。</p><h3 id="外观模式"><a class="anchor" href="#外观模式">#</a> 外观模式</h3><p>&lt;img src=&quot;设计模式 /image-20230131151151403.png&quot; alt=&quot;image-20230131151151403&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这个子系统更加容易使用。Java 的 JDBC 就是一个著名的外观模式的例子。JDBC 为用户提供了一个统一的接口，用户可以通过这个接口访问不同的数据库。</p><p>外观模式由三个角色组成：</p><ol><li>外观角色 (Facade): 这是外观模式的核心。它被客户角色调用，因此它熟悉子系统的功能。其内部根据客户角色已有的需求预定了几种功能组合。</li><li>子系统角色：实现子系统的功能，对它而言，外观角色就和客户角色一样是未知的，它没有任何外观角色的信息和链接。</li><li>客户角色：调用外观角色来完成要得到的功能。</li></ol><p>外观模式的优点：</p><ol><li>降低了客户类与子系统类的耦合度，这样子系统的变化不会影响到调用它的客户类，只需要调整外观类即可。</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li><li>通过引入外观模式，可以使系统层次化。</li><li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li></ol><p>外观模式的缺点：</p><ol><li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li><li>如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。</li><li>如果需要实现外观类中没有的复杂功能，此时可以绕开外观类直接访问子系统类。</li></ol><h3 id="桥接模式"><a class="anchor" href="#桥接模式">#</a> 桥接模式</h3><p>&lt;img src=&quot;设计模式 /image-20230131162602383.png&quot; alt=&quot;image-20230131162602383&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 桥接模式是指将抽象部分与它的实现部分分离，使它们可以独立地变化。<strong>当一个类存在两个及以上独立变化的维度，且这些维度都需要进行扩展时，可以使用桥接模式</strong>。桥接模式将继承关系转化为关联关系，从而降低了类与类之间的耦合度，减少了代码编写量。</p><p>桥接模式具有如下优点：</p><ol><li>分离接口和实现部分。一个实现不必固定地绑定一个接口。抽家类的实现可以仕系统运行时进行配置，一个对象甚至可以在运行时改变它的实现。</li><li>提高了可扩展性。可以独立地对 Abstraction 和 Implementor 层次结构进行扩展。</li><li>实现细节对客户的透明。可以对客户隐藏实现细节。</li></ol><p>​ 桥接模式强调对象有两个以上的维度变化，简化多级继承关系，但同时增加了聚合对象的内部方法，因为它不得不多写方法以便包含它的类调用。</p><h2 id="行为型设计模式"><a class="anchor" href="#行为型设计模式">#</a> 行为型设计模式</h2><p>​ 行为型软件设计模式关心算法和对象之间的责任分配。它关心的不仅仅是描述对象或类的模式，而是要更加侧重描述它们之间的通信模式。行为型软件设计模式刻画了很难在运行时跟踪的复杂的控制流，将软件开发者的注意力从控制流转移到对象相互关联的方式方面。</p><p>​ 行为型软件设计模式解释对象之间是怎样进行交互的。它描述为了完成一些任务，完成任务的步骤是如何划分不同的对象，以及不同的类和对象之间是如何互相发送消息的。</p><h3 id="迭代器模式"><a class="anchor" href="#迭代器模式">#</a> 迭代器模式</h3><p>&lt;img src=&quot;设计模式 /image-20230201090112144.png&quot; alt=&quot;image-20230201090112144&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 迭代器模式的关键思想是将对列表的访问和遍历从列表对象中分离出来，放入一个独立的迭代器对象中。迭代器类定义了一个访问该列表元素的接口。迭代器类所提供的方法负责跟踪当前的元素，即它知道哪些元素已经遍历过了，哪些元素还没被遍历。</p><p>​ 迭代器模式能够提供一种方法按照顺序访问一个聚合对象中的所有元素，而又不需要暴露该对象的内部表示。</p><p>迭代器模式的优点如下:</p><ol><li>迭代器模式支持以不同的方式遍历同一个聚合，复杂的聚合可用多种方式进行遍历。例如二叉树遍历方法有 4 种；先序遍历、中序遍历、后序遍历和层次遍历。可以将不同的遍历算法封装在不同的迭代器子类中，每个迭代器保持自己的遍历状态，因此可以同时进行多种不同方式的遍历。</li><li>当修改某一个遍历算法时不会影响其他的遍历算法。</li><li>当修改被遍历的聚合结构代码时，如果该聚合结构没有改变，则相应的遍历算法代码也不需要改变。</li><li>迭代器简化了聚合的接口。有了迭代器的遍历接口，聚合本身就不需要类似的遍历接口了，这样就简化了聚合的接口。</li></ol><h3 id="访问者模式"><a class="anchor" href="#访问者模式">#</a> 访问者模式</h3><p>&lt;img src=&quot;设计模式 /image-20230201155742138.png&quot; alt=&quot;image-20230201155742138&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 访问者模式隔离了数据和操作，使得操作集合可以独立变化。一般适用于数据结构相对稳定的系统，但操作算法经常变化的系统，它降低了数据结构与操作算法之间的耦合，使得操作算法可以独立变化，而不影响系统的数据结构。</p><p>访问者模式的优点如下:</p><ol><li>使得在访问者类中针对复杂类结构中的某个类添加新方法较为容易，即只需要简单地添加一个新的访问者方法即可。如果不采用访问者模式，则需要在每个类中添加一个方法。</li><li>访问者将相关的方法集中在一个具体的访问者类中，而将其他相关的方法集中在另外二个具体的访问者类中。也就是说，访问者子类是按照方法的类型来分类的。</li></ol><h3 id="命令模式"><a class="anchor" href="#命令模式">#</a> 命令模式</h3><p>&lt;img src=&quot;设计模式 /image-20230201171037638.png&quot; alt=&quot;image-20230201171037638&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 命令模式的目的是解除调用者类和接收者类之间的耦合。调用者不需要知道谁执行了命令，也不需要知道如何执行命令，只需要在合适的时间调用调用命令即可。命令模式的关键在于引入了抽象命令类，调用者针对抽象命令类编程，只有实现了抽象命令类的具体命令才与接收者相关联。</p><p>​ 命令模式常用于较为复杂的场景中，增加新的命令或接受者都很方便，不会影响调用者和其他类。并且在需要对请求进行记录、撤销和重做等处理时，命令模式是比较好的选择。但是对于一些简单的场景，使用命令模式反而会增加系统的复杂度，较为简单的场景可以使用匿名函数来实现。</p><p>命令模式的优点如下：</p><ol><li>命令模式可实现调用者与被调用者之间的解耦。</li><li>命令模式很容易被扩展，增加新的 Command 很容易，并且无需改变已有的类。</li><li>命令模式支持将多个命令装配成一个复合命令，复合命令实际上是组合模式的一个实例。</li><li>命令模式支持操作的取消和重做。当然这需要 ConcreteCommand 类存储额外的状态信息。</li></ol><h3 id="中介者模式"><a class="anchor" href="#中介者模式">#</a> 中介者模式</h3><p>&lt;img src=&quot;设计模式 /image-20230201205205130.png&quot; alt=&quot;image-20230201205205130&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 中介者模式的要点是将所有对象之间的交互细节抽象到一个独立的类中，这个类叫做中介者类 Mediator。每个对象仍然负责提供原来设计的服务，但是对象之间不再有直接交互，对象之间的交互经由 Mediator 类完成。为了完成某个任务，任何一个对象都可以给 Mediator 发送消息 (调用 Mediator 的方法)，Mediator 再给相关的有能力合作完成该任务的对象发送消息 (调用那些对象中的方法），最后完成一项任务。</p><p>中介者模式的优点如下：</p><ol><li>所有对象的交互行为都被转入到一个独立的中介者对象中，使得用户更容易通过中介者修改对象之间的相互关系行为。当修改一个交互行为的时候，可以通过修改或者更换其中一个具体的中介者子类来完成。另外，将对象的交互转移到一个专门的类中也提高了对象的可重用性。</li><li>因为对象之间不直接有交互，使对象的单元测试更加容易</li><li>低耦合使得一个类的修改不会影响到其他的类。</li></ol><p>中介者模式的缺点如下：</p><ol><li>当对象之间的交互变得复杂时，中介者的代码会变得复杂。</li><li>当对象之间的交互很简单时，使用中介者模式可能会增加系统的复杂性。</li></ol><h3 id="策略模式"><a class="anchor" href="#策略模式">#</a> 策略模式</h3><p>&lt;img src=&quot;设计模式 /image-20230202101611855.png&quot; alt=&quot;image-20230202101611855&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 策略模式定义了一系列的算法，将每一个算法封装起来，并且使它们之间可以相互替换。策略模式让算法的变化不会影响到使用算法的客户。</p><p>在以下的情况之一发生时可以使用策略模式：</p><ol><li>当有多个仅在行为上不同但是相关的类存在时，策略模式提供了一个为一个类配置多种行为之一的方法。</li><li>当一个算法使用用户不应该知道的数据时，使用策略模式可以将算法实现细节隐藏起来，避免暴露与算法相关的复杂细节。注意，虽然可以将算法实现细节封装起来，但是客户程序必须知道各个策略子类的接口。</li><li>当一个类有多种行为，这些行为以大块的条件语句实现时可以使用策略模式，这时可以将条件块移入它们自己的 Strategy 类。</li></ol><p>Context 类有如下作用：</p><ol><li>作为客户类 (Client) 和策略类 (Strategy) 的 “传话筒”，将客户类的请求与由客户类所提供的各种参数传递给策略类。客户类通常创建并且传递一个 ConcreteStrategy 的对象给 Context，然后客户类即可和 context 类单独交互。</li><li>可以将算法所需要的所有数据传递给策略类。</li><li>可以将自己以参数的形式传递给策略的运算，然后当需要时，让策略类调用 Context。</li></ol><p>策略模式的优点：</p><ol><li>得到一系列可以复用的算法，这些算法继承一个共同的抽象类，因此共有的功能可以放到超类中。</li><li>将不同算法封装在不同的策略子类中，使逻辑更加清晰，各个算法可以独立地变化。</li><li>使功能改变或者扩展更容易。具体地说，修改一个算法不必重新编译 “Client” 与 “Context&quot;类。增加一个新算法时，在应用程序暂时还不想使用该新算法的情况下，不必重新编译 “Client&quot; 与 “Context” 类。</li></ol><p>​ 使用策略模式的缺点为，客户程序必须知道不同策略接口的各个子类的行为，必须理解每个子类有哪些不同。因此，在客户类中通常存在许多与策略类各个分支相关的条件语句，用于选择产生策略子类对象，然后将这些对象传递给 Context 类，而 Context 类则直接使用此对象调用策略模式的策略子类的方法。</p><h3 id="状态模式"><a class="anchor" href="#状态模式">#</a> 状态模式</h3><p>&lt;img src=&quot;设计模式 /image-20230202160518421.png&quot; alt=&quot;image-20230202160518421&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 状态模式将不同状态的行为封装在不同的子类中。这样做的优点是程序的状态变化十分明显，不容易发生状态选择错误。另外，该设计也有利于扩展与维护，一般情况下，添加一个状态或者修改一个状态类，只需要少许修改其他的类。</p><p>在下列情况下可以使用状态模式：</p><ol><li>当对象的行为依赖于状态，对象要在运行时改变状态时使用状态模式。</li><li>当操作带有大量依赖于状态的条件语句时使用该模式。通常许多操作都含有相同的条件结构，状态模式将条件结构的每个分支包装成独立分支的类，使得在不同状态下的行为可以独立变化。</li></ol><p>状态模式的优点如下：</p><ol><li>因为状态相关的代码都被封装在各个状态子类中，所以容易添加新的状态，只需要定义并添加新的状态子类和新的状态变化关系即可。有时其他的类也需要较少的修改。</li><li>将不同的状态封装成不同的类使得状态迁移很明确，开且可以防止 Context 类将状态弄混乱。</li></ol><h2 id="软件体系结构概述"><a class="anchor" href="#软件体系结构概述">#</a> 软件体系结构概述</h2><p>​ 软件体系结构对于软件开发具有重要的意义。首先，软件体系结构是软件相关人员之间进行交流的手段。软件体系结构的目标是建立一个一致的系统视图集，从而支持与软件相关的各类人员相互进行交流，特别是支持设计者与最终用户以及设计者与设计者之间的交流。</p><p>​ 此外，软件体系结构是一种高层次的设计复用手段。就像建筑学中有罗马式、哥特式、巴洛克式，拜占庭式等建筑风格一样，在软件中也存在着各种不同的软件体系结构风格，这些风格被广泛应用于各类大型软件设计中。并且，有些软件架构还会被实现为一些基础性的软件实体，如软件框架及相关的构件库，从而为软件开发带来极大的便利性。</p><p>​ 最后，软件体系结构是早期关键设计决策的体现。软件架构将决定软件的技术选型、项目团队的分工，为软件的设计、开发、测试及维护等提供准则和依据，并且软件体系结构还直接决定着软件的质量。</p><h4 id="软件体系结构与软件质量属性"><a class="anchor" href="#软件体系结构与软件质量属性">#</a> 软件体系结构与软件质量属性</h4><p>​ 架构的优劣取决于各种因素，这些因素通常称为软件质量 (Software Qualities) 属性。这些质量属性主要包括性能、可伸缩性、可用性、可维护性、安全性、易用性、可重用性、可测试性及可移植性等。</p><p>下面简要对上述各种软件质量属性及其对策进行分析。</p><ol><li>性能 (Performance)</li></ol><p>​ 性能是指软件运行时系统的 “时间及空间” 效率，即系统的反应时间及所占存储空间的大小。通常更关注的是系统反应时间，因为这直接影响用户体验。架构师解决性能问题的手段通常有集群、缓存、异步消息传输等。</p><ol start="2"><li>可伸缩性 (Scalability)</li></ol><p>​ 可伸缩性是系统能够平稳应对不断增长的处理任务的能力。良好的可伸缩性能够保证系统在不同的负载水平下维持相同或相近的性能。架构师应对可伸缩性的手段通常是集群。</p><ol start="3"><li>可用性 (Availability)</li></ol><p>​ 可用性也称健壮性 (Robustness) ，是指系统的容错及从错误中恢复的能力，以保证系统无论何时都能正确运行。架构师应对可用性的手段有集群、点对点 (Peer-to-peer) 架构等。</p><ol start="4"><li>可维护性 (Modifiability)</li></ol><p>​ 可维护性是指系统应对变化的能力，系统可被修改的容易程度。架构师的手段包括关注点分离、分层、企业服务总线等。</p><ol start="5"><li>安全性 (Security)</li></ol><p>​ 安全性是阻止未授权用户访问系统的能力，从而保证合法用户的数据安全。架构师的安全手段主要有防火墙、入侵检测、加密、数字签名等。</p><ol start="6"><li>易用性 (Usability)</li></ol><p>​ 易用性是指用户学习使用软件的容易程度、软件的使用效率等。架构师的手段有统一界面风格、用户界面与业务逻辑分离等。</p><ol start="7"><li>可重用性 (Reusability)</li></ol><p>​ 可重用性是指软件代码的可重用程度，重用是提高开发效率，提高代码质量及降低维护代价的重要手段，架构师提高可重用性的手段主要包括关注点分离、分层、领域工程等。</p><ol start="8"><li>可测试性 (Testability)</li></ol><p>​ 可测试性是指软件可被测试的容易程度。通常包括被测试的对象状态是否可控、是否可独立地被测试，测试结果是否容易被观测，是否支持自动化测试等。架构师的策略主要包括用户界面与业务逻辑分离、接口与实现分离等。</p><ol start="9"><li>可移植性 (Portability)</li></ol><p>​ 可移植性是指软件不经修改或稍加修改即可在不同平台运行的能力。架构师的策略包括虚拟机、面向服务的架构等。</p><p>​ 上述这些质量属性之间可能是有冲突的。如要实现系统的安全性，可能会对系统性能产生负面影响。架构师需要在这些质量属性之间进行权衡，做出一个完美的折中方案。</p><h4 id="软件体系结构的风格"><a class="anchor" href="#软件体系结构的风格">#</a> 软件体系结构的风格</h4><p>&lt;img src=&quot;设计模式 /image-20230203101028584.png&quot; alt=&quot;image-20230203101028584&quot; style=&quot;zoom: 50%;&quot; /&gt;</p><h2 id="经典软件体系结构"><a class="anchor" href="#经典软件体系结构">#</a> 经典软件体系结构</h2><h3 id="调用-返回风格-软件体系结构"><a class="anchor" href="#调用-返回风格-软件体系结构">#</a> 调用 - 返回风格 软件体系结构</h3><p>​ 利用调用 - 返回风格软件体系结构设计的软件系统使用的是分而治之策略，其主要思想是将一个复杂的大系统分解为一些子系统，以便降低复杂度，并且增加可修改性。这种系统的程序执行顺序通常只由一个单线程控制。</p><h4 id="主程序-子程序软件体系风格"><a class="anchor" href="#主程序-子程序软件体系风格">#</a> 主程序 - 子程序软件体系风格</h4><p>&lt;img src=&quot;设计模式 /image-20230203111501991.png&quot; alt=&quot;image-20230203111501991&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 主程序 - 子程序软件体系结构在设计上使用层次化的划分方法，该体系结构中使用由编程语言直接支持的单一的控制线程。子程序的结构是明确的，子程序通常组成程序模块。子程序的调用呈现层次状，其正确与否往往取决于其调用的子程序的正确与否。</p><p>相对于非结构化设计，结构化设计有以下优点。</p><ol><li>逻辑设计与物理设计分开。</li><li>开发过程中形成一套规范化的文档，以便后期修改和维护。</li></ol><p>​ 结构化设计的缺点为开发周期长，系统难以适应环境的变化以及开发过程复杂繁琐。结构化设计适用于组织相对稳定、业务处理过程规范、需求明确且在一定时期内不会发生大的变化的大型复杂系统的开发。经验表明，当程序小于 10 万行时，结构化程序设计比较成功。当程序大于 10 万行时，结构化程序设计表现不佳。原因是当程序规模非常大时，程序代码编写耗时长，软件测试变得越来越困难，难以保证软件的可靠性。</p><p>自顶向下的程序设计方法存在如下问题。</p><ol><li>功能演化困难。自上而下的方法创建了符合最初需求的较好的软件系统模型。但是当系统改变或者增加新的需求时，功能结构变得越来越笨拙。由于软件被设计为树形结构，修改与更新通常要求广泛的 “剪枝” 与 “嫁接”，使系统维护变得越来越困难。</li><li>现实中的系统功能不容易描述。大型交互系统很难从功能方面进行刻画。很多大型系统没有 “顶部”，例如，一个涉及数据查询、数据改变与保持数据一致性的软件系统，如果按照功能化的自顶向下的设计，则该系统可能被设计成为一个基于一个唯一的 “虚拟” 顶点并且会产生非常复杂的结构。</li><li>功能化设计丢掉了数据与数据结构。自顶向下设计中捕捉不到所设计软件涉及的数据，通常，同样的数据被多个函数共享 (如更新、删除、插入和询问数据库表)。因为系统分解只突出问题的功能方面，数据结构对问题的影响被丢失了。</li><li>由功能设计得到的软件产品产生的可复用的代码较少。自顶向下的设计连续不断地将系统分为越来越简单的程序块。每个程序块被单独地分析确定，没有太多地考虑系统的其他部分。但是每个程序单元的设计都仅仅考虑极为有限的需求，因为这些特定的需求不太可能出现于下个问题中，所以产生的设计与代码没有普遍性与通用性，从而通常不可复用。</li></ol><h4 id="面向对象软件体系结构"><a class="anchor" href="#面向对象软件体系结构">#</a> 面向对象软件体系结构</h4><p>&lt;img src=&quot;设计模式 /image-20230206104149469.png&quot; alt=&quot;image-20230206104149469&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 一个对象是一个具有状态 (State ，即包含数据) 与行为的实体。一个对象存储它的状态在域中，并且通过方法暴露它的行为。方法对其所在对象的内部状态进行操作，并且是对象之间交流的主要机制。面向对象设计隐藏对象的内部状态，并且要求所有对象之间的交互都通过该对象的方法，这叫做数据封装，是面向对象编程的基本原则。</p><p>​ 在面向对象设计与编程中，一个类是一个结构体，使用该结构体可以产生该类的对象。一个类描述了使用该类创建的对象的共有状态与行为。一个类的对象也可以被称为该类的实例。</p><p>面向对象设计的特点：</p><ol><li>封装性 (Encapsulation)：限制对特定信息的访问。</li><li>继承性 (Inheritance)：共享同一个功能定义。继承性是一个对已经存在的类的复用的重要手段。</li><li>动态绑定性 (Dynamic Binding)：通常在使用一个层次类的时候，声明一个超类类型的变量，在程序运行以前，不知道创建哪个类的对象，而只是在运行时才动态决定要生成的子类的对象和调用哪个操作（方法或函数)。动态绑定是面向对象程序设计的重要特点之一。</li><li>复用与可维护性 (Reuse and Maintenance)：这是因为采用了封装与局部化。</li><li>对象是对现实世界的抽象并且可以自己管理自己。对象中包含了数据与管理这些数据的方法。</li><li>系统功能通过对象服务表示：对象的接口提供了一系列的方法，包括方法名、参数类型。在整个软件系统中有很多对象，每个对象所提供的方法提供了一些服务。整个系统的功能通过所有的类所提供的方法完成。</li><li>共享数据区域被取消：在面向对象设计中，所有的数据都被封装在各个类之中，因此不存在全局变量。</li><li>对象可以是分布的：分布的对象通常指的是设计成在一起工作的软件模块，但是位于被网络连接在一起的多台计算机中或者在同一台计算机的不同过程中。</li></ol><p>面向对象设计的优点：</p><ol><li>容易维护：因为一个对象将其内部表示对客户程序隐藏起来，所以可以改变其内部实现而不影响那些客户程序。</li><li>可复用性好：对象为适合复用的构件。</li><li>映射现实世界：对于许多软件系统都存在明显的现实世界的实体到系统的对象。</li><li>容易对一个系统进行剖分：面向对象设计将数据与数据访问、操纵方法绑定在一起形成类，由类产生对象。使得软件设计者将整个问题剖分为一系列的互相交互的对象的集合。</li></ol><p>面向对象设计的缺点：</p><ol><li>面向对象程序占用内存较大。这是因为在程序运行中，每个新被创建的对象都必须占用一块内存，而在面向对象程序中，往往有大量的对象被创建。因此和结构化设计产生的程序相比较，面向对象程序占用内存更多。</li><li>一个对象要和另外一个对象交互，该对象必须知道另外一个对象的身份，包括对象名、方法名和参数类型等。</li></ol><h3 id="数据流风格-软件体系结构"><a class="anchor" href="#数据流风格-软件体系结构">#</a> 数据流风格 软件体系结构</h3><p>​ 数据流系统是一个软件系统，在该系统中，数据的可用性控制计算 (数据处理过程)，过程间的数据有序流动决定了系统的结构。数据的流动方式是明确的。一般情况下，数据可以以任何方式流动，但这样的数据流系统通常较为复杂。往往使用的是相对简单的数据流动方式。</p><p>&lt;img src=&quot;设计模式 /image-20230206113508112.png&quot; alt=&quot;image-20230206113508112&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 数据流系统的各软件组件在无数据到达时处于休眠状态，当有数据到达时，该软件组件被激活，开始对数据进行处理。软件工程师关心的是程序中控制流的轨迹。数据可以伴随着控制，但是数据不处于控制地位，重要的是程序的执行顺序。在系统设计中，人们关注数据是怎样流动的，关心数据的可用性、变换与延迟。</p><p>​ 数据流风格软件体系结构将整个软件系统看作由一系列作用在连续数据集合上的 “变换” 组成。数据和作用于其上的操作是互相独立的。软件系统被分解为一些数据处理单位或称为组件，数据流控制数据处理顺序。在纯数据流系统中，过程间无其他的互动。数据流系统架构中的组件将其输入数据 “变换” 为对应的输出数据。可以使用 IO 流、I/O 文件、缓冲（Buffer)、管道流，或者其他连接类型来实现子系统组件之间的连接。</p><p>​ 数据流风格软件体系结构应用于定义明确的一系列带有有序输入与输出的独立数据变换，数据传输可以是整块的数据传输或者以数据流的形式进行。这些处理都不需要用户 / 系统交互。典型的实例是商业数据处理和编译器。</p><p>​ 在数据流风格体系结构中，组件是高度独立的，不存在全局控制组件的行为。处理单元可以并发工作，甚至是在不同的计算机上并发工作，这个特点使其可以处理连续的流数据。数据流风格体系结构中的组件是可以被重复使用的，且在保证输入与输出接口都不变的情况下，可以独立修改一个组件，而不影响其他的组件。</p><p>​ 在实现数据流风格软件体系结构的软件时，需要特别注意组件之间的同步 (Syncronization) 问题。</p><h4 id="顺序批处理-软件体系结构"><a class="anchor" href="#顺序批处理-软件体系结构">#</a> 顺序批处理 软件体系结构</h4><p>&lt;img src=&quot;设计模式 /image-20230206114510335.png&quot; alt=&quot;image-20230206114510335&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 顺序批处理数据流系统 (Batch Sequential Dataflow System) 是数据流风格体系结构的一个子类型。在该系统中，组件为独立的程序，并且<strong>这些组件按照先后顺序处理</strong>，即只有<strong>当一个组件的运行彻底结束以后，下一个组件才能开始执行</strong>。可以认为，数据在处理步骤之间的传输是成批的，而不是以数据流的方式进行的。</p><h4 id="管道-过滤器-软件体系结构"><a class="anchor" href="#管道-过滤器-软件体系结构">#</a> 管道 - 过滤器 软件体系结构</h4><p>&lt;img src=&quot;设计模式 /image-20230206114437599.png&quot; alt=&quot;image-20230206114437599&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 与批处理结构相似，但是实际上它们却有本质的区别。在管道 - 过滤器软件体系结构中，每个组件都有一组输入和输出，组件读入输入数据流，经过数据处理，然后产生输出数据流。这个过程通常通过对输人流数据进行增量式的 “变换” 或者称为 “计算” 来完成，所以在输入被完全消费之前，输出便产生了。因此，这里的组件被称为过滤器，这种风格的连接件就像是数据流传输的管道，将一个过滤器的输出传到另一过滤器的输入。</p><h3 id="事件系统-软件体系结构"><a class="anchor" href="#事件系统-软件体系结构">#</a> 事件系统 软件体系结构</h3><p>​ 在事件驱动架构中，事件是由一个对象发出，以通知另一个对象进行处理，这些对象之间不需要直接交互。当一个事件发生时，事件发送者通过事件频道向事件处理者发送事件通知，然后事件处理者对事件进行处理。这样，事件驱动架构能够解耦系统的各个部分，从而使系统更具可扩展性和可维护性。</p><p>&lt;img src=&quot;设计模式 /image-20230207153105934.png&quot; alt=&quot;image-20230207153105934&quot; style=&quot;zoom:50%;&quot; /&gt;</p><h4 id="观察者模式"><a class="anchor" href="#观察者模式">#</a> 观察者模式</h4><p>​ 观察者模式是一种常用的设计模式，它定义了对象之间的一对多依赖关系，一个对象的状态改变会通知其他的对象。在事件系统中，事件是观察者模式的具体实现，事件发生时，事件处理者可以通过订阅事件来接收事件通知，并进行相应的处理。</p><p>​ 观察者模式通过定义抽象类或接口，实现对象之间的解耦，使得系统更加灵活、易扩展。在实现事件系统时，可以使用观察者模式来实现事件的订阅和发布，同时通过抽象类和接口等方式实现系统的灵活性。</p><p>&lt;img src=&quot;设计模式 /image-20230207154525065.png&quot; alt=&quot;image-20230207154525065&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>观察者模式的工作原理如下：</p><ol><li>被观察者保持一个数据结构，用于记载动态添加的观察者。</li><li>对被观察者状态感兴趣的对象 (观察者)，应该调用被观察者的 <code>register()</code> 方法将自己注册为它的一个观察者。</li><li>每当被观察者的状态发生改变的时候，它将使用方法 <code>notifyObservers()</code> 通知已经注册的观察者。</li><li>当接到通知以后，每个观察者都将查询被观察者的状态，以便保持状态同步。根据新的状态，观察者将决定做一些图标更新或者其他相关的操作。</li></ol><p>观察者模式具有如下优点：</p><ol><li>当动态添加一些不同的观察者时，不需要对被观察者类进行修改。</li><li>当被观察者类的状态或者逻辑发生变化时，观察者不受影响。</li></ol><h3 id="层次-软件体系结构"><a class="anchor" href="#层次-软件体系结构">#</a> 层次 软件体系结构</h3><p>​ 层次体系结构是指将软件设计成层次结构，每个层为其上层提供服务，同时又是其下层的客户。</p><p>&lt;img src=&quot;设计模式 /image-20230207173615632.png&quot; alt=&quot;image-20230207173615632&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>层次软件体系结构的缺点如下：</p><ol><li>不是所有的系统都容易被组织成层次结构。</li><li>有时即便一个系统可以从逻辑上被组织成一个层次结构，但是出于性能方面的考虑，可能要求层次结构中的逻辑上的较高层次与较低层次之间有比较紧密的耦合，从而迫使软件设计 / 实现者考虑跨层调用，而这是违反层次架构原理的。</li><li>正确的层次抽象往往可能很困难。</li></ol><h3 id="mvc-软件体系结构"><a class="anchor" href="#mvc-软件体系结构">#</a> MVC 软件体系结构</h3><p>​ MVC 体系结构将一个互动的应用分成三部分：Model、View 和 Controller。粗略地说，Model 包含核心功能与数据，View 为用户显示信息， Controller 处理用户输入。因此，根据责任分离与增加可扩展性的原则，Model 应该被设计成独立于特定的输入行为和输出表示的程序。View 模块将模型中的数据显示给用户。而因为相同的数据可以有不同形式的显示方法，所以一个 Model 可以有很多个 View。每个 View 可以拥有与之相关联的 Controller 组件。</p><p>&lt;img src=&quot;设计模式 /image-20230207174145192.png&quot; alt=&quot;image-20230207174145192&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>一般形式的 MVC 结构类图：</p><p>&lt;img src=&quot;设计模式 /image-20230207174221745.png&quot; alt=&quot;image-20230207174221745&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>采用观察者模式的 MVC 结构类图：</p><p>&lt;img src=&quot;设计模式 /image-20230207173926943.png&quot; alt=&quot;image-20230207173926943&quot; style=&quot;zoom:50%;&quot; /&gt;</p><h2 id="基于网络的软件体系结构"><a class="anchor" href="#基于网络的软件体系结构">#</a> 基于网络的软件体系结构</h2><h3 id="client-server-软件体系结构"><a class="anchor" href="#client-server-软件体系结构">#</a> Client - Server 软件体系结构</h3><p>​ 客户端 - 服务器软件体系结构是一个多样性的、基于消息的模块基础结构。其目的是改善可用性、灵活性、互操作性与可伸缩性。客户端被定义为是一个服务请求软件，服务器端被定义为一个服务提供软件，客户端与服务器互相通信。</p><h4 id="一层-client-server-软件体系结构"><a class="anchor" href="#一层-client-server-软件体系结构">#</a> 一层 Client - Server 软件体系结构</h4><p>&lt;img src=&quot;设计模式 /image-20230215090356839.png&quot; alt=&quot;image-20230215090356839&quot; style=&quot;zoom:50%;&quot; /&gt;</p><h4 id="两层-client-server-软件体系结构"><a class="anchor" href="#两层-client-server-软件体系结构">#</a> 两层 Client - Server 软件体系结构</h4><p>&lt;img src=&quot;设计模式 /image-20230215090646472.png&quot; alt=&quot;image-20230215090646472&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>两层客户端 - 服务器的工作原理如下。</p><ol><li>客户端发送 SQL 语句进行一项数据查询，或者要求更新数据库。</li><li>服务器端数据库管理系统 (DBMS) 可以协助用户查询，并且将查询结果返回给客户端；或者更新数据库，例如修改一个表中某一个域的值，或者写入新的商业记录。</li></ol><p>​ 胖服务器端将更多的功能放到服务器端，而胖客户端将更多的功能放到客户端。在胖客户端的情况，多数应用在客户端运行。</p><p>优点：</p><ul><li>与文件共享系统相比，两层客户端 - 服务器发送请求与回答而不是文件，从而降低网络使用。</li></ul><p>缺点：</p><ol><li>它是单一服务器且以局域网为中心的，所以难以扩展至大型企业广域网或因特网。</li><li>它受限于供应商，程序的升级维护必须由供应商重新开发扩展。</li><li>数据库被厂商锁定，因为用户的 GUI 代码直接与数据库服务器绑定，依赖于一个特定―商的技术将会使用户更换其他产品很困难。</li><li>当配置到远程环境的时候，两层的客户端 - 服务器结构管理起来比较困难。尤其是对于胖客户端的情况，就更难管理。</li><li>在软件上常常呈现出胖客户端，用户必须在客户端安装特定的客户端应用程序，而且当越来越多的企业的业务逻辑写在客户端应用程序中的时候，程序维护变得越来越困难。程序升级需要每个客户端都要安装新的客户端应用程序，同时，对于程序开发商来说，程序模块的重用性差，各个模块相对独立。</li><li>很难管理大量的客户机。</li></ol><h4 id="三层-client-server-软件体系结构"><a class="anchor" href="#三层-client-server-软件体系结构">#</a> 三层 Client - Server 软件体系结构</h4><p>&lt;img src=&quot;设计模式 /image-20230215091047755.png&quot; alt=&quot;image-20230215091047755&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>三层客户端 - 服务器体系结构的主要优点如下：</p><ol><li>具有良好的灵活性和可扩展性。当一层改变的时候不影响其他层的改变。对于环境和应用条件经常变动的情况，只要应用层的实现进行相应改变，就能够达到目的。</li><li>开发语言独立。例如，客户端可以由 C++ 开发，中间层可以由 Java 开发。</li><li>具有可共享性。单个应用服务器可以为处于不同平台的客户应用程序提供服务，在很大程度上节省了开发时间和资金投入。</li><li>具有较好的安全性。在这种结构中，客户应用程序不能直接访问数据，应用服务器不仅可控制哪些数据被改变和被访问，而且还可以控制数据的改变和访问方式。</li><li>增强了企业对象的重复可用性。“企业对象” 是指封装了企业逻辑程序代码，能够执行特定功能的对象。随着组件技术的发展，这种可重用的组件模式越来越为软件开发所接受。</li><li>成为真正意义上的瘦客户端，从而具备了很高的稳定性、延展性和执行效率。</li><li>可以将服务集中在一起管理，统一服务于客户端，从而具备了良好的容错能力和负载平衡能力。</li></ol><blockquote><p>​ <strong>三层层次体系结构</strong>与<strong>三层客户端 - 服务器体系结构</strong>的主要区别是，在通常的层次体系结构中所涉及的层次指的是逻辑层，而三层客户端–服务器体系结构中所涉及的层是从物理方面考虑的层。即客户端运行在 PC 上，服务层被部署在应用服务器上，数据库层包含数据库与数据库管理系统软件，被部署在数据库服务器上。</p></blockquote><h3 id="p2p-软件体系结构"><a class="anchor" href="#p2p-软件体系结构">#</a> P2P 软件体系结构</h3><p>P2P (Peer to Peer) 思想：</p><ol><li>P2P 使得任何的网络感知设备可以为另外一个网络感知设备提供服务。</li><li>P2P 网络的一个节点既是客户端，又是服务器。</li><li>P2P 计算通过直接交换的方式共享资源。</li></ol><h4 id="第一代p2p-集中目录式p2p"><a class="anchor" href="#第一代p2p-集中目录式p2p">#</a> 第一代 P2P - 集中目录式 P2P</h4><p>&lt;img src=&quot;设计模式 /image-20230215092323494.png&quot; alt=&quot;image-20230215092323494&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 以 Napster 为代表的集中目录式 P2P 软件体系结构采用中央目录服务器管理 P2P 各结点，PP 结点向中央目录服务器注册关于名称、地址、资源、元数据、所能提供的服务等自身的信息，但所有内容存储在各结点中而非服务器上。当一个结点要查找某种服务的时候，该结点首先连接到目录服务器，然后根据目录服务器中的信息查询以及网络流量和延迟等信息来选择与定位其他对等点。一旦找到了所要连接的结点，则直接与其建立连接，而不必经过中央目录服务器进行。目录服务器除了提供各结点的基本的已注册信息之外，并不真正地承担任何其他的功能。</p><h4 id="第二代p2p-纯p2p"><a class="anchor" href="#第二代p2p-纯p2p">#</a> 第二代 P2P - 纯 P2P</h4><p>&lt;img src=&quot;设计模式 /image-20230215092548491.png&quot; alt=&quot;image-20230215092548491&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 纯 P2P 体系结构也被称为广播式的 P2P 模型，它没有集中的中央目录服务器，每个用户随机接入网络，并与自己相邻的一组邻居结点通过端到端连接构成一个逻辑覆盖的网络。每个对等结点都可以既作为客户端又作为服务器，且与它们的邻居都有相同的能力。每个对等结点都作为网络中的一个结点，没有中心路由器。</p><p>​ 纯 P2P 网络结构有两种路由结构：分布式目录的方式与直接发送消息的方式。</p><p>一个采用纯 P2P 体系结构的实例是 Gnutella 协议。Gnutella 协议具有如下特性：</p><ol><li>可靠性：如果代表一个结点的计算机的软件系统或者硬件系统出现故障，整体网络也不会受到影响。</li><li>开放性：Gnutella 协议允许任何类型交换文件</li><li>匿名性：Gnutella 协议是匿名的，使用该协议不需要提供名字或电子邮件地址。</li><li>资源共享性：Gnutella 协议还提供了资源共享的机制，人们可以共享任何东西，如家庭照片、计算机程序和家庭电影等。</li></ol><p>纯 P2P 软件体系结构具有如下缺点。</p><ol><li>服务发现限制与困难。在大型 PP 网络中，查询会遇到查询范围小的困难。</li><li>由于没有一个对等结点知道整个网络的结构，网络中的搜索算法以泛洪的方式进行，控制信息的泛滥消耗了大量带宽并且可能很快造成网络拥塞甚至网络的不稳定，从而导致整个网络的可用性较差。</li></ol><h4 id="第三代p2p-非结构化的层次纯p2p"><a class="anchor" href="#第三代p2p-非结构化的层次纯p2p">#</a> 第三代 P2P - 非结构化的层次纯 P2P</h4><p>&lt;img src=&quot;设计模式 /image-20230215093204067.png&quot; alt=&quot;image-20230215093204067&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>​ 在非结构化的层次纯 P2P 架构中，结点被分为叶子结点 (Leaf Peer) 与超级结点 (Super Peer) 两类。叶子结点仅仅同它们的超级结点维持连接；而超级结点除了与自己的叶子结点维持连接以外，还连接到超级结点覆盖网 (Overlay Network) 中的其他的超级结点。超级结点充当自己的叶子结点的代理结点。根据它的容量和能力，一个超级结点可能连接多个叶结点。在寻找资源的过程中，叶结点仅仅负责初始化查询请求，接收相关联的查询答复，如果被请求的资源刚好被存储在该结点的话，则由该结点负责回答请求。除了本组的超级结点之外，叶子结点不会向其他的超级结点传递询问。超级结点负责将查询请求传递到其他的超级结点，或者，如果它准确地知道自己的某个叶结点能回答该请求，它会将该请求传递给该叶子结点。此外，超级结点也有叶结点的正常功能，即初始请求和收到被关联的答复。在超级结点层面也使用基于泛洪机制传递查询请求。</p><p>​ 非结构化的层次纯 P2P 体系结构通过引入建立在原来的对等网络之上的超级结点覆盖网络，使得网络查询效率有了明显的改善。非结构化的层次纯 P2P 系统的查询率也大大地优越于原始的纯 P2P 体系结构。</p><h3 id="网格计算-软件体系结构"><a class="anchor" href="#网格计算-软件体系结构">#</a> 网格计算 软件体系结构</h3><p>​ 网格计算是指为了达到一个共同的目标，聚集多个行政领域的计算机资源来完成一项特定的任务。网格计算的一个主要策略是使用中间件将一个程序分布到许多计算机之中，有时计算机的数目可以是成千上万。网格计算涉及分布式方式的计算，有时也涉及大规模的集群计算 (Cluster Computing) 系统。网格的规模可能有很大的不同，从企业内部结点计算机网络的合作，到横跨许多大企业内部结点网络的大型协作。</p><p>一个计算网格是一个满足如下要求的系统:</p><ol><li>使本来不属于中心控制的资源进行合作。</li><li>使用标准的、开放的，通用的协议。</li><li>提供有相当质量的服务。</li></ol><p>​ 根据该定义，网格计算的主要目的是协同多个组织的多种计算资源，达到为了一个特定目的的计算。资源的类型不但可以包含具有计算能力的多种计算机，而且也可以包括数据库、传感器、流数据等资源。</p><h3 id="soa-软件体系结构-与-web-services"><a class="anchor" href="#soa-软件体系结构-与-web-services">#</a> SOA 软件体系结构 与 Web Services</h3><p>​ 面向服务的体系结构 (Service-Oriented Architecture，SOA) 是为了满足企业对电子商务中各分立系统之间通信的要求，创建的一套全新的基于互联网的开放通信框架。Web Services 是 SOA 体系结构的实现。</p><h4 id="soa软件体系结构"><a class="anchor" href="#soa软件体系结构">#</a> SOA 软件体系结构</h4><p>历史上有三个基本的电子商务模型：</p><ul><li>企业对企业 (B2B)</li><li>企业对消费者 (B2C)</li><li>消费者对消费者 (C2C)</li></ul><p>​ 在 SOA 体系结构中，企业的内部业务可以暴露给其他企业，这种为了某种目的而提供给其他企业使用的操作称为服务。SOA 定义了两个计算实体之间的交互，是利用网络上已有的服务创建新的软件应用的软件体系结构。该架构提倡软件组件之间松散耦合，以便实现组件的复用。在 SOA 应用程序中，一个服务是一个完整定义的商业功能的实现，并且可以被不同的应用或者业务过程使用。</p><p><img data-src="image-20230215094702377.png" alt="image-20230215094702377"></p><p>SOA 体系结构遵循以下的原则：</p><ol><li>分离服务接口及其实现。</li><li>服务消费者将服务看成是支持一个特定的请求格式的端点。</li><li>服务消费者不关心服务是如何实现的。</li></ol><h4 id="web-services"><a class="anchor" href="#web-services">#</a> Web Services</h4><p>​ Web service 是 “一个被设计成支持网络上的计算机对计算机的可互操作的软件系统”。它包含一个自描述的接口 (即服务描述语言 WSDL 描述的接口)。其他系统与该 Web Service 通过简单对象访问协议 (SOAP) 进行交互。</p><p>​ Web Services 通过 HTTP 协议传递 XML 格式的交互信息。通过这种技术中立的方式，Web Services 提供了一种能够在异构应用之间进行互操作的标准方案。Web Services 可以被松散地组装在一起，以便实现更为复杂的业务操作。即便是原有提供简单服务的程序也可以通过互动而实现服务增值。</p><p>​ 由于 Web Services 实现了 SOA 体系结构，所以 Web Services 具有服务发现、绑定与执行的工作机制。</p><h2 id="云计算软件体系结构"><a class="anchor" href="#云计算软件体系结构">#</a> 云计算软件体系结构</h2><p>​ 作为一种新兴的计算模式，云计算能够将各种资源以服务的形式通过网络提供给用户。这些服务资源可分为三类，分别是网络应用、应用的开发和运行平台以及虚拟化后的计算和存储资源。相应地，可以将提供这些资源的服务分别称为软件即服务 (Software as a Service ，SaaS)、平台即服务 ( Platform as a Service，PaaS) 和基础设施即服务 (Infrastructure as a Service ， IaaS)。</p><p>​ 而为了提供上述三类服务，典型的云计算体系结构可分为 4 个层次：硬件层、基础设施层、平台层和应用层。</p><p>&lt;img src=&quot;设计模式 /image-20230215114727580.png&quot; alt=&quot;image-20230215114727580&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>支撑云计算的关键技术主要有：</p><ul><li>集群</li><li>虚拟化</li><li>大规模分布式数据存储</li><li>海量数据处理</li><li>多租户体系结构</li></ul><p>​ 网格计算主要面向科研领域，强调强大的分布式计算能力。网格计算通常借助由许多连接到网络的松散耦合的计算机一起组成的 “超级虚拟计算机” 来执行大规模科学计算任务，且往往并不以商业盈利为目的。</p><p>​ 而云计算主要面向商业领域，强调计算资源的服务化。云计算的核心思想是将各种资源以服务的形式通过网络提供给用户，这些服务资源可以是网络应用软件，软件运行开发平台或者物理的计算和存储资源，这些资源属于云计算服务提供商，而不属于用户，但用户可以通过支付租金的方式来使用这些资源。</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-02-15 17:11:14" itemprop="dateModified" datetime="2023-02-15T17:11:14+08:00">2023-02-15</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Ling yunchi 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Ling yunchi 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Ling yunchi 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Ling yunchi <i class="ic i-at"><em>@</em></i>QWQ</li><li class="link"><strong>本文链接：</strong> <a href="https://ling-yunchi.github.io/2023/01/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/" title="设计模式">https://ling-yunchi.github.io/2023/01/30/设计模式1/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/01/27/cuda/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclflwv2aj20zk0m84qp.jpg" title="cuda"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>cuda</h3></a></div><div class="item right"><a href="/2023/01/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclh0m9pdj20zk0m8hdt.jpg" title="设计模式"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>设计模式</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">软件开发与设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">设计模式概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%84%8F%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">概念与意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">软件设计模式与软件体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.3.</span> <span class="toc-text">软件设计模式的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">创建型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">工厂方法与抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">简单工厂方法模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">工厂方法模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">抽象工厂模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">生成器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">单例模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">结构型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">组合模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%89%E5%85%A8%E5%BD%A2%E5%BC%8F%E4%B8%8E%E9%80%8F%E6%98%8E%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">组合模式的安全形式与透明形式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">类适配器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">对象适配器模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">外观模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.4.</span> <span class="toc-text">桥接模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">行为型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">迭代器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">访问者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">命令模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.4.</span> <span class="toc-text">中介者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.5.</span> <span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.6.</span> <span class="toc-text">状态模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.</span> <span class="toc-text">软件体系结构概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">软件体系结构与软件质量属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">软件体系结构的风格</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.</span> <span class="toc-text">经典软件体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-%E8%BF%94%E5%9B%9E%E9%A3%8E%E6%A0%BC-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.1.</span> <span class="toc-text">调用 - 返回风格 软件体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F-%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">主程序 - 子程序软件体系风格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">面向对象软件体系结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E9%A3%8E%E6%A0%BC-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.2.</span> <span class="toc-text">数据流风格 软件体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%89%B9%E5%A4%84%E7%90%86-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">顺序批处理 软件体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93-%E8%BF%87%E6%BB%A4%E5%99%A8-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">管道 - 过滤器 软件体系结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.3.</span> <span class="toc-text">事件系统 软件体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">观察者模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.4.</span> <span class="toc-text">层次 软件体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mvc-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.5.</span> <span class="toc-text">MVC 软件体系结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.</span> <span class="toc-text">基于网络的软件体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#client-server-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.1.</span> <span class="toc-text">Client - Server 软件体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%B1%82-client-server-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">一层 Client - Server 软件体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E5%B1%82-client-server-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">两层 Client - Server 软件体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%B1%82-client-server-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">三层 Client - Server 软件体系结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#p2p-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.2.</span> <span class="toc-text">P2P 软件体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%BB%A3p2p-%E9%9B%86%E4%B8%AD%E7%9B%AE%E5%BD%95%E5%BC%8Fp2p"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">第一代 P2P - 集中目录式 P2P</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%BB%A3p2p-%E7%BA%AFp2p"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">第二代 P2P - 纯 P2P</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%BB%A3p2p-%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BA%AFp2p"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">第三代 P2P - 非结构化的层次纯 P2P</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E8%AE%A1%E7%AE%97-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.3.</span> <span class="toc-text">网格计算 软件体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#soa-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%B8%8E-web-services"><span class="toc-number">1.7.4.</span> <span class="toc-text">SOA 软件体系结构 与 Web Services</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#soa%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">SOA 软件体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#web-services"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">Web Services</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.</span> <span class="toc-text">云计算软件体系结构</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Ling yunchi" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Ling yunchi</p><div class="description" itemprop="description">qwqqqq</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">53</span> <span class="name">文章</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpbmcteXVuY2hp" title="https:&#x2F;&#x2F;github.com&#x2F;Ling-yunchi"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/01/27/cuda/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/01/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Ling yunchi @ Ling Yunchi</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/01/30/设计模式1/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->